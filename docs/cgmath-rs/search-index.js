var searchIndex = {};
searchIndex['cgmath'] = {"items":[[0,"","cgmath","Computer graphics-centric math."],[0,"array","",""],[6,"Array1","cgmath::array","An array containing elements of type `Element`"],[10,"ptr","","Get the pointer to the first element of the array.",0],[10,"mut_ptr","","Get a mutable pointer to the first element of the array.",0],[10,"i","","Get a shared reference to the `i`th value.",0],[10,"mut_i","","Get a mutable reference to the `i`th value.",0],[10,"swap_i","","Swap the elements at indices `i` and `j` in-place.",0],[10,"replace_i","","Replace an element in the array.",0],[9,"map","","Apply a function to each element.",0],[6,"Array2","","A column-major array"],[10,"ptr","","Get the pointer to the first element of the array.",1],[10,"mut_ptr","","Get a mutable pointer to the first element of the array.",1],[10,"c","","Get a shared reference to a column of this array.",1],[10,"mut_c","","Get a mutable reference to a column of this array.",1],[10,"swap_c","","Swap two columns of this array.",1],[10,"replace_c","","Replace a column in the array.",1],[9,"r","","Get a row from this array by-value.",1],[9,"swap_r","","Swap two rows of this array.",1],[10,"cr","","Return a shared reference to the element at column `c` and row `r`.",1],[10,"mut_cr","","Return a mutable reference to the element at column `c` and row `r`.",1],[10,"swap_cr","","Swap the values at index `a` and `b`",1],[9,"map","","Apply a function to each column.",1],[0,"matrix","cgmath","Column major, square matrix types and traits."],[1,"Matrix2","cgmath::matrix","A 2 x 2, column major matrix"],[11,"x","","",2],[11,"y","","",2],[1,"Matrix3","","A 3 x 3, column major matrix"],[11,"x","","",3],[11,"y","","",3],[11,"z","","",3],[1,"Matrix4","","A 4 x 4, column major matrix"],[11,"x","","",4],[11,"y","","",4],[11,"z","","",4],[11,"w","","",4],[6,"Matrix","",""],[9,"mul_s","","Multiply this matrix by a scalar, returning the new matrix.",5],[9,"div_s","","Divide this matrix by a scalar, returning the new matrix.",5],[9,"rem_s","","Take the remainder of this matrix by a scalar, returning the new\nmatrix.",5],[9,"add_m","","Add this matrix with another matrix, returning the new metrix.",5],[9,"sub_m","","Subtract another matrix from this matrix, returning the new matrix.",5],[9,"mul_v","","Multiplay a vector by this matrix, returning a new vector.",5],[9,"mul_m","","Multiply this matrix by another matrix, returning the new matrix.",5],[9,"neg_self","","Negate this matrix in-place (multiply by scalar -1).",5],[9,"mul_self_s","","Multiply this matrix by a scalar, in-place.",5],[9,"div_self_s","","Divide this matrix by a scalar, in-place.",5],[9,"rem_self_s","","Take the remainder of this matrix, in-place.",5],[9,"add_self_m","","Add this matrix with another matrix, in-place.",5],[9,"sub_self_m","","Subtract another matrix from this matrix, in-place.",5],[10,"mul_self_m","","Multiply this matrix by another matrix, in-place.",5],[9,"transpose","","Transpose this matrix, returning a new matrix.",5],[9,"transpose_self","","Transpose this matrix in-place.",5],[9,"determinant","","Take the determinant of this matrix.",5],[9,"diagonal","","Return a vector containing the diagonal of this matrix.",5],[10,"trace","","Return the trace of this matrix. That is, the sum of the diagonal.",5],[9,"invert","","Invert this matrix, returning a new matrix. `m.mul_m(m.invert())` is\nthe identity matrix. Returns `None` if this matrix is not invertible\n(has a determinant of zero).",5],[10,"invert_self","","Invert this matrix in-place.",5],[10,"is_invertible","","Test if this matrix is invertible.",5],[10,"is_identity","","Test if this matrix is the identity matrix. That is, it is diagonal\nand every element in the diagonal is one.",5],[9,"is_diagonal","","Test if this is a diagonal matrix. That is, every element outside of\nthe diagonal is 0.",5],[9,"is_symmetric","","Test if this matrix is symmetric. That is, it is equal to its\ntranspose.",5],[6,"ToMatrix2","","Represents types which can be converted to a Matrix2"],[9,"to_matrix2","","Convert this value to a Matrix2",6],[6,"ToMatrix3","","Represents types which can be converted to a Matrix3"],[9,"to_matrix3","","Convert this value to a Matrix3",7],[6,"ToMatrix4","","Represents types which can be converted to a Matrix4"],[9,"to_matrix4","","Convert this value to a Matrix4",8],[10,"eq","","",2],[10,"ne","","",2],[10,"clone","","",2],[10,"eq","","",3],[10,"ne","","",3],[10,"clone","","",3],[10,"eq","","",4],[10,"ne","","",4],[10,"clone","","",4],[10,"new","","Create a new matrix, providing values for each index.",2],[10,"from_cols","","Create a new matrix, providing columns.",2],[10,"from_value","","Create a new diagonal matrix, providing a single value to use for each\nnon-zero index.",2],[10,"zero","","Create a zero matrix (all zeros).",2],[10,"identity","","Create an identity matrix (diagonal matrix of ones).",2],[10,"look_at","","Create a transformation matrix that will cause a vector to point at\n`dir`, using `up` for orientation.",2],[10,"from_angle","","",2],[10,"new","","Create a new matrix, providing values for each index.",3],[10,"from_cols","","Create a new matrix, providing columns.",3],[10,"from_value","","Create a new diagonal matrix, providing a single value to use for each\nnon-zero index.",3],[10,"zero","","Create a zero matrix (all zeros).",3],[10,"identity","","Create an identity matrix (diagonal matrix of ones).",3],[10,"look_at","","Create a transformation matrix that will cause a vector to point at\n`dir`, using `up` for orientation.",3],[10,"from_angle_x","","Create a matrix from a rotation around the `x` axis (pitch).",3],[10,"from_angle_y","","Create a matrix from a rotation around the `y` axis (yaw).",3],[10,"from_angle_z","","Create a matrix from a rotation around the `z` axis (roll).",3],[10,"from_euler","","Create a matrix from a set of euler angles.",3],[10,"from_axis_angle","","Create a matrix from a rotation around an arbitrary axis",3],[10,"new","","Create a new matrix, providing values for each index.",4],[10,"from_cols","","Create a new matrix, providing columns.",4],[10,"from_value","","Create a new diagonal matrix, providing a single value to use for each\nnon-zero index.",4],[10,"zero","","Create a zero matrix (all zeros).",4],[10,"identity","","Create an identity matrix (diagonal matrix of ones).",4],[10,"from_translation","","Create a translation matrix from a Vector3",4],[10,"look_at","","Create a transformation matrix that will cause a vector to point at\n`dir`, using `up` for orientation.",4],[10,"add","","",2],[10,"add","","",3],[10,"add","","",4],[10,"sub","","",2],[10,"sub","","",3],[10,"sub","","",4],[10,"neg","","",2],[10,"neg","","",3],[10,"neg","","",4],[10,"zero","","",2],[10,"is_zero","","",2],[10,"zero","","",3],[10,"is_zero","","",3],[10,"zero","","",4],[10,"is_zero","","",4],[10,"mul","","",2],[10,"mul","","",3],[10,"mul","","",4],[10,"one","","",2],[10,"one","","",3],[10,"one","","",4],[10,"r","","",2],[10,"swap_r","","",2],[10,"map","","",2],[10,"index","","",2],[10,"index_mut","","",2],[10,"r","","",3],[10,"swap_r","","",3],[10,"map","","",3],[10,"index","","",3],[10,"index_mut","","",3],[10,"r","","",4],[10,"swap_r","","",4],[10,"map","","",4],[10,"index","","",4],[10,"index_mut","","",4],[10,"mul_s","","",2],[10,"div_s","","",2],[10,"rem_s","","",2],[10,"add_m","","",2],[10,"sub_m","","",2],[10,"mul_v","","",2],[10,"mul_m","","",2],[10,"neg_self","","",2],[10,"mul_self_s","","",2],[10,"div_self_s","","",2],[10,"rem_self_s","","",2],[10,"add_self_m","","",2],[10,"sub_self_m","","",2],[10,"transpose","","",2],[10,"transpose_self","","",2],[10,"determinant","","",2],[10,"diagonal","","",2],[10,"invert","","",2],[10,"is_diagonal","","",2],[10,"is_symmetric","","",2],[10,"mul_s","","",3],[10,"div_s","","",3],[10,"rem_s","","",3],[10,"add_m","","",3],[10,"sub_m","","",3],[10,"mul_v","","",3],[10,"mul_m","","",3],[10,"neg_self","","",3],[10,"mul_self_s","","",3],[10,"div_self_s","","",3],[10,"rem_self_s","","",3],[10,"add_self_m","","",3],[10,"sub_self_m","","",3],[10,"transpose","","",3],[10,"transpose_self","","",3],[10,"determinant","","",3],[10,"diagonal","","",3],[10,"invert","","",3],[10,"is_diagonal","","",3],[10,"is_symmetric","","",3],[10,"mul_s","","",4],[10,"div_s","","",4],[10,"rem_s","","",4],[10,"add_m","","",4],[10,"sub_m","","",4],[10,"mul_v","","",4],[10,"mul_m","","",4],[10,"neg_self","","",4],[10,"mul_self_s","","",4],[10,"div_self_s","","",4],[10,"rem_self_s","","",4],[10,"add_self_m","","",4],[10,"sub_self_m","","",4],[10,"transpose","","",4],[10,"transpose_self","","",4],[10,"determinant","","",4],[10,"diagonal","","",4],[10,"invert","","",4],[10,"is_diagonal","","",4],[10,"is_symmetric","","",4],[10,"approx_eq_eps","","",2],[10,"approx_eq_eps","","",3],[10,"approx_eq_eps","","",4],[10,"to_matrix3","","Clone the elements of a 2-dimensional matrix into the top-left corner\nof a 3-dimensional identity matrix.",2],[10,"to_matrix4","","Clone the elements of a 2-dimensional matrix into the top-left corner\nof a 4-dimensional identity matrix.",2],[10,"to_matrix4","","Clone the elements of a 3-dimensional matrix into the top-left corner\nof a 4-dimensional identity matrix.",3],[10,"to_quaternion","","Convert the matrix to a quaternion",3],[10,"fmt","","",2],[10,"fmt","","",3],[10,"fmt","","",4],[0,"quaternion","cgmath",""],[1,"Quaternion","cgmath::quaternion","A [quaternion](https://en.wikipedia.org/wiki/Quaternion) in scalar/vector\nform."],[11,"s","","",9],[11,"v","","",9],[6,"ToQuaternion","","Represents types which can be expressed as a quaternion."],[9,"to_quaternion","","Convert this value to a quaternion.",10],[10,"eq","","",9],[10,"ne","","",9],[10,"clone","","",9],[10,"map","","",9],[10,"index","","",9],[10,"index_mut","","",9],[10,"new","","Construct a new quaternion from one scalar component and three\nimaginary components",9],[10,"from_sv","","Construct a new quaternion from a scalar and a vector",9],[10,"zero","","The additive identity, ie: `q = 0 + 0i + 0j + 0i`",9],[10,"identity","","The multiplicative identity, ie: `q = 1 + 0i + 0j + 0i`",9],[10,"mul_s","","The result of multiplying the quaternion a scalar",9],[10,"div_s","","The result of dividing the quaternion a scalar",9],[10,"mul_v","","The result of multiplying the quaternion by a vector",9],[10,"add_q","","The sum of this quaternion and `other`",9],[10,"sub_q","","The difference between this quaternion and `other`",9],[10,"mul_q","","The result of multipliplying the quaternion by `other`",9],[10,"mul_self_s","","Multiply this quaternion by a scalar, in-place.",9],[10,"div_self_s","","Divide this quaternion by a scalar, in-place.",9],[10,"add_self_q","","Add this quaternion by another, in-place.",9],[10,"sub_self_q","","Subtract another quaternion from this one, in-place.",9],[10,"mul_self_q","","Multiply this quaternion by another, in-place.",9],[10,"dot","","The dot product of the quaternion and `q`.",9],[10,"conjugate","","The conjugate of the quaternion.",9],[10,"magnitude2","","The squared magnitude of the quaternion. This is useful for\nmagnitude comparisons where the exact magnitude does not need to be\ncalculated.",9],[10,"magnitude","","The magnitude of the quaternion",9],[10,"normalize","","Normalize this quaternion, returning the new quaternion.",9],[10,"nlerp","","Do a normalized linear interpolation with `other`, by `amount`.",9],[10,"approx_eq_eps","","",9],[10,"slerp","","Spherical Linear Intoperlation",9],[10,"to_matrix3","","Convert the quaternion to a 3 x 3 rotation matrix",9],[10,"to_matrix4","","Convert the quaternion to a 4 x 4 rotation matrix",9],[10,"neg","","",9],[10,"fmt","","",9],[10,"to_rot3","","",9],[10,"to_quaternion","","",9],[10,"identity","","",9],[10,"look_at","","",9],[10,"between_vectors","","",9],[10,"rotate_vector","","",9],[10,"concat","","",9],[10,"concat_self","","",9],[10,"invert","","",9],[10,"invert_self","","",9],[10,"from_axis_angle","","",9],[10,"from_euler","","",9],[0,"vector","cgmath","Types and traits for two, three, and four-dimensional vectors."],[1,"Vector2","cgmath::vector",""],[11,"x","","",11],[11,"y","","",11],[1,"Vector3","",""],[11,"x","","",12],[11,"y","","",12],[11,"z","","",12],[1,"Vector4","",""],[11,"x","","",13],[11,"y","","",13],[11,"z","","",13],[11,"w","","",13],[3,"dot","","Dot product of two vectors."],[6,"Vector","","A trait that specifies a range of numeric operations for vectors. Not all\nof these make sense from a linear algebra point of view, but are included\nfor pragmatic reasons."],[9,"add_s","","Add a scalar to this vector, returning a new vector.",14],[9,"sub_s","","Subtract a scalar from this vector, returning a new vector.",14],[9,"mul_s","","Multiply this vector by a scalar, returning a new vector.",14],[9,"div_s","","Divide this vector by a scalar, returning a new vector.",14],[9,"rem_s","","Take the remainder of this vector by a scalar, returning a new vector.",14],[9,"add_v","","Add this vector to another, returning a new vector.",14],[9,"sub_v","","Subtract another vector from this one, returning a new vector.",14],[9,"mul_v","","Multiply this vector by another, returning a new vector.",14],[9,"div_v","","Divide this vector by another, returning a new vector.",14],[9,"rem_v","","Take the remainder of this vector by another, returning a new scalar.",14],[9,"neg_self","","Negate this vector in-place.",14],[9,"add_self_s","","Add a scalar to this vector in-place.",14],[9,"sub_self_s","","Subtract a scalar from this vector, in-place.",14],[9,"mul_self_s","","Multiply this vector by a scalar, in-place.",14],[9,"div_self_s","","Divide this vector by a scalar, in-place.",14],[9,"rem_self_s","","Take the remainder of this vector by a scalar, in-place.",14],[9,"add_self_v","","Add another vector to this one, in-place.",14],[9,"sub_self_v","","Subtract another vector from this one, in-place.",14],[9,"mul_self_v","","Multiply this matrix by another, in-place.",14],[9,"div_self_v","","Divide this matrix by anothor, in-place.",14],[9,"rem_self_v","","Take the remainder of this vector by another, in-place.",14],[9,"comp_add","","The sum of each component of the vector.",14],[9,"comp_mul","","The product of each component of the vector.",14],[10,"dot","","Vector dot product.",14],[9,"comp_min","","The minimum component of the vector.",14],[9,"comp_max","","The maximum component of the vector.",14],[6,"EuclideanVector","","Specifies geometric operations for vectors. This is only implemented for\n2-dimensional and 3-dimensional vectors."],[10,"is_perpendicular","","Returns `true` if the vector is perpendicular (at right angles) to the\nother vector.",15],[10,"length2","","Returns the squared length of the vector. This does not perform an\nexpensive square root operation like in the `length` method and can\ntherefore be more efficient for comparing the lengths of two vectors.",15],[10,"length","","The norm of the vector.",15],[9,"angle","","The angle between the vector and `other`, in radians.",15],[10,"normalize","","Returns a vector with the same direction, but with a `length` (or\n`norm`) of `1`.",15],[10,"normalize_to","","Returns a vector with the same direction and a given `length`.",15],[10,"lerp","","Returns the result of linarly interpolating the length of the vector\ntowards the length of `other` by the specified amount.",15],[10,"normalize_self","","Normalises the vector to a length of `1`.",15],[10,"normalize_self_to","","Normalizes the vector to `length`.",15],[10,"lerp_self","","Linearly interpolates the length of the vector towards the length of\n`other` by the specified amount.",15],[10,"hash","","",11],[10,"clone","","",11],[10,"eq","","",11],[10,"ne","","",11],[10,"new","","Construct a new vector, using the provided values.",11],[10,"from_value","","Construct a vector from a single value, replicating it.",11],[10,"zero","","The additive identity of the vector.",11],[10,"ident","","The multiplicative identity of the vector.",11],[10,"map","","",11],[10,"add_s","","",11],[10,"sub_s","","",11],[10,"mul_s","","",11],[10,"div_s","","",11],[10,"rem_s","","",11],[10,"add_v","","",11],[10,"sub_v","","",11],[10,"mul_v","","",11],[10,"div_v","","",11],[10,"rem_v","","",11],[10,"neg_self","","",11],[10,"add_self_s","","",11],[10,"sub_self_s","","",11],[10,"mul_self_s","","",11],[10,"div_self_s","","",11],[10,"rem_self_s","","",11],[10,"add_self_v","","",11],[10,"sub_self_v","","",11],[10,"mul_self_v","","",11],[10,"div_self_v","","",11],[10,"rem_self_v","","",11],[10,"comp_add","","",11],[10,"comp_mul","","",11],[10,"comp_min","","",11],[10,"comp_max","","",11],[10,"add","","",11],[10,"sub","","",11],[10,"zero","","",11],[10,"is_zero","","",11],[10,"neg","","",11],[10,"mul","","",11],[10,"div","","",11],[10,"rem","","",11],[10,"one","","",11],[10,"index","","",11],[10,"index_mut","","",11],[10,"approx_eq_eps","","",11],[10,"hash","","",12],[10,"clone","","",12],[10,"eq","","",12],[10,"ne","","",12],[10,"new","","Construct a new vector, using the provided values.",12],[10,"from_value","","Construct a vector from a single value, replicating it.",12],[10,"zero","","The additive identity of the vector.",12],[10,"ident","","The multiplicative identity of the vector.",12],[10,"map","","",12],[10,"add_s","","",12],[10,"sub_s","","",12],[10,"mul_s","","",12],[10,"div_s","","",12],[10,"rem_s","","",12],[10,"add_v","","",12],[10,"sub_v","","",12],[10,"mul_v","","",12],[10,"div_v","","",12],[10,"rem_v","","",12],[10,"neg_self","","",12],[10,"add_self_s","","",12],[10,"sub_self_s","","",12],[10,"mul_self_s","","",12],[10,"div_self_s","","",12],[10,"rem_self_s","","",12],[10,"add_self_v","","",12],[10,"sub_self_v","","",12],[10,"mul_self_v","","",12],[10,"div_self_v","","",12],[10,"rem_self_v","","",12],[10,"comp_add","","",12],[10,"comp_mul","","",12],[10,"comp_min","","",12],[10,"comp_max","","",12],[10,"add","","",12],[10,"sub","","",12],[10,"zero","","",12],[10,"is_zero","","",12],[10,"neg","","",12],[10,"mul","","",12],[10,"div","","",12],[10,"rem","","",12],[10,"one","","",12],[10,"index","","",12],[10,"index_mut","","",12],[10,"approx_eq_eps","","",12],[10,"hash","","",13],[10,"clone","","",13],[10,"eq","","",13],[10,"ne","","",13],[10,"new","","Construct a new vector, using the provided values.",13],[10,"from_value","","Construct a vector from a single value, replicating it.",13],[10,"zero","","The additive identity of the vector.",13],[10,"ident","","The multiplicative identity of the vector.",13],[10,"map","","",13],[10,"add_s","","",13],[10,"sub_s","","",13],[10,"mul_s","","",13],[10,"div_s","","",13],[10,"rem_s","","",13],[10,"add_v","","",13],[10,"sub_v","","",13],[10,"mul_v","","",13],[10,"div_v","","",13],[10,"rem_v","","",13],[10,"neg_self","","",13],[10,"add_self_s","","",13],[10,"sub_self_s","","",13],[10,"mul_self_s","","",13],[10,"div_self_s","","",13],[10,"rem_self_s","","",13],[10,"add_self_v","","",13],[10,"sub_self_v","","",13],[10,"mul_self_v","","",13],[10,"div_self_v","","",13],[10,"rem_self_v","","",13],[10,"comp_add","","",13],[10,"comp_mul","","",13],[10,"comp_min","","",13],[10,"comp_max","","",13],[10,"add","","",13],[10,"sub","","",13],[10,"zero","","",13],[10,"is_zero","","",13],[10,"neg","","",13],[10,"mul","","",13],[10,"div","","",13],[10,"rem","","",13],[10,"one","","",13],[10,"index","","",13],[10,"index_mut","","",13],[10,"approx_eq_eps","","",13],[10,"unit_x","","A unit vector in the `x` direction.",11],[10,"unit_y","","A unit vector in the `y` direction.",11],[10,"perp_dot","","The perpendicular dot product of the vector and `other`.",11],[10,"extend","","Create a `Vector3`, using the `x` and `y` values from this vector, and the\nprovided `z`.",11],[10,"unit_x","","A unit vector in the `x` direction.",12],[10,"unit_y","","A unit vector in the `y` direction.",12],[10,"unit_z","","A unit vector in the `w` direction.",12],[10,"cross","","Returns the cross product of the vector and `other`.",12],[10,"cross_self","","Calculates the cross product of the vector and `other`, then stores the\nresult in `self`.",12],[10,"extend","","Create a `Vector4`, using the `x`, `y` and `z` values from this vector, and the\nprovided `w`.",12],[10,"truncate","","Create a `Vector2`, dropping the `z` value.",12],[10,"unit_x","","A unit vector in the `x` direction.",13],[10,"unit_y","","A unit vector in the `y` direction.",13],[10,"unit_z","","A unit vector in the `z` direction.",13],[10,"unit_w","","A unit vector in the `w` direction.",13],[10,"truncate","","Create a `Vector3`, dropping the `w` value.",13],[10,"truncate_n","","Create a `Vector3`, dropping the nth element",13],[10,"angle","","",11],[10,"angle","","",12],[10,"angle","","",13],[10,"fmt","","",11],[10,"fmt","","",12],[10,"fmt","","",13],[0,"angle","cgmath","Angle units for type-safe, self-documenting code."],[1,"Rad","cgmath::angle","An angle, in radians"],[11,"s","","",16],[1,"Deg","","An angle, in degrees"],[11,"s","","",17],[3,"rad","","Create a new angle, in radians"],[3,"deg","","Create a new angle, in degrees"],[3,"bisect","",""],[3,"sin","",""],[3,"cos","",""],[3,"tan","",""],[3,"sin_cos","",""],[3,"cot","",""],[3,"sec","",""],[3,"csc","",""],[3,"asin","",""],[3,"acos","",""],[3,"atan","",""],[3,"atan2","",""],[6,"ToRad","","Represents types that can be converted to radians."],[9,"to_rad","","Convert this value to radians.",18],[6,"ToDeg","","Represents types that can be converted to degrees."],[9,"to_deg","","Convert this value to degrees.",19],[6,"ScalarConv","","Private utility functions for converting to/from scalars"],[9,"from","","",20],[9,"s","","",20],[9,"mut_s","","",20],[6,"Angle","","Operations on angles."],[9,"from","","Create a new angle from any other valid angle.",21],[10,"neg_self","","Negate this angle, in-place.",21],[10,"add_a","","Add this angle with another, returning the new angle.",21],[10,"sub_a","","Subtract another angle from this one, returning the new angle.",21],[10,"div_a","","Divide this angle by another, returning the ratio.",21],[10,"rem_a","","Take the remainder of this angle with another.",21],[10,"mul_s","","Multiply this angle by a scalar, returning the new angle.",21],[10,"div_s","","Divide this angle by a scalar, returing the new angle.",21],[10,"rem_s","","Take the remainder of this angle by a scalar, returning the new angle.",21],[10,"add_self_a","","Add this angle with another, in-place.",21],[10,"sub_self_a","","Subtract another angle from this one, in-place.",21],[10,"mul_self_s","","Multiply this angle by a scalar, in-place.",21],[10,"div_self_s","","Divide this angle by a scalar, in-place.",21],[10,"rem_self_s","","Take the remainder of this angle by a scalar, in-place.",21],[10,"normalize","","Return the angle, normalized to the range `[0, full_turn)`.",21],[10,"normalize_self","","Normalize the angle to the range `[0, full_turn)`.",21],[10,"opposite","","Return the angle rotated by half a turn",21],[10,"bisect","","Returns the interior bisector of the two angles",21],[9,"full_turn","","",21],[10,"turn_div_2","","",21],[10,"turn_div_3","","",21],[10,"turn_div_4","","",21],[10,"turn_div_6","","",21],[10,"hash","","",16],[10,"partial_cmp","","",16],[10,"lt","","",16],[10,"le","","",16],[10,"gt","","",16],[10,"ge","","",16],[10,"eq","","",16],[10,"ne","","",16],[10,"clone","","",16],[10,"hash","","",17],[10,"partial_cmp","","",17],[10,"lt","","",17],[10,"le","","",17],[10,"gt","","",17],[10,"ge","","",17],[10,"eq","","",17],[10,"ne","","",17],[10,"clone","","",17],[10,"to_rad","","",16],[10,"to_rad","","",17],[10,"to_deg","","",16],[10,"to_deg","","",17],[10,"from","","",16],[10,"s","","",16],[10,"mut_s","","",16],[10,"from","","",17],[10,"s","","",17],[10,"mut_s","","",17],[10,"zero","","",16],[10,"full_turn","","",16],[10,"turn_div_2","","",16],[10,"turn_div_3","","",16],[10,"turn_div_4","","",16],[10,"turn_div_6","","",16],[10,"zero","","",17],[10,"full_turn","","",17],[10,"turn_div_2","","",17],[10,"turn_div_3","","",17],[10,"turn_div_4","","",17],[10,"turn_div_6","","",17],[10,"add","","",16],[10,"add","","",17],[10,"sub","","",16],[10,"sub","","",17],[10,"neg","","",16],[10,"neg","","",17],[10,"zero","","",16],[10,"is_zero","","",16],[10,"zero","","",17],[10,"is_zero","","",17],[10,"mul","","",16],[10,"mul","","",17],[10,"one","","",16],[10,"one","","",17],[10,"equiv","","",16],[10,"equiv","","",17],[10,"from","","",16],[10,"full_turn","","",16],[10,"from","","",17],[10,"full_turn","","",17],[10,"fmt","","",16],[10,"fmt","","",17],[10,"approx_eq_eps","","",16],[10,"approx_eq_eps","","",17],[0,"plane","cgmath",""],[1,"Plane","cgmath::plane","A 3-dimensional plane formed from the equation: `A*x + B*y + C*z - D = 0`."],[11,"n","","",22],[11,"d","","",22],[10,"eq","","",22],[10,"ne","","",22],[10,"clone","","",22],[10,"new","","Construct a plane from a normal vector and a scalar distance. The\nplane will be perpendicular to `n`, and `d` units offset from the\norigin.",22],[10,"from_abcd","","# Arguments",22],[10,"from_vector4","","Construct a plane from the components of a four-dimensional vector",22],[10,"from_points","","Constructs a plane that passes through the the three points `a`, `b` and `c`",22],[10,"approx_eq_eps","","",22],[10,"fmt","","",22],[0,"point","cgmath","Points are fixed positions in affine space with no length or direction. This\ndisinguishes them from vectors, which have a length and direction, but do\nnot have a fixed position."],[1,"Point2","cgmath::point","A point in 2-dimensional space."],[11,"x","","",23],[11,"y","","",23],[1,"Point3","","A point in 3-dimensional space."],[11,"x","","",24],[11,"y","","",24],[11,"z","","",24],[6,"Point","","Specifies the numeric operations for point types."],[9,"origin","","Create a point at the origin.",25],[9,"from_vec","","Create a point from a vector.",25],[9,"to_vec","","Convert a point to a vector.",25],[9,"mul_s","","Multiply each component by a scalar, returning the new point.",25],[9,"div_s","","Divide each component by a scalar, returning the new point.",25],[9,"rem_s","","Subtract a scalar from each component, returning the new point.",25],[9,"add_v","","Add a vector to this point, returning the new point.",25],[9,"sub_p","","Subtract another point from this one, returning a new vector.",25],[9,"mul_self_s","","Multiply each component by a scalar, in-place.",25],[9,"div_self_s","","Divide each component by a scalar, in-place.",25],[9,"rem_self_s","","Take the remainder of each component by a scalar, in-place.",25],[9,"add_self_v","","Add a vector to this point, in-place.",25],[9,"dot","","This is a weird one, but its useful for plane calculations.",25],[9,"min","","",25],[9,"max","","",25],[10,"hash","","",23],[10,"clone","","",23],[10,"eq","","",23],[10,"ne","","",23],[10,"hash","","",24],[10,"clone","","",24],[10,"eq","","",24],[10,"ne","","",24],[10,"new","","",23],[10,"new","","",24],[10,"from_homogeneous","","",24],[10,"to_homogeneous","","",24],[10,"map","","",23],[10,"index","","",23],[10,"index_mut","","",23],[10,"origin","","",23],[10,"from_vec","","",23],[10,"to_vec","","",23],[10,"mul_s","","",23],[10,"div_s","","",23],[10,"rem_s","","",23],[10,"add_v","","",23],[10,"sub_p","","",23],[10,"mul_self_s","","",23],[10,"div_self_s","","",23],[10,"rem_self_s","","",23],[10,"add_self_v","","",23],[10,"dot","","",23],[10,"min","","",23],[10,"max","","",23],[10,"approx_eq_eps","","",23],[10,"map","","",24],[10,"index","","",24],[10,"index_mut","","",24],[10,"origin","","",24],[10,"from_vec","","",24],[10,"to_vec","","",24],[10,"mul_s","","",24],[10,"div_s","","",24],[10,"rem_s","","",24],[10,"add_v","","",24],[10,"sub_p","","",24],[10,"mul_self_s","","",24],[10,"div_self_s","","",24],[10,"rem_self_s","","",24],[10,"add_self_v","","",24],[10,"dot","","",24],[10,"min","","",24],[10,"max","","",24],[10,"approx_eq_eps","","",24],[10,"fmt","","",23],[10,"fmt","","",24],[0,"line","cgmath","Line segments"],[1,"Line","cgmath::line","A generic directed line segment from `origin` to `dest`."],[11,"origin","","",26],[11,"dest","","",26],[4,"Line2","",""],[4,"Line3","",""],[10,"eq","","",26],[10,"ne","","",26],[10,"clone","","",26],[10,"new","","",26],[0,"ray","cgmath",""],[1,"Ray","cgmath::ray","A generic ray starting at `origin` and extending infinitely in\n`direction`."],[11,"origin","","",27],[11,"direction","","",27],[4,"Ray2","",""],[4,"Ray3","",""],[10,"eq","","",27],[10,"ne","","",27],[10,"clone","","",27],[10,"new","","",27],[0,"rotation","cgmath",""],[1,"Basis2","cgmath::rotation","A two-dimensional rotation matrix."],[1,"Basis3","","A three-dimensional rotation matrix."],[6,"Rotation","","A trait for a generic rotation. A rotation is a transformation that\ncreates a circular motion, and preserves at least one point in the space."],[9,"identity","","Create the identity transform (causes no transformation).",28],[9,"look_at","","Create a rotation to a given direction with an 'up' vector",28],[9,"between_vectors","","Create a shortest rotation to transform vector 'a' into 'b'.\nBoth given vectors are assumed to have unit length.",28],[9,"rotate_vector","","Rotate a vector using this rotation.",28],[10,"rotate_point","","Rotate a point using this rotation, by converting it to its\nrepresentation as a vector.",28],[10,"rotate_ray","","Rotate a ray using this rotation.",28],[9,"concat","","Create a new rotation which combines both this rotation, and another.",28],[9,"invert","","Create a new rotation which \"un-does\" this rotation. That is,\n`r.concat(r.invert())` is the identity.",28],[10,"concat_self","","Modify this rotation in-place by combining it with another.",28],[10,"invert_self","","Invert this rotation in-place.",28],[6,"Rotation2","","A two-dimensional rotation."],[9,"from_angle","","Create a rotation by a given angle. Thus is a redundant case of both\nfrom_axis_angle() and from_euler() for 2D space.",29],[6,"Rotation3","","A three-dimensional rotation."],[9,"from_axis_angle","","Create a rotation using an angle around a given axis.",30],[9,"from_euler","","Create a rotation from a set of euler angles.",30],[10,"from_angle_x","","Create a rotation from an angle around the `x` axis (pitch).",30],[10,"from_angle_y","","Create a rotation from an angle around the `y` axis (yaw).",30],[10,"from_angle_z","","Create a rotation from an angle around the `z` axis (roll).",30],[6,"ToBasis2","","Represents types which can be converted to a rotation matrix."],[9,"to_rot2","","Convert this type to a rotation matrix.",31],[6,"ToBasis3","","Represents types which can be converted to a rotation matrix."],[9,"to_rot3","","Convert this type to a rotation matrix.",32],[10,"clone","","",33],[10,"eq","","",33],[10,"ne","","",33],[10,"as_matrix2","","Coerce to a `Matrix2`",33],[10,"to_rot2","","",33],[10,"to_matrix2","","",33],[10,"identity","","",33],[10,"look_at","","",33],[10,"between_vectors","","",33],[10,"rotate_vector","","",33],[10,"concat","","",33],[10,"concat_self","","",33],[10,"invert","","",33],[10,"invert_self","","",33],[10,"approx_eq_eps","","",33],[10,"from_angle","","",33],[10,"clone","","",34],[10,"eq","","",34],[10,"ne","","",34],[10,"from_quaternion","","Create a new rotation matrix from a quaternion.",34],[10,"as_matrix3","","Coerce to a `Matrix3`",34],[10,"to_rot3","","",34],[10,"to_matrix3","","",34],[10,"to_quaternion","","",34],[10,"identity","","",34],[10,"look_at","","",34],[10,"between_vectors","","",34],[10,"rotate_vector","","",34],[10,"concat","","",34],[10,"concat_self","","",34],[10,"invert","","",34],[10,"invert_self","","",34],[10,"approx_eq_eps","","",34],[10,"from_axis_angle","","",34],[10,"from_euler","","",34],[10,"from_angle_x","","",34],[10,"from_angle_y","","",34],[10,"from_angle_z","","",34],[0,"transform","cgmath",""],[1,"Decomposed","cgmath::transform","A generic transformation consisting of a rotation,\ndisplacement vector and scale amount."],[11,"scale","","",35],[11,"rot","","",35],[11,"disp","","",35],[1,"AffineMatrix3","","A homogeneous transformation matrix."],[11,"mat","","",36],[6,"Transform","","A trait representing an [affine\ntransformation](https://en.wikipedia.org/wiki/Affine_transformation) that\ncan be applied to points or vectors. An affine transformation is one which"],[9,"identity","","Create an identity transformation. That is, a transformation which\ndoes nothing.",37],[9,"look_at","","Create a transformation that rotates a vector to look at `center` from\n`eye`, using `up` for orientation.",37],[9,"transform_vector","","Transform a vector using this transform.",37],[9,"transform_point","","Transform a point using this transform.",37],[10,"transform_ray","","Transform a ray using this transform.",37],[10,"transform_as_point","","Transform a vector as a point using this transform.",37],[9,"concat","","Combine this transform with another, yielding a new transformation\nwhich has the effects of both.",37],[9,"invert","","Create a transform that \"un-does\" this one.",37],[10,"concat_self","","Combine this transform with another, in-place.",37],[10,"invert_self","","Invert this transform in-place, failing if the transformation is not\ninvertible.",37],[6,"Transform3","",""],[10,"identity","","",35],[10,"look_at","","",35],[10,"transform_vector","","",35],[10,"transform_point","","",35],[10,"concat","","",35],[10,"invert","","",35],[10,"to_matrix4","","",35],[10,"fmt","","",35],[10,"identity","","",36],[10,"look_at","","",36],[10,"transform_vector","","",36],[10,"transform_point","","",36],[10,"concat","","",36],[10,"invert","","",36],[10,"to_matrix4","","",36],[0,"projection","cgmath",""],[1,"PerspectiveFov","cgmath::projection","A perspective projection based on a vertical field-of-view angle."],[11,"fovy","","",38],[11,"aspect","","",38],[11,"near","","",38],[11,"far","","",38],[1,"Perspective","","A perspective projection with arbitrary left/right/bottom/top distances"],[11,"left","","",39],[11,"bottom","","",39],[11,"near","","",39],[1,"Ortho","","An orthographic projection with arbitrary left/right/bottom/top distances"],[11,"left","","",40],[11,"bottom","","",40],[11,"near","","",40],[3,"perspective","","Create a perspective projection matrix."],[3,"frustum","","Create a perspective matrix from a view frustrum."],[3,"ortho","","Create an orthographic projection matrix."],[6,"Projection","",""],[9,"to_frustum","","",41],[10,"eq","","",38],[10,"ne","","",38],[10,"clone","","",38],[10,"to_perspective","","",38],[10,"to_frustum","","",38],[10,"to_matrix4","","",38],[10,"eq","","",39],[10,"ne","","",39],[10,"clone","","",39],[10,"to_frustum","","",39],[10,"to_matrix4","","",39],[10,"eq","","",40],[10,"ne","","",40],[10,"clone","","",40],[10,"to_frustum","","",40],[10,"to_matrix4","","",40],[0,"aabb","cgmath","Axis-aligned bounding boxes"],[1,"Aabb2","cgmath::aabb","A two-dimensional AABB, aka a rectangle."],[11,"min","","",42],[11,"max","","",42],[1,"Aabb3","","A three-dimensional AABB, aka a rectangular prism."],[11,"min","","",43],[11,"max","","",43],[6,"Aabb","",""],[9,"new","","Create a new AABB using two points as opposing corners.",44],[9,"min","","Return a shared reference to the point nearest to (-inf, -inf).",44],[9,"max","","Return a shared reference to the point nearest to (inf, inf).",44],[10,"dim","","Return the dimensions of this AABB.",44],[10,"volume","","Return the volume this AABB encloses.",44],[10,"center","","Return the center point of this AABB.",44],[9,"contains","","Tests whether a point is cointained in the box, inclusive for min corner\nand exclusive for the max corner.",44],[10,"grow","","Returns a new AABB that is grown to include the given point.",44],[10,"add_v","","Add a vector to every point in the AABB, returning a new AABB.",44],[10,"mul_s","","Multiply every point in the AABB by a scalar, returning a new AABB.",44],[10,"mul_v","","Multiply every point in the AABB by a vector, returning a new AABB.",44],[10,"eq","","",42],[10,"ne","","",42],[10,"clone","","",42],[10,"new","","Construct a new axis-aligned bounding box from two points.",42],[10,"new","","",42],[10,"min","","",42],[10,"max","","",42],[10,"contains","","",42],[10,"fmt","","",42],[10,"eq","","",43],[10,"ne","","",43],[10,"clone","","",43],[10,"new","","Construct a new axis-aligned bounding box from two points.",43],[10,"new","","",43],[10,"min","","",43],[10,"max","","",43],[10,"contains","","",43],[10,"fmt","","",43],[0,"cylinder","cgmath","Oriented bounding cylinder"],[1,"Cylinder","cgmath::cylinder",""],[11,"center","","",45],[11,"axis","","",45],[11,"radius","","",45],[10,"eq","","",45],[10,"ne","","",45],[10,"clone","","",45],[0,"frustum","cgmath","View frustum for visibility determination"],[1,"Frustum","cgmath::frustum",""],[11,"left","","",46],[11,"right","","",46],[11,"bottom","","",46],[11,"top","","",46],[11,"near","","",46],[11,"far","","",46],[1,"FrustumPoints","",""],[11,"near_top_left","","",47],[11,"near_top_right","","",47],[11,"near_bottom_left","","",47],[11,"near_bottom_right","","",47],[11,"far_top_left","","",47],[11,"far_top_right","","",47],[11,"far_bottom_left","","",47],[11,"far_bottom_right","","",47],[10,"eq","","",46],[10,"ne","","",46],[10,"clone","","",46],[10,"new","","Constructs a frustum",46],[10,"from_matrix4","","Extracts frustum planes from a projection matrix",46],[10,"eq","","",47],[10,"ne","","",47],[10,"clone","","",47],[0,"intersect","cgmath",""],[6,"Intersect","cgmath::intersect",""],[9,"intersection","","",48],[0,"obb","cgmath","Oriented bounding boxes"],[1,"Obb2","cgmath::obb",""],[11,"center","","",49],[11,"axis","","",49],[11,"extents","","",49],[1,"Obb3","",""],[11,"center","","",50],[11,"axis","","",50],[11,"extents","","",50],[10,"eq","","",49],[10,"ne","","",49],[10,"clone","","",49],[10,"eq","","",50],[10,"ne","","",50],[10,"clone","","",50],[0,"sphere","cgmath","Bounding sphere"],[1,"Sphere","cgmath::sphere",""],[11,"center","","",51],[11,"radius","","",51],[10,"eq","","",51],[10,"ne","","",51],[10,"clone","","",51],[0,"approx","cgmath",""],[6,"ApproxEq","cgmath::approx",""],[10,"approx_epsilon","","",52],[10,"approx_eq","","",52],[9,"approx_eq_eps","","",52],[0,"num","cgmath",""],[6,"PartialOrd","cgmath::num","A trait providing a [partial ordering][po]"],[9,"partial_min","","",53],[9,"partial_max","","",53],[6,"BaseNum","","Base numeric types with partial ordering"],[6,"BaseInt","","Base integer types"],[6,"BaseFloat","","Base floating point types"]],"paths":[[6,"Array1"],[6,"Array2"],[1,"Matrix2"],[1,"Matrix3"],[1,"Matrix4"],[6,"Matrix"],[6,"ToMatrix2"],[6,"ToMatrix3"],[6,"ToMatrix4"],[1,"Quaternion"],[6,"ToQuaternion"],[1,"Vector2"],[1,"Vector3"],[1,"Vector4"],[6,"Vector"],[6,"EuclideanVector"],[1,"Rad"],[1,"Deg"],[6,"ToRad"],[6,"ToDeg"],[6,"ScalarConv"],[6,"Angle"],[1,"Plane"],[1,"Point2"],[1,"Point3"],[6,"Point"],[1,"Line"],[1,"Ray"],[6,"Rotation"],[6,"Rotation2"],[6,"Rotation3"],[6,"ToBasis2"],[6,"ToBasis3"],[1,"Basis2"],[1,"Basis3"],[1,"Decomposed"],[1,"AffineMatrix3"],[6,"Transform"],[1,"PerspectiveFov"],[1,"Perspective"],[1,"Ortho"],[6,"Projection"],[1,"Aabb2"],[1,"Aabb3"],[6,"Aabb"],[1,"Cylinder"],[1,"Frustum"],[1,"FrustumPoints"],[6,"Intersect"],[1,"Obb2"],[1,"Obb3"],[1,"Sphere"],[6,"ApproxEq"],[6,"PartialOrd"]]};
initSearch(searchIndex);
