var searchIndex = {};
searchIndex['piston'] = {"items":[[0,"","piston","A user friendly graphics engine."],[1,"AssetStore","","A place to store sounds, textures, animations etc."],[1,"GameIterator","","A game loop iterator."],[11,"game_window","","The game window used by iterator.",0],[1,"GameIteratorSettings","","Settings for the game loop behavior."],[11,"updates_per_second","","The number of updates per second (UPS).",1],[11,"max_frames_per_second","","The maximum number of frames per second (FPS target).",1],[1,"RenderArgs","","Render argument."],[11,"ext_dt","","Extrapolated time in seconds, used to do smooth animation.",2],[11,"width","","The width of rendered area.",2],[11,"height","","The height of rendered area.",2],[1,"UpdateArgs","","Update argument."],[11,"dt","","Delta time in seconds.",3],[2,"GameEvent","","Contains the different game events."],[12,"Render","","Render graphics.",4],[12,"Update","","Update physical state of the game.",4],[12,"Input","","Input event.",4],[0,"game_window","","Game window operations."],[1,"GameWindowSettings","piston::game_window","Settings for window behavior."],[11,"title","","Title of the window.",5],[11,"size","","The size of the window",5],[11,"fullscreen","","If true, the window is fullscreen.",5],[11,"exit_on_esc","","If true, exit when pressing Esc.",5],[2,"Event","","Used by window back-end to model window events."],[12,"NoEvent","","No event occured.",6],[12,"KeyReleased","","A key was released.",6],[12,"KeyPressed","","A key was pressed.",6],[12,"MouseButtonPressed","","A mouse button was pressed.",6],[12,"MouseButtonReleased","","A mouse button was released.",6],[12,"MouseMoved","","The mouse moved.",6],[12,"MouseScrolled","","The mouse wheel.",6],[6,"GameWindow","","Implemented by window back-end."],[9,"get_settings","","Get the window's settings.",7],[9,"should_close","","Returns ture if the window should close.",7],[9,"close","","Inform the window that it should close.",7],[10,"get_size","","Get the window's size",7],[10,"get_draw_size","","Get the size in drawing coordinates.",7],[10,"swap_buffers","","Swap buffers.",7],[10,"capture_cursor","","When the cursor is captured,\nit is hidden and the cursor position does not change.\nOnly relative mouse motion is registered.",7],[10,"poll_event","","Poll a event from window's event queue.",7],[10,"fmt","","",6],[10,"partial_cmp","","",6],[10,"lt","","",6],[10,"le","","",6],[10,"gt","","",6],[10,"ge","","",6],[10,"eq","","",6],[10,"ne","","",6],[10,"clone","","",6],[10,"default","","Gets default settings.",5],[0,"shader_version","piston",""],[0,"opengl","piston::shader_version","Models versions of OpenGL"],[10,"get_major_minor","shader_version::opengl","Gets the minor version of OpenGL.",8],[10,"to_GLSL","","Gets GLSL version associated with OpenGL.",8],[10,"to_OpenGL","shader_version::glsl","Gets OpenGL version associated with GLSL.",9],[2,"OpenGL","piston::shader_version::opengl",""],[12,"OpenGL_2_0","","",8],[12,"OpenGL_2_1","","",8],[12,"OpenGL_3_0","","",8],[12,"OpenGL_3_1","","",8],[12,"OpenGL_3_2","","",8],[12,"OpenGL_3_3","","",8],[12,"OpenGL_4_0","","",8],[12,"OpenGL_4_1","","",8],[12,"OpenGL_4_2","","",8],[12,"OpenGL_4_3","","",8],[12,"OpenGL_4_4","","",8],[0,"glsl","piston::shader_version","Models versions of OpenGL Shader Language (GLSL)"],[2,"GLSL","piston::shader_version::glsl","For OpenGL version 3.3 and above,\nthe GLSL version is the same as the OpenGL version."],[12,"GLSL_1_10","","",9],[12,"GLSL_1_20","","",9],[12,"GLSL_1_30","","",9],[12,"GLSL_1_40","","",9],[12,"GLSL_1_50","","",9],[12,"GLSL_3_30","","",9],[12,"GLSL_4_00","","",9],[12,"GLSL_4_10","","",9],[12,"GLSL_4_20","","",9],[12,"GLSL_4_30","","",9],[12,"GLSL_4_40","","",9],[2,"VersionRange","piston::shader_version","Models knowledge about version range."],[12,"VersionFromTo","","The version range is working from a version,\nup to but not included another version.",10],[12,"VersionFrom","","The version range is working from a version,\nand possibly for all newer versions unless\nthe context it is used implies otherwise.",10],[0,"image","piston",""],[0,"imageops","piston::image","Image Processing Functions"],[3,"crop","piston::image::imageops","Return a mutable view into an image"],[3,"brighten","","Brighten the supplied image\n```value``` is the amount to brighten each pixel by.\nNegative values decrease the brightness and positive values increase it."],[3,"flip_horizontal","","Flip an image horizontally"],[3,"invert","","Invert each pixel within the supplied image\nThis function operates in place."],[3,"blur","","Performs a Gaussian blur on the supplied image.\n```sigma``` is a measure of how much to blur by."],[3,"unsharpen","","Performs an unsharpen mask on the supplied image\n```sigma``` is the amount to blur the image by.\n```threshold``` is the threshold for the difference between\nsee https://en.wikipedia.org/wiki/Unsharp_masking#Digital_unsharp_masking"],[3,"filter3x3","","Perform a 3x3 box filter on the supplied image.\n```kernel``` is an array of the filter weights of length 9."],[10,"new","image::webp::decoder","Create a new WebpDecoder from the Reader ```r```.\nThis function takes ownership of the Reader.",11],[10,"dimensions","","",11],[10,"colortype","","",11],[10,"row_len","","",11],[10,"read_scanline","","",11],[10,"read_image","","",11],[10,"load_rect","","",11],[10,"new","image::webp::vp8","",12],[10,"init","","",12],[10,"read_bool","","",12],[10,"read_literal","","",12],[10,"read_magnitude_and_sign","","",12],[10,"read_with_tree","","",12],[10,"read_flag","","",12],[10,"clone","","",13],[10,"clone_from","","",13],[10,"fmt","","",13],[10,"default","","",13],[10,"default","","",14],[10,"new","","Create a new decoder.\nThe reader must present a raw vp8 bitstream to the decoder",15],[10,"decode_frame","","Decodes the current frame and returns a reference to it",15],[10,"new","image::ppm::encoder","Create a new PPMEncoder from the Writer ```w```.\nThis function takes ownership of the Writer.",16],[10,"encode","","Encode the buffer ```im``` as a PPM image.\n```width``` and ```height``` are the dimensions of the buffer.\n```color``` is the buffers ColorType.",16],[10,"fmt","image::png::filter","",17],[10,"from_i64","","",17],[10,"from_u64","","",17],[10,"from_int","","",17],[10,"from_i8","","",17],[10,"from_i16","","",17],[10,"from_i32","","",17],[10,"from_uint","","",17],[10,"from_u8","","",17],[10,"from_u16","","",17],[10,"from_u32","","",17],[10,"from_f32","","",17],[10,"from_f64","","",17],[10,"eq","image::png::decoder","",18],[10,"ne","","",18],[10,"ne","","",18],[10,"new","","Create a new decoder that decodes from the stream ```r```",19],[10,"palette","","Returns a reference to the color palette used for indexed\ncolor images.\nEach array element is a tuple of RGB values.",19],[10,"dimensions","","",19],[10,"colortype","","",19],[10,"row_len","","",19],[10,"read_scanline","","",19],[10,"read_image","","",19],[10,"load_rect","","",19],[10,"new","","",20],[10,"set_inital_length","","",20],[10,"read","","",20],[10,"read_at_least","","",20],[10,"read_byte","","",20],[10,"push","","",20],[10,"push_at_least","","",20],[10,"read_exact","","",20],[10,"read_to_end","","",20],[10,"read_to_string","","",20],[10,"bytes","","",20],[10,"read_le_uint_n","","",20],[10,"read_le_int_n","","",20],[10,"read_be_uint_n","","",20],[10,"read_be_int_n","","",20],[10,"read_le_uint","","",20],[10,"read_le_int","","",20],[10,"read_be_uint","","",20],[10,"read_be_int","","",20],[10,"read_be_u64","","",20],[10,"read_be_u32","","",20],[10,"read_be_u16","","",20],[10,"read_be_i64","","",20],[10,"read_be_i32","","",20],[10,"read_be_i16","","",20],[10,"read_be_f64","","",20],[10,"read_be_f32","","",20],[10,"read_le_u64","","",20],[10,"read_le_u32","","",20],[10,"read_le_u16","","",20],[10,"read_le_i64","","",20],[10,"read_le_i32","","",20],[10,"read_le_i16","","",20],[10,"read_le_f64","","",20],[10,"read_le_f32","","",20],[10,"read_u8","","",20],[10,"read_i8","","",20],[10,"by_ref","","",20],[10,"new","image::png::encoder","Create a new encoder that writes its output to ```w```",21],[10,"encode","","Encodes the image ```image```\nthat has dimensions ```width``` and ```height```\nand ```ColorType``` ```c```",21],[10,"new","image::png::zlib","Create a new decoder that decodes from a Reader",22],[10,"inner","","Return a mutable reference to the wrapped Reader",22],[10,"read","","",22],[10,"read_at_least","","",22],[10,"read_byte","","",22],[10,"push","","",22],[10,"push_at_least","","",22],[10,"read_exact","","",22],[10,"read_to_end","","",22],[10,"read_to_string","","",22],[10,"bytes","","",22],[10,"read_le_uint_n","","",22],[10,"read_le_int_n","","",22],[10,"read_be_uint_n","","",22],[10,"read_be_int_n","","",22],[10,"read_le_uint","","",22],[10,"read_le_int","","",22],[10,"read_be_uint","","",22],[10,"read_be_int","","",22],[10,"read_be_u64","","",22],[10,"read_be_u32","","",22],[10,"read_be_u16","","",22],[10,"read_be_i64","","",22],[10,"read_be_i32","","",22],[10,"read_be_i16","","",22],[10,"read_be_f64","","",22],[10,"read_be_f32","","",22],[10,"read_le_u64","","",22],[10,"read_le_u32","","",22],[10,"read_le_u16","","",22],[10,"read_le_i64","","",22],[10,"read_le_i32","","",22],[10,"read_le_i16","","",22],[10,"read_le_f64","","",22],[10,"read_le_f32","","",22],[10,"read_u8","","",22],[10,"read_i8","","",22],[10,"by_ref","","",22],[10,"clone","image::png::deflate","",23],[10,"clone_from","","",23],[10,"eq","","",23],[10,"ne","","",23],[10,"ne","","",23],[10,"put","","",23],[10,"new","","Create a new decoder that decodes from a Reader",24],[10,"eof","","Indicate whether the end of the stream has been reached.",24],[10,"inner","","Return a mutable reference to the wrapped Reader",24],[10,"read","","",24],[10,"read_at_least","","",24],[10,"read_byte","","",24],[10,"push","","",24],[10,"push_at_least","","",24],[10,"read_exact","","",24],[10,"read_to_end","","",24],[10,"read_to_string","","",24],[10,"bytes","","",24],[10,"read_le_uint_n","","",24],[10,"read_le_int_n","","",24],[10,"read_be_uint_n","","",24],[10,"read_be_int_n","","",24],[10,"read_le_uint","","",24],[10,"read_le_int","","",24],[10,"read_be_uint","","",24],[10,"read_be_int","","",24],[10,"read_be_u64","","",24],[10,"read_be_u32","","",24],[10,"read_be_u16","","",24],[10,"read_be_i64","","",24],[10,"read_be_i32","","",24],[10,"read_be_i16","","",24],[10,"read_be_f64","","",24],[10,"read_be_f32","","",24],[10,"read_le_u64","","",24],[10,"read_le_u32","","",24],[10,"read_le_u16","","",24],[10,"read_le_i64","","",24],[10,"read_le_i32","","",24],[10,"read_le_i16","","",24],[10,"read_le_f64","","",24],[10,"read_le_f32","","",24],[10,"read_u8","","",24],[10,"read_i8","","",24],[10,"by_ref","","",24],[10,"new","","",25],[10,"guarantee","","",25],[10,"byte_align","","",25],[10,"consume","","",25],[10,"receive","","",25],[10,"decode_symbol","","",25],[10,"new","image::png::hash","Create a new hasher.",26],[10,"update","","Update the internal hasher with the bytes from ```buf```",26],[10,"checksum","","Return the computed hash.",26],[10,"reset","","Reset this hasher to its initial state.",26],[10,"new","","Create a new hasher.",27],[10,"update","","Update the internal hasher with the bytes from ```buf```",27],[10,"checksum","","Return the computed hash.",27],[10,"reset","","Reset this hasher to its initial state.",27],[10,"new","image::jpeg::encoder","Create a new encoder that writes its output to ```w```",28],[10,"encode","","Encodes the image ```image```\nthat has dimensions ```width``` and ```height```\nand ```ColorType``` ```c```\nThe Image in encoded with subsampling ratio 4:2:2",28],[10,"clone","image::jpeg::decoder","",29],[10,"clone_from","","",29],[10,"eq","","",30],[10,"ne","","",30],[10,"ne","","",30],[10,"new","","Create a new decoder that decodes from the stream ```r```",31],[10,"dimensions","","",31],[10,"colortype","","",31],[10,"row_len","","",31],[10,"read_scanline","","",31],[10,"read_image","","",31],[10,"load_rect","","",31],[10,"clone","image::jpeg::entropy","",32],[10,"clone_from","","",32],[10,"default","","",32],[10,"new","","",33],[10,"read_bit","","",33],[10,"receive","","",33],[10,"decode_symbol","","",33],[10,"new","image::gif::decoder","Create a new GIFDecoder from the Reader ```r```.\nThis function takes ownership of the Reader.",34],[10,"delay","","Returns the display delay in 100th's of a second for the currently\ndecoded image.",34],[10,"dimensions","","",34],[10,"colortype","","",34],[10,"row_len","","",34],[10,"read_scanline","","",34],[10,"read_image","","",34],[10,"load_rect","","",34],[10,"new","image::gif::lzw","Create a new decompressor from a Reader",35],[10,"read","","",35],[10,"read_at_least","","",35],[10,"read_byte","","",35],[10,"push","","",35],[10,"push_at_least","","",35],[10,"read_exact","","",35],[10,"read_to_end","","",35],[10,"read_to_string","","",35],[10,"bytes","","",35],[10,"read_le_uint_n","","",35],[10,"read_le_int_n","","",35],[10,"read_be_uint_n","","",35],[10,"read_be_int_n","","",35],[10,"read_le_uint","","",35],[10,"read_le_int","","",35],[10,"read_be_uint","","",35],[10,"read_be_int","","",35],[10,"read_be_u64","","",35],[10,"read_be_u32","","",35],[10,"read_be_u16","","",35],[10,"read_be_i64","","",35],[10,"read_be_i32","","",35],[10,"read_be_i16","","",35],[10,"read_be_f64","","",35],[10,"read_be_f32","","",35],[10,"read_le_u64","","",35],[10,"read_le_u32","","",35],[10,"read_le_u16","","",35],[10,"read_le_i64","","",35],[10,"read_le_i32","","",35],[10,"read_le_i16","","",35],[10,"read_le_f64","","",35],[10,"read_le_f32","","",35],[10,"read_u8","","",35],[10,"read_i8","","",35],[10,"by_ref","","",35],[10,"assert_receiver_is_total_eq","image::image","",36],[10,"eq","","",36],[10,"ne","","",36],[10,"ne","","",36],[10,"fmt","","",36],[10,"fmt","","",37],[10,"assert_receiver_is_total_eq","","",37],[10,"eq","","",37],[10,"ne","","",37],[10,"ne","","",37],[10,"next","","",38],[10,"size_hint","","",38],[10,"chain","","",38],[10,"zip","","",38],[10,"map","","",38],[10,"filter","","",38],[10,"filter_map","","",38],[10,"enumerate","","",38],[10,"peekable","","",38],[10,"skip_while","","",38],[10,"take_while","","",38],[10,"skip","","",38],[10,"take","","",38],[10,"scan","","",38],[10,"flat_map","","",38],[10,"fuse","","",38],[10,"inspect","","",38],[10,"by_ref","","",38],[10,"advance","","",38],[10,"collect","","",38],[10,"nth","","",38],[10,"last","","",38],[10,"fold","","",38],[10,"count","","",38],[10,"all","","",38],[10,"any","","",38],[10,"find","","",38],[10,"position","","",38],[10,"max_by","","",38],[10,"min_by","","",38],[10,"next","","",39],[10,"size_hint","","",39],[10,"chain","","",39],[10,"zip","","",39],[10,"map","","",39],[10,"filter","","",39],[10,"filter_map","","",39],[10,"enumerate","","",39],[10,"peekable","","",39],[10,"skip_while","","",39],[10,"take_while","","",39],[10,"skip","","",39],[10,"take","","",39],[10,"scan","","",39],[10,"flat_map","","",39],[10,"fuse","","",39],[10,"inspect","","",39],[10,"by_ref","","",39],[10,"advance","","",39],[10,"collect","","",39],[10,"nth","","",39],[10,"last","","",39],[10,"fold","","",39],[10,"count","","",39],[10,"all","","",39],[10,"any","","",39],[10,"find","","",39],[10,"position","","",39],[10,"max_by","","",39],[10,"min_by","","",39],[10,"clone","","",40],[10,"clone_from","","",40],[10,"new","","Construct a new ImageBuf with the specified width and height.",40],[10,"from_fn","","Construct a new ImageBuf by repeated application of the supplied function.\nThe arguments to the function are the pixel's x and y coordinates.",40],[10,"from_pixels","","Construct a new ImageBuf from a vector of pixels.",40],[10,"from_pixel","","Construct a new ImageBuf from a pixel.",40],[10,"pixelbuf","","Return an immutable reference to this image's pixel buffer",40],[10,"mut_pixelbuf","","Return a mutable reference to this image's pixel buffer",40],[10,"into_vec","","Destroy this ImageBuf, returning the internal vector",40],[10,"dimensions","","",40],[10,"bounds","","",40],[10,"get_pixel","","",40],[10,"put_pixel","","",40],[10,"pixels","","",40],[10,"get_mut_pixel","","",40],[10,"mut_pixels","","",40],[10,"index","","",40],[10,"new","","Construct a new subimage",41],[10,"mut_inner","","Return a mutable reference to the wrapped image.",41],[10,"change_bounds","","Change the coordinates of this subimage.",41],[10,"to_image","","Convert this subimage to an ImageBuf",41],[10,"dimensions","","",41],[10,"bounds","","",41],[10,"get_pixel","","",41],[10,"put_pixel","","",41],[10,"pixels","","",41],[10,"get_mut_pixel","","",41],[10,"mut_pixels","","",41],[10,"clone","image::dynimage","",42],[10,"clone_from","","",42],[10,"to_rgb","","Returns a copy of this image as an RGB image.",42],[10,"to_rgba","","Returns a copy of this image as an RGBA image.",42],[10,"to_luma","","Returns a copy of this image as a Luma image.",42],[10,"to_luma_alpha","","Returns a copy of this image as a LumaA image.",42],[10,"crop","","Return a cut out of this image delimited by the bounding rectangle.",42],[10,"as_rgb8","","Return a reference to an 8bit RGB image",42],[10,"as_mut_rgb8","","Return a mutable reference to an 8bit RGB image",42],[10,"as_rgba8","","Return a reference to an 8bit RGBA image",42],[10,"as_mut_rgba8","","Return a mutable reference to an 8bit RGBA image",42],[10,"as_luma8","","Return a reference to an 8bit Grayscale image",42],[10,"as_mut_luma8","","Return a mutable reference to an 8bit Grayscale image",42],[10,"as_luma_alpha8","","Return a reference to an 8bit Grayscale image with an alpha channel",42],[10,"as_mut_luma_alpha8","","Return a mutable reference to an 8bit Grayscale image with an alpha channel",42],[10,"raw_pixels","","Return this image's pixels as a byte vector.",42],[10,"color","","Return this image's color type.",42],[10,"grayscale","","Return a grayscale version of this image.",42],[10,"invert","","Invert the colors of this image.\nThis method operates inplace.",42],[10,"resize","","Resize this image using the specified filter algorithm.\n Returns a new image. The image's aspect ratio is preserved.\n```nwidth``` and ```nheight``` are the new image's dimensions",42],[10,"resize_exact","","Resize this image using the specified filter algorithm.\n Returns a new image. Does not preserve aspect ratio.\n```nwidth``` and ```nheight``` are the new image's dimensions",42],[10,"blur","","Performs a Gaussian blur on this image.\n```sigma``` is a measure of how much to blur by.",42],[10,"unsharpen","","Performs an unsharpen mask on this image\n```sigma``` is the amount to blur the image by.\n```threshold``` is a control of how much to sharpen.\nsee https://en.wikipedia.org/wiki/Unsharp_masking#Digital_unsharp_masking",42],[10,"filter3x3","","Filters this image with the specified 3x3 kernel.",42],[10,"adjust_contrast","","Adjust the contrast of this image.\n```contrast``` is the amount to adjust the contrast by.\nNegative values decrease the contrast and positive values increase the contrast.",42],[10,"brighten","","Brighten the pixels of this image.\n```value``` is the amount to brighten each pixel by.\nNegative values decrease the brightness and positive values increase it.",42],[10,"flipv","","Flip this image vertically",42],[10,"fliph","","Flip this image horizontally",42],[10,"rotate90","","Rotate this image 90 degrees clockwise.",42],[10,"rotate180","","Rotate this image 180 degrees clockwise.",42],[10,"rotate270","","Rotate this image 270 degrees clockwise.",42],[10,"save","","Encode this image and write it to ```w```",42],[10,"dimensions","","",42],[10,"bounds","","",42],[10,"get_pixel","","",42],[10,"put_pixel","","",42],[10,"pixels","","",42],[10,"clone","image::color","",43],[10,"clone_from","","",43],[10,"fmt","","",43],[10,"assert_receiver_is_total_eq","","",43],[10,"eq","","",43],[10,"ne","","",43],[10,"ne","","",43],[10,"fmt","","",44],[10,"clone","","",44],[10,"clone_from","","",44],[10,"assert_receiver_is_total_eq","","",44],[10,"eq","","",44],[10,"ne","","",44],[10,"ne","","",44],[10,"default","","",44],[10,"channel","","Returns the channels of this pixel as a tuple",44],[10,"fmt","","",45],[10,"clone","","",45],[10,"clone_from","","",45],[10,"assert_receiver_is_total_eq","","",45],[10,"eq","","",45],[10,"ne","","",45],[10,"ne","","",45],[10,"default","","",45],[10,"channels","","Returns the channels of this pixel as a tuple",45],[10,"alpha","","Returns the alpha channel of this pixel",45],[10,"fmt","","",46],[10,"clone","","",46],[10,"clone_from","","",46],[10,"assert_receiver_is_total_eq","","",46],[10,"eq","","",46],[10,"ne","","",46],[10,"ne","","",46],[10,"default","","",46],[10,"channels","","Returns the channels of this pixel as a tuple",46],[10,"fmt","","",47],[10,"clone","","",47],[10,"clone_from","","",47],[10,"assert_receiver_is_total_eq","","",47],[10,"eq","","",47],[10,"ne","","",47],[10,"ne","","",47],[10,"default","","",47],[10,"channels","","Returns the channels of this pixel as a tuple",47],[10,"alpha","","Returns the alpha channel of this pixel",47],[10,"from_channels","","",46],[10,"to_luma","","",46],[10,"to_luma_alpha","","",46],[10,"to_rgb","","",46],[10,"to_rgba","","",46],[10,"invert","","",46],[10,"map","","",46],[10,"map_with_alpha","","",46],[10,"map2","","",46],[10,"channels4","","",46],[10,"from_channels","","",47],[10,"to_luma","","",47],[10,"to_luma_alpha","","",47],[10,"to_rgb","","",47],[10,"to_rgba","","",47],[10,"invert","","",47],[10,"map","","",47],[10,"map_with_alpha","","",47],[10,"map2","","",47],[10,"channels4","","",47],[10,"from_channels","","",44],[10,"to_luma","","",44],[10,"to_luma_alpha","","",44],[10,"to_rgb","","",44],[10,"to_rgba","","",44],[10,"invert","","",44],[10,"map","","",44],[10,"map_with_alpha","","",44],[10,"map2","","",44],[10,"channels4","","",44],[10,"from_channels","","",45],[10,"to_luma","","",45],[10,"to_luma_alpha","","",45],[10,"to_rgb","","",45],[10,"to_rgba","","",45],[10,"invert","","",45],[10,"map","","",45],[10,"map_with_alpha","","",45],[10,"map2","","",45],[10,"channels4","","",45],[2,"FilterType","piston::image::imageops","Available Sampling Filters"],[12,"Nearest","","Nearest Neighbor",48],[12,"Triangle","","Linear Filter",48],[12,"CatmullRom","","Cubic Filter",48],[12,"Gaussian","","Gaussian Filter",48],[12,"Lanczos3","","Lanczos with window 3",48],[3,"rotate90","","Rotate an image 90 degrees clockwise."],[3,"resize","","Resize the supplied image to the specified dimensions\n```nwidth``` and ```nheight``` are the new dimensions.\n```filter``` is the sampling filter to use."],[3,"flip_vertical","","Flip an image vertically"],[3,"grayscale","","Convert the supplied image to grayscale"],[3,"rotate180","","Rotate an image 180 degrees clockwise."],[3,"contrast","","Adjust the contrast of the supplied image\n```contrast``` is the amount to adjust the contrast by.\nNegative values decrease the contrast and positive values increase the contrast."],[3,"rotate270","","Rotate an image 270 degrees clockwise."],[0,"webp","piston::image","Decoding of Webp Images"],[0,"vp8","piston::image::webp","An implementation of the VP8 Video Codec"],[1,"Frame","piston::image::webp::vp8","A Representation of the last decoded video frame"],[11,"width","","The width of the luma plane",13],[11,"height","","The height of the luma plane",13],[11,"ybuf","","The luma plane of the frame",13],[11,"keyframe","","Indicates whether this frame is a keyframe",13],[11,"for_display","","Indicates whether this frame is intended for display",13],[11,"pixel_type","","The pixel type of the frame as defined by Section 9.2\nof the VP8 Specification",13],[1,"VP8Decoder","","VP8 Decoder\nOnly decodes keyframes"],[1,"WebpDecoder","piston::image::webp","A Representation of a Webp Image format decoder."],[0,"ppm","piston::image","Encoding of portable pixmap Images"],[1,"PPMEncoder","piston::image::ppm","A representation of a PPM encoder."],[0,"png","piston::image","Decoding and Encoding of PNG Images"],[0,"zlib","piston::image::png","An Implementation of RFC 1950"],[1,"ZlibDecoder","piston::image::png::zlib","A Zlib compressed stream decoder."],[0,"deflate","piston::image::png","An Implementation of RFC 1951"],[1,"Inflater","piston::image::png::deflate","A DEFLATE compressed stream decoder."],[0,"hash","piston::image::png","This module provides implementations of common hashing algorithms."],[1,"Adler32","piston::image::png::hash","An Implementation of the Adler-32 checksum"],[1,"Crc32","","An Implementation of the Crc-32 checksum"],[1,"PNGDecoder","piston::image::png","The representation of a PNG decoder"],[1,"PNGEncoder","","The representation of a PNG encoder"],[0,"jpeg","piston::image","Decoding and Encoding of JPEG Images"],[1,"Component","piston::image::jpeg","A representation of a JPEG component"],[11,"id","","The Component's identifier",29],[11,"h","","Horizontal sampling factor",29],[11,"v","","Vertical sampling factor",29],[11,"tq","","The quantization table selector",29],[11,"dc_table","","Index to the Huffman DC Table",29],[11,"ac_table","","Index to the AC Huffman Table",29],[11,"dc_pred","","The dc prediction of the component",29],[1,"JPEGEncoder","","The representation of a JPEG encoder"],[1,"JPEGDecoder","","The representation of a JPEG decoder"],[0,"gif","piston::image","Decoding of GIF Images"],[0,"lzw","piston::image::gif","This modules provides an implementation of the Lempel–Ziv–Welch Compression Algorithm"],[1,"LZWReader","piston::image::gif::lzw","An implementation of an LZW Decompressor."],[1,"GIFDecoder","piston::image::gif","The Representation of a GIF decoder"],[1,"Rgb","piston::image","A type to hold an RGB pixel"],[3,"open","","Open the image located at the path specified.\nThe image's format is determined from the path's file extension."],[1,"LumaA","","A type to hold a grayscale pixel with an alpha channel"],[2,"FilterType","","Available Sampling Filters"],[12,"Nearest","","Nearest Neighbor",48],[12,"Triangle","","Linear Filter",48],[12,"CatmullRom","","Cubic Filter",48],[12,"Gaussian","","Gaussian Filter",48],[12,"Lanczos3","","Lanczos with window 3",48],[1,"Rgba","","A type to hold an RGB pixel with an alpha channel"],[2,"ColorType","","An enumeration over supported color types and their bit depths"],[12,"Grey","","Pixel is greyscale",43],[12,"RGB","","Pixel contains R, G and B channels",43],[12,"Palette","","Pixel is an index into a color palette",43],[12,"GreyA","","Pixel is greyscale with an alpha channel",43],[12,"RGBA","","Pixel is RGB with an alpha channel",43],[6,"Pixel","","A trait that all pixels implement."],[9,"from_channels","","Construct a pixel from the 4 channels a, b, c and d.\nIf the pixel does not contain 4 channels the extra are ignored.",49],[9,"to_rgb","","Convert this pixel to RGB",49],[9,"to_rgba","","Convert this pixel to RGB with an alpha channel",49],[9,"to_luma","","Convert this pixel to luma",49],[9,"to_luma_alpha","","Convert this pixel to luma with an alpha channel",49],[9,"invert","","Invert this pixel",49],[9,"map","","Apply the function ```f``` to each channel of this pixel.",49],[9,"map_with_alpha","","Apply the function f to each channel except the alpha channel.\nApply the function g to the alpha channel.",49],[9,"map2","","Apply the function ```f``` to each channel of this pixel and\n```other``` pairwise.",49],[9,"channels4","","Returns the channels of this pixel as a 4 tuple. If the pixel\nhas less than 4 channels the remainder is filled with the maximum value",49],[1,"Pixels","","Immutable pixel iterator"],[1,"MutPixels","","Mutable pixel iterator"],[1,"ImageBuf","","An Image whose pixels are contained within a vector"],[2,"ImageFormat","","An enumeration of supported image formats.\nNot all formats support both encoding and decoding."],[12,"PNG","","An Image in PNG Format",37],[12,"JPEG","","An Image in JPEG Format",37],[12,"GIF","","An Image in GIF Format",37],[12,"WEBP","","An Image in WEBP Format",37],[12,"PPM","","An Image in PPM Format",37],[1,"Luma","","A type to hold a grayscale pixel"],[3,"load_from_memory","","Create a new image from a byte slice"],[6,"ImageDecoder","","The trait that all decoders implement"],[9,"dimensions","","Return a tuple containing the width and height of the image",50],[9,"colortype","","Return the color type of the image e.g RGB(8) (8bit RGB)",50],[9,"row_len","","Returns the length in bytes of one decoded row of the image",50],[9,"read_scanline","","Read one row from the image into buf\nReturns the row index",50],[9,"read_image","","Decode the entire image and return it as a Vector",50],[9,"load_rect","","Decode a specific region of the image, represented by the rectangle\nstarting from ```x``` and ```y``` and having ```length``` and ```width```",50],[6,"MutableRefImage","","A trait for images that allow providing mutable references to pixels."],[9,"get_mut_pixel","","Return a mutable reference to the pixel located at (x, y)",51],[9,"mut_pixels","","Return an Iterator over mutable pixels of this image.\nThe iterator yields the coordinates of each pixel\nalong with a mutable reference to them.",51],[2,"ImageError","","An enumeration of Image Errors"],[12,"FormatError","","The Image is not formatted properly",36],[12,"DimensionError","","The Image's dimensions are either too small or too large",36],[12,"UnsupportedError","","The Decoder does not support this image format",36],[12,"UnsupportedColor","","The Decoder does not support this color type",36],[12,"NotEnoughData","","Not enough data was provided to the Decoder\nto decode the image",36],[12,"IoError","","An I/O Error occurred while decoding the image",36],[12,"ImageEnd","","The end of the image has been reached",36],[4,"ImageResult","",""],[2,"DynamicImage","","A Dynamic Image"],[12,"ImageLuma8","","Each pixel in this image is 8-bit Luma",42],[12,"ImageLumaA8","","Each pixel in this image is 8-bit Luma with alpha",42],[12,"ImageRgb8","","Each pixel in this image is 8-bit Rgb",42],[12,"ImageRgba8","","Each pixel in this image is 8-bit Rgb with alpha",42],[3,"load","","Create a new image from a Reader"],[1,"SubImage","","A View into another image"],[6,"GenericImage","","A trait for manipulating images."],[9,"dimensions","","The width and height of this image.",52],[9,"bounds","","The bounding rectangle of this image.",52],[9,"get_pixel","","Return the pixel located at (x, y)",52],[9,"put_pixel","","Put a pixel at location (x, y)",52],[9,"pixels","","Return an Iterator over the pixels of this image.\nThe iterator yields the coordinates of each pixel\nalong with their value",52],[0,"graphics","piston",""],[0,"internal","piston::graphics","Contains internal type aliases and traits."],[10,"clone","graphics::context","",53],[10,"clone_from","","",53],[10,"get_transform","","",53],[10,"transform","","",53],[10,"get_view_transform","","",53],[10,"view_transform","","",53],[10,"new","","Creates a new drawing context.",53],[10,"abs","","Creates a new drawing context in absolute coordinates.",53],[10,"rect","","",53],[10,"rect_centered","","",53],[10,"square","","",53],[10,"square_centered","","",53],[10,"rect","","",53],[10,"rect_centered","","",53],[10,"square","","",53],[10,"square_centered","","",53],[10,"rgba","","",53],[10,"rgb","","",53],[10,"color","","",53],[10,"grey","","",53],[10,"alpha","","",53],[10,"ellipse","","",53],[10,"ellipse_centered","","",53],[10,"circle","","",53],[10,"polygon","","",53],[10,"image","","",53],[10,"get_rectangle","","",53],[10,"get_source_rectangle","","",53],[10,"image","","",53],[10,"round","","",53],[10,"border_radius","","",53],[10,"border_width","","",53],[10,"polygons","","",53],[10,"rectangle","","",53],[10,"source_rectangle","","",53],[10,"draw","","",53],[10,"get_color","","",53],[10,"get_color","","",53],[10,"color","","",53],[10,"line","","",53],[10,"draw","","",53],[10,"draw","","",53],[10,"lerp","","",53],[10,"square_border_radius","","",53],[10,"square_border_width","","",53],[10,"bevel_border_radius","","",53],[10,"bevel_border_width","","",53],[10,"round_border_radius","","",53],[10,"round_border_width","","",53],[10,"draw","","",53],[10,"rect","","",53],[10,"rect_centered","","",53],[10,"square","","",53],[10,"square_centered","","",53],[10,"image","","",53],[10,"draw","","",53],[10,"bevel","","",53],[10,"draw","","",53],[10,"draw","","",53],[10,"draw","","",53],[10,"draw","","",53],[10,"draw","","",53],[10,"draw","","",53],[10,"draw","","",53],[10,"draw","","",53],[10,"draw","","",53],[10,"draw","","",53],[10,"draw","","",53],[10,"draw","","",53],[10,"draw","","",53],[10,"bevel","graphics::shape","",54],[10,"round","","",54],[10,"border_radius","","",54],[10,"border_width","","",54],[10,"rectangle","","",54],[10,"rectangle","","",54],[10,"rectangle","","",54],[10,"get_rectangle","","",54],[10,"get_rectangle","","",54],[10,"get_rectangle","","",54],[10,"get_source_rectangle","","",54],[10,"source_rectangle","","",54],[10,"polygons","","",54],[10,"get_color","","",54],[4,"Area","piston::graphics::internal",""],[4,"Color","",""],[4,"ColorComponent","",""],[4,"Line","",""],[4,"SourceRectangle","",""],[4,"Polygon","",""],[4,"Polygons","",""],[4,"Radius","",""],[4,"Ray","",""],[4,"Rectangle","",""],[4,"Triangle","",""],[4,"Vec2d","",""],[4,"Width","",""],[6,"CanColor","","Implemented by contexts that can color."],[9,"color","","Create a new context with color.",55],[6,"CanRectangle","","Implemented by contexts that can set rectangle information."],[9,"rectangle","","Create new context with rectangle information.",56],[6,"CanSourceRectangle","","Implemented by contexts that can set source rectangle information."],[9,"source_rectangle","","Create new context with source rectangle information.",57],[6,"CanTransform","","Implemented by contexts that can transform."],[9,"transform","","Create a new context with transformation.",58],[6,"CanViewTransform","","Implemented by contexts that can view transform."],[9,"view_transform","","Create a new context with view transformation.",59],[6,"HasColor","","Implemented by contexts that uses type `U` as current color."],[9,"get_color","","Returns the current color.",60],[6,"HasRectangle","","Implemented by contexts that uses type `U` as current rectangle."],[9,"get_rectangle","","Returns the current rectangle.",61],[6,"HasSourceRectangle","","Implemented by contexts that uses type `U` as current source rectangle."],[9,"get_source_rectangle","","Returns the current source rectangle.",62],[6,"HasTransform","","Implemented by contexts that uses type `U` as current transform."],[9,"get_transform","","Returns the current transform.",63],[6,"HasViewTransform","","Implemented by contexts that uses type `U` as current view transform."],[9,"get_view_transform","","Returns the current view transform.",64],[0,"interpolation","piston::graphics","Interpolation algorithms."],[3,"lerp","piston::graphics::interpolation","Performs linear interpolation.\nA linear interpolation consists of two states 'a' and 'b'.\nThe 't' variable is a factor between 0 and 1 that \ngives weight to 'a' or 'b'.\nWhen 't' is zero then 'a' has full weight.\nWhen 't' is one then 'b' has full weight."],[3,"lerp_2","","Performs linear interpolation on array of size 3."],[3,"lerp_3","","Performs linear interpolation on array of size 3."],[3,"lerp_4","","Performs linear interpolation on array of size 4."],[3,"lerp_5","","Performs linear interpolation on array of size 5."],[3,"quad_bez","","Performs quadratic beziér interpolation.\nThis is done by nesting linear interpolations.\nFor more information, see:"],[3,"cub_bez","","Performs cubic beziér interpolation.\nThis is done by interpolation between two quadratic beziér.\nFor more information, see:"],[0,"modular_index","piston::graphics","Helper functions for computing modular index safely."],[3,"offset","piston::graphics::modular_index","Computes modular offset safely for indices."],[3,"previous","","Computes previous modular index safely."],[3,"next","","Computes next modular index safely."],[0,"triangulation","piston::graphics","Methods for converting shapes into triangles."],[3,"with_lerp_polygons_tri_list_xy_f32_rgba_f32","piston::graphics::triangulation","Streams tweened polygons using linear interpolation."],[3,"with_ellipse_tri_list_xy_f32_rgba_f32","","Streams an ellipse specified by a resolution."],[3,"with_round_border_line_tri_list_xy_f32_rgba_f32","","Streams a round border line."],[3,"with_round_rectangle_tri_list_xy_f32_rgba_f32","","Streams a round rectangle."],[3,"stream_polygon_tri_list_xy_f32_rgba_f32","","Streams a polygon into tri list with color per vertex.\nUses buffers that fit inside L1 cache."],[3,"with_ellipse_border_tri_list_xy_f32_rgba_f32","","Streams an ellipse border specified by a resolution."],[3,"with_round_rectangle_border_tri_list_xy_f32_rgba_f32","","Streams a round rectangle border."],[3,"stream_quad_tri_list_xy_f32_rgba_f32","","Streams a quad into tri list with color per vertex."],[3,"with_polygon_tri_list_xy_f32_rgba_f32","","Splits polygon into convex segments with one color per vertex.\nCreate a buffer that fits into L1 cache with 1KB overhead."],[3,"rect_tri_list_xy_f32","","Creates triangle list vertices from rectangle."],[3,"rect_border_tri_list_xy_f32","","Creates triangle list vertices from rectangle."],[3,"rect_tri_list_rgba_f32","","Creates triangle list colors from rectangle."],[3,"rect_border_tri_list_rgba_f32","","Creates triangle list colors from rectangle border."],[3,"rect_tri_list_uv_f32","","Creates triangle list texture coords from image."],[0,"vecmath","piston::graphics","Various methods for computing with vectors."],[4,"Scalar","piston::graphics::vecmath",""],[4,"Matrix2d","",""],[4,"Vec2d","",""],[3,"translate","","Creates a translation matrix."],[3,"rotate_radians","","Creates a rotation matrix."],[3,"orient","","Orients x axis to look at point."],[3,"scale","","Create a scale matrix."],[3,"shear","","Create a shear matrix."],[3,"identity","","Create an identity matrix."],[3,"get_scale","","Extract scale information from matrix."],[3,"separation","","Compute the shortest vector from point to ray.\nA ray stores starting point and directional vector."],[3,"least_separation_4","","Returns the least separation out of four.\nEach seperation can be computed using `separation` function.\nThe separation returned can be used\nto solve collision of rectangles."],[3,"margin_rectangle","","Shrinks a rectangle by a factor on all sides."],[3,"relative_rectangle","","Computes a relative rectangle using the rectangle as a tile."],[3,"relative_source_rectangle","","Computes a relative source rectangle using\nthe source rectangle as a tile."],[3,"modular_offset","","Computes modular offset safely for numbers."],[3,"area_centroid","","Computes the area and centroid of a simple polygon."],[3,"area","","Computes area of a simple polygon."],[3,"centroid","","Computes centroid of a simple polygon."],[3,"line_side","","Returns a number that tells which side it is relative to a line."],[3,"inside_triangle","","Returns true if point is inside triangle."],[3,"triangle_face","","Returns true if triangle is clockwise."],[3,"hsv","","Transform color with hue saturation and value."],[3,"row_mat2x3_mul","","Multiplies two matrices."],[4,"BevelBorderLineContext","piston::graphics",""],[4,"BevelBorderLineColorContext","",""],[4,"BevelRectangleContext","",""],[4,"BevelRectangleColorContext","",""],[4,"BevelRectangleBorderContext","",""],[4,"BevelRectangleBorderColorContext","",""],[4,"ColorContext","",""],[4,"EllipseContext","",""],[4,"EllipseBorderContext","",""],[4,"EllipseColorContext","",""],[4,"EllipseBorderColorContext","",""],[4,"LerpTweenContext","",""],[4,"LerpTweenColorContext","",""],[4,"LerpTweenPolygonsContext","",""],[4,"LerpTweenPolygonsColorContext","",""],[4,"LineContext","",""],[4,"LineColorContext","",""],[4,"ImageContext","",""],[4,"ImageColorContext","",""],[4,"ImageRectangleContext","",""],[4,"ImageRectangleColorContext","",""],[4,"PolygonContext","",""],[4,"PolygonColorContext","",""],[4,"RectangleContext","",""],[4,"RectangleBorderContext","",""],[4,"RectangleColorContext","",""],[4,"RectangleBorderColorContext","",""],[4,"RoundBorderLineContext","",""],[4,"RoundBorderLineColorContext","",""],[4,"RoundRectangleContext","",""],[4,"RoundRectangleColorContext","",""],[4,"RoundRectangleBorderContext","",""],[4,"RoundRectangleBorderColorContext","",""],[4,"SquareBorderLineContext","",""],[4,"SquareBorderLineColorContext","",""],[6,"AddRoundBorder","","Implemented by contexts that can add round border."],[9,"round_border_radius","","Adds a round border radius.",65],[9,"round_border_width","","Adds a round border width.",65],[6,"RelativeRectangle","","Should be implemented by contexts that have rectangle information."],[9,"margin","","Shrinks the current rectangle equally by all sides.",66],[9,"expand","","Expands the current rectangle equally by all sides.",66],[9,"rel","","Moves to a relative rectangle using the current rectangle as tile.",66],[6,"AddColor","","Implemented by contexts who can add color."],[9,"rgba","","Add color with alpha channel.",67],[9,"rgb","","Adds color with alpha channel set to 1.0.",67],[9,"color","","Add color [r, g, b, a].",67],[9,"grey","","Adds a gray color.",67],[9,"alpha","","Adds a white semi-transparent color.",67],[6,"BackEnd","","Implemented by all graphics back-ends.\nThis trait uses default methods to simplify implementation."],[9,"supports_clear_rgba","","Returns true if feature is supported.",68],[9,"clear_rgba","","Clears background with a color.",68],[9,"enable_alpha_blend","","Turns on alpha blending.",68],[9,"disable_alpha_blend","","Turns off alpha blending.",68],[9,"supports_single_texture","","Returns true if texture feature is supported.",68],[9,"enable_single_texture","","Sets the current single-texture.",68],[9,"disable_single_texture","","Disables single-texture.",68],[9,"has_texture_alpha","","Should return true if texture has alpha channel.",68],[9,"supports_tri_list_xy_f64_rgba_f32","","Returns true if feature is supported.",68],[9,"tri_list_xy_f64_rgba_f32","","Renders list of 2d triangles with color assigned per vertex.",68],[9,"supports_tri_list_xy_f32_rgba_f32","","Returns true if feature is supported.",68],[9,"tri_list_xy_f32_rgba_f32","","Renders list of 2d triangles with color assigned per vertex.",68],[9,"supports_tri_list_xy_f32_rgba_f32_uv_f32","","Returns true if feature is supported.",68],[9,"tri_list_xy_f32_rgba_f32_uv_f32","","Renders list of 2d triangles.",68],[6,"RelativeTransform2d","","Implemented by contexts that can transform."],[9,"trans","","Translate x an y in local coordinates.",69],[9,"rot_deg","","Rotates degrees in local coordinates.",69],[9,"rot_rad","","Rotate radians in local coordinates.",69],[9,"orient","","Orients x axis to look at point locally.",69],[9,"scale","","Scales in local coordinates.",69],[9,"zoom","","Scales in both directions in local coordinates.",69],[9,"flip_v","","Flips vertically in local coordinates.",69],[9,"flip_h","","Flips horizontally in local coordinates.",69],[9,"flip_hv","","Flips horizontally and vertically in local coordinates.",69],[9,"shear","","Shears in local coordinates.",69],[6,"RelativeColor","","Implemented by contexts that contains color."],[9,"mul_rgba","","Multiplies with red, green, blue and alpha values.",70],[9,"tint","","Mixes the current color with white.",70],[9,"shade","","Mixes the current color with black.",70],[9,"hue_deg","","Rotates hue by degrees.",70],[9,"hue_rad","","Rotates hue by radians.",70],[6,"AddPolygons","","Implemented by tweening contexts that can add polygons."],[9,"polygons","","Add polygons.",71],[6,"AddBevelBorder","","Implemented by contexts that can add round border."],[9,"bevel_border_radius","","Adds a bevel border radius.",72],[9,"bevel_border_width","","Adds a bevel border width.",72],[6,"AddEllipse","","Implemented by all contexts that can add ellipse."],[9,"ellipse","","Adds an ellipse.",73],[9,"ellipse_centered","","Adds an ellipse with coordinates in the center.",73],[9,"circle","","Adds a circle.",73],[6,"ImageSize","","Must be implemented by all images to be used with graphics back-end."],[9,"get_size","","Get the image size.",74],[6,"AddBorder","","Implemented by contexts that can add border."],[9,"border_radius","","Adds a border radius.",75],[9,"border_width","","Adds a border width.",75],[6,"AddLine","","Implemented by all contexts that can add rectangle."],[9,"line","","Adds a line.",76],[6,"AddSquareBorder","","Implemented by contexts that can add square border."],[9,"square_border_radius","","Adds a square border radius.",77],[9,"square_border_width","","Adds a square border width.",77],[6,"RelativeSourceRectangle","","Should be implemented by contexts that\nhave source rectangle information."],[9,"src_rect","","Adds a source rectangle.",78],[9,"src_rel","","Moves to a relative source rectangle using\nthe current source rectangle as tile.",78],[9,"src_flip_h","","Flips the source rectangle horizontally.",78],[9,"src_flip_v","","Flips the source rectangle vertically.",78],[9,"src_flip_hv","","Flips the source rectangle horizontally and vertically.",78],[6,"AddImage","","Implemented by contexts that can add image."],[9,"image","","Add image to context.",79],[1,"Context","","Drawing 2d context."],[11,"view","","View transformation.",53],[11,"transform","","Current transformation.",53],[6,"AddTween","","Implemented by contexts who can give an animated inbetweening context."],[9,"lerp","","Do linear interpolation.",80],[6,"AddRectangle","","Implemented by all contexts that can add rectangle."],[9,"rect","","Adds a rectangle.",81],[9,"rect_centered","","Adds a rectangle with coordinates in the center.",81],[9,"square","","Adds a square with coordinates of upper left corner.",81],[9,"square_centered","","Adds a square with coordinates in the center.",81],[6,"Draw","","Implemented by contexts that can draws something using a back-end."],[9,"draw","","Draw using back-end.",82],[6,"AddPolygon","","Implemented by contexts who can add polygon."],[9,"polygon","","Add polygon.",83],[6,"View","","Should be implemented by contexts that\ndraws something relative to view."],[9,"view","","Moves the current transform to the view coordinate system.",84],[9,"reset","","Moves the current transform to the default coordinate system.",84],[9,"store_view","","Stores the current transform as new view.",84],[9,"get_view_size","","Computes the current view size.",84],[6,"AddBevel","","Implemented by contexts that can make a shape bevel."],[9,"bevel","","Bevels the shape of the current context.",85],[6,"AddRound","","Implemented by contexts that can make a shape rounder."],[9,"round","","Rounds the shape of the current context.",86],[0,"vecmath","piston",""],[4,"Vector2","piston::vecmath",""],[4,"Vector3","",""],[4,"Vector4","",""],[4,"Matrix2x3","",""],[4,"Matrix3x2","",""],[4,"Matrix3","",""],[4,"Matrix3x4","",""],[4,"Matrix4x3","",""],[4,"Matrix4","",""],[3,"col_mat3x2_mul_col","","Computes column vector in column matrix product."],[3,"col_mat3_mul_col","","Computes column vector in column matrix product."],[3,"col_mat4x3_mul_col","","Computes column vector in column matrix product."],[3,"col_mat4_mul_col","","Computes column vector in column matrix product."],[3,"row_mat2x3_mul_row","","Computes row vector in row matrix product."],[3,"row_mat3_mul_row","","Computes row vector in row matrix product."],[3,"row_mat3x4_mul_row","","Computes row vector in row matrix product."],[3,"row_mat4_mul_row","","Computes row vector in row matrix product."],[3,"col_mat3x2_mul","","Multiplies two matrices."],[3,"col_mat3_mul","","Multiplies two matrices."],[3,"col_mat4x3_mul","","Multiplies two matrices."],[3,"col_mat4_mul","","Multiplies two matrices."],[3,"row_mat2x3_mul","","Multiplies two matrices."],[3,"row_mat3_mul","","Multiplies two matrices."],[3,"row_mat3x4_mul","","Multiplies two matrices."],[3,"row_mat4_mul","","Multiplies two matrices."],[3,"mat2x3_id","","Constructs identity matrix."],[3,"mat3x2_id","","Constructs identity matrix."],[3,"mat3_id","","Constructs identity matrix."],[3,"mat3x4_id","","Constructs identity matrix."],[3,"mat4x3_id","","Constructs identity matrix."],[3,"mat4_id","","Constructs identity matrix."],[3,"vec2_to_f32","","Converts to a f32 vector."],[3,"vec3_to_f32","","Converts to a f32 vector."],[3,"vec4_to_f32","","Converts to a f32 vector."],[3,"mat2x3_to_f32","","Converts to a f32 matrix."],[3,"mat3x2_to_f32","","Converts to a f32 matrix."],[3,"mat3_to_f32","","Converts to a f32 matrix."],[3,"mat3x4_to_f32","","Converts to a f32 matrix."],[3,"mat4x3_to_f32","","Converts to a f32 matrix."],[3,"mat4_to_f32","","Converts to a f32 matrix."],[3,"vec2_to_f64","","Converts to a f64 vector."],[3,"vec3_to_f64","","Converts to a f64 vector."],[3,"vec4_to_f64","","Converts to a f64 vector."],[3,"mat2x3_to_f64","","Converts to a f64 matrix."],[3,"mat3x2_to_f64","","Converts to a f64 matrix."],[3,"mat3_to_f64","","Converts to a f64 matrix."],[3,"mat3x4_to_f64","","Converts to a f64 matrix."],[3,"mat4x3_to_f64","","Converts to a f64 matrix."],[3,"mat4_to_f64","","Converts to a f64 matrix."],[3,"vec2_from_f32","","Converts from a f32 vector."],[3,"vec3_from_f32","","Converts from a f32 vector."],[3,"vec4_from_f32","","Converts to a f32 vector."],[3,"mat2x3_from_f32","","Converts to a f32 matrix."],[3,"mat3x2_from_f32","","Converts to a f32 matrix."],[3,"mat3_from_f32","","Converts to a f32 matrix."],[3,"mat3x4_from_f32","","Converts to a f32 matrix."],[3,"mat4x3_from_f32","","Converts to a f32 column matrix."],[3,"mat4_from_f32","","Converts to a f32 matrix."],[3,"vec2_from_f64","","Converts to a f64 vector."],[3,"vec3_from_f64","","Converts to a f64 vector."],[3,"vec4_from_f64","","Converts to a f64 vector."],[3,"mat2x3_from_f64","","Converts to a f64 matrix."],[3,"mat3x2_from_f64","","Converts to a f64 matrix."],[3,"mat3_from_f64","","Converts to a f64 matrix."],[3,"mat3x4_from_f64","","Converts to a f64 matrix."],[3,"mat4x3_from_f64","","Converts to a f64 matrix."],[3,"mat4_from_f64","","Converts to a f64 matrix."],[3,"vec2_sub","","Subtracts 'b' from 'a'."],[3,"vec3_sub","","Subtracts 'b' from 'a'."],[3,"vec4_sub","","Subtracts 'b' from 'a'."],[3,"mat2x3_sub","","Subtracts 'b' from 'a'."],[3,"mat3x2_sub","","Subtracts 'b' from 'a'."],[3,"mat3_sub","","Subtracts 'b' from 'a'."],[3,"mat3x4_sub","","Subtracts 'b' from 'a'."],[3,"mat4x3_sub","","Subtracts 'b' from 'a'."],[3,"mat4_sub","","Subtracts 'b' from 'a'."],[3,"vec2_add","","Adds two vectors."],[3,"vec3_add","","Adds two vectors."],[3,"vec4_add","","Adds two vectors."],[3,"mat2x3_add","","Adds two matrices."],[3,"mat3x2_add","","Adds two matrices."],[3,"mat3_add","","Adds two matrices."],[3,"mat3x4_add","","Adds two matrices."],[3,"mat4x3_add","","Adds two matrices."],[3,"mat4_add","","Adds two matrices."],[3,"vec2_dot","","Computes the dot product."],[3,"vec3_dot","","Computes the dot product."],[3,"vec4_dot","","Computes the dot product."],[3,"vec2_square_len","","Computes the square length of a vector."],[3,"vec3_square_len","","Computes the square length of a vector."],[3,"vec4_square_len","","Computes the square length of a vector."],[3,"vec2_cross","","Computes the cross product."],[3,"vec3_cross","","Computes the cross product."],[3,"vec2_scale","","Multiplies the vector with a scalar."],[3,"vec3_scale","","Multiplies the vector with a scalar."],[3,"vec4_scale","","Multiplies the vector with a scalar."],[3,"vec2_len","","Computes the length of vector."],[3,"vec3_len","","Computes the length of vector."],[3,"vec4_len","","Computes the length of vector."],[3,"vec2_inv_len","","Computes the inverse length of a vector."],[3,"vec3_inv_len","","Computes the inverse length of a vector."],[3,"vec4_inv_len","","Computes the inverse length of a vector."],[3,"vec2_normalized","","Computes the normalized."],[3,"vec3_normalized","","Computes the normalized."],[3,"vec4_normalized","","Computes the normalized."],[3,"vec2_normalized_sub","","Computes the normalized difference between two vectors."],[3,"vec3_normalized_sub","","Computes the normalized difference between two vectors."],[3,"vec4_normalized_sub","","Computes the normalized difference between two vectors."],[3,"vec3_dot_vec2","","Computes transformed vector component."],[3,"vec4_dot_vec3","","Computes transformed vector component."],[3,"vec3_dot_pos2","","Computes transformed position component."],[3,"vec4_dot_pos3","","Computes transformed position component."],[3,"row_mat2x3_col","","Returns a column vector of a row matrix."],[3,"col_mat2x3_row","","Returns a row vector of a column matrix."],[3,"row_mat3x2_col","","Returns a column vector of a row matrix."],[3,"col_mat3x2_row","","Returns a row vector of a column matrix."],[3,"row_mat3_col","","Returns a column vector of a row matrix."],[3,"col_mat3_row","","Returns a row vector of a column matrix."],[3,"row_mat3x4_col","","Returns a column vector of a row matrix."],[3,"col_mat3x4_row","","Returns a row vector of a column matrix."],[3,"row_mat4x3_col","","Returns a column vector of a row matrix."],[3,"col_mat4x3_row","","Returns a column vector of a row matrix."],[3,"row_mat4_col","","Returns a column vector of a row matrix."],[3,"col_mat4_row","","Returns a row vector of a column matrix."],[3,"mat2x3_transposed","","Constructs the transpose of a matrix."],[3,"mat3x2_transposed","","Constructs the transpose of a matrix."],[3,"mat3_transposed","","Constructs the transpose of a matrix."],[3,"mat3x4_transposed","","Constructs the transpose of a matrix."],[3,"mat4x3_transposed","","Constructs the transpose of a matrix."],[3,"mat4_transposed","","Constructs the transpose of a matrix."],[3,"col_mat3_transform","","Transforms a 3D vector through a matrix."],[3,"col_mat4_transform","","Transforms a 4D vector through a matrix."],[3,"row_mat3_transform","","Transforms a 3D vector through a matrix."],[3,"row_mat4_transform","","Transforms a 4D vector through a matrix."],[3,"row_mat2x3_transform_pos2","","Transforms a 2D position through matrix."],[3,"col_mat3x2_transform_pos2","","Transforms a 2D position through matrix."],[3,"row_mat3_transform_pos2","","Transforms a 2D position through row matrix."],[3,"col_mat3_transform_pos2","","Transforms a 2D position through column matrix."],[3,"row_mat3x4_transform_pos3","","Transforms a 3D position through matrix."],[3,"col_mat4x3_transform_pos3","","Transforms a 3D position through matrix."],[3,"row_mat2x3_transform_vec2","","Transforms a 2D vector through matrix."],[3,"col_mat3x2_transform_vec2","","Transforms a 2D vector through matrix."],[3,"row_mat3_transform_vec2","","Transforms a 2D vector through row matrix."],[3,"col_mat3_transform_vec2","","Transforms a 2D vector through column matrix."],[3,"row_mat3x4_transform_vec3","","Transforms a 3D vector through matrix."],[3,"col_mat4x3_transform_vec3","","Transforms a 3D vector through matrix."],[3,"mat2x3_det","","Computes the determinant of a matrix."],[3,"mat3x2_det","","Computes the determinant of a matrix."],[3,"mat3_det","","Computes the determinant of a matrix."],[3,"mat3x4_det","","Computes the determinant of a matrix."],[3,"mat4x3_det","","Computes the determinant of a matrix."],[3,"mat4_det","","Computes the determinant of a 4x4 matrix."],[3,"mat2x3_inv_det","","Computes inverse determinant of a 2x3 matrix."],[3,"mat3x2_inv_det","","Computes inverse determinant of a 3x2 matrix."],[3,"mat3_inv_det","","Computes inverse determinant of a 3x3 matrix."],[3,"mat3x4_inv_det","","Computes inverse determinant of a 3x4 matrix."],[3,"mat4x3_inv_det","","Computes inverse determinant of a 4x3 matrix."],[3,"mat4_inv_det","","Computes the inverse determinant of a 4x4 matrix."],[3,"mat2x3_inv","","Computes the inverse of a 2x3 matrix."],[3,"mat3x2_inv","","Computes the inverse of a 3x2 matrix."],[3,"mat3_inv","","Computes the inverse of a 3x3 matrix."],[3,"mat3x4_inv","","Computes the inverse of a 3x4 matrix."],[3,"mat4x3_inv","","Computes the inverse of a 4x3 matrix."],[3,"mat4_inv","","Computes the inverse of a 4x4 matrix."],[0,"input","piston",""],[0,"keyboard","piston::input","Back-end agnostic keyboard keys."],[10,"code","input::keyboard","Returns an id of the key",87],[10,"fmt","","",87],[10,"clone","","",87],[10,"clone_from","","",87],[10,"eq","","",87],[10,"ne","","",87],[10,"assert_receiver_is_total_eq","","",87],[10,"partial_cmp","","",87],[10,"lt","","",87],[10,"le","","",87],[10,"gt","","",87],[10,"ge","","",87],[10,"cmp","","",87],[10,"hash","","",87],[10,"to_i64","","",87],[10,"to_u64","","",87],[10,"to_int","","",87],[10,"to_int","","",87],[10,"to_i8","","",87],[10,"to_i16","","",87],[10,"to_i32","","",87],[10,"to_uint","","",87],[10,"to_u8","","",87],[10,"to_u16","","",87],[10,"to_u32","","",87],[10,"to_f32","","",87],[10,"to_f64","","",87],[10,"from_u64","","",87],[10,"from_i64","","",87],[10,"from_int","","",87],[10,"from_int","","",87],[10,"from_i8","","",87],[10,"from_i16","","",87],[10,"from_i32","","",87],[10,"from_uint","","",87],[10,"from_u8","","",87],[10,"from_u16","","",87],[10,"from_u32","","",87],[10,"from_f32","","",87],[10,"from_f64","","",87],[10,"fmt","input::mouse","",88],[10,"hash","","",88],[10,"partial_cmp","","",88],[10,"lt","","",88],[10,"le","","",88],[10,"gt","","",88],[10,"ge","","",88],[10,"lt","","",88],[10,"le","","",88],[10,"gt","","",88],[10,"ge","","",88],[10,"cmp","","",88],[10,"assert_receiver_is_total_eq","","",88],[10,"eq","","",88],[10,"ne","","",88],[10,"ne","","",88],[10,"clone","","",88],[10,"clone_from","","",88],[10,"clone","input","",89],[10,"clone_from","","",89],[2,"Key","piston::input::keyboard","Represent a keyboard key."],[12,"Unknown","","",87],[12,"Backspace","","",87],[12,"Tab","","",87],[12,"Return","","",87],[12,"Escape","","",87],[12,"Space","","",87],[12,"Exclaim","","",87],[12,"Quotedbl","","",87],[12,"Hash","","",87],[12,"Dollar","","",87],[12,"Percent","","",87],[12,"Ampersand","","",87],[12,"Quote","","",87],[12,"LeftParen","","",87],[12,"RightParen","","",87],[12,"Asterisk","","",87],[12,"Plus","","",87],[12,"Comma","","",87],[12,"Minus","","",87],[12,"Period","","",87],[12,"Slash","","",87],[12,"D0","","",87],[12,"D1","","",87],[12,"D2","","",87],[12,"D3","","",87],[12,"D4","","",87],[12,"D5","","",87],[12,"D6","","",87],[12,"D7","","",87],[12,"D8","","",87],[12,"D9","","",87],[12,"Colon","","",87],[12,"Semicolon","","",87],[12,"Less","","",87],[12,"Equals","","",87],[12,"Greater","","",87],[12,"Question","","",87],[12,"At","","",87],[12,"LeftBracket","","",87],[12,"Backslash","","",87],[12,"RightBracket","","",87],[12,"Caret","","",87],[12,"Underscore","","",87],[12,"Backquote","","",87],[12,"A","","",87],[12,"B","","",87],[12,"C","","",87],[12,"D","","",87],[12,"E","","",87],[12,"F","","",87],[12,"G","","",87],[12,"H","","",87],[12,"I","","",87],[12,"J","","",87],[12,"K","","",87],[12,"L","","",87],[12,"M","","",87],[12,"N","","",87],[12,"O","","",87],[12,"P","","",87],[12,"Q","","",87],[12,"R","","",87],[12,"S","","",87],[12,"T","","",87],[12,"U","","",87],[12,"V","","",87],[12,"W","","",87],[12,"X","","",87],[12,"Y","","",87],[12,"Z","","",87],[12,"Delete","","",87],[12,"CapsLock","","",87],[12,"F1","","",87],[12,"F2","","",87],[12,"F3","","",87],[12,"F4","","",87],[12,"F5","","",87],[12,"F6","","",87],[12,"F7","","",87],[12,"F8","","",87],[12,"F9","","",87],[12,"F10","","",87],[12,"F11","","",87],[12,"F12","","",87],[12,"PrintScreen","","",87],[12,"ScrollLock","","",87],[12,"Pause","","",87],[12,"Insert","","",87],[12,"Home","","",87],[12,"PageUp","","",87],[12,"End","","",87],[12,"PageDown","","",87],[12,"Right","","",87],[12,"Left","","",87],[12,"Down","","",87],[12,"Up","","",87],[12,"NumLockClear","","",87],[12,"NumPadDivide","","",87],[12,"NumPadMultiply","","",87],[12,"NumPadMinus","","",87],[12,"NumPadPlus","","",87],[12,"NumPadEnter","","",87],[12,"NumPad1","","",87],[12,"NumPad2","","",87],[12,"NumPad3","","",87],[12,"NumPad4","","",87],[12,"NumPad5","","",87],[12,"NumPad6","","",87],[12,"NumPad7","","",87],[12,"NumPad8","","",87],[12,"NumPad9","","",87],[12,"NumPad0","","",87],[12,"NumPadPeriod","","",87],[12,"Application","","",87],[12,"Power","","",87],[12,"NumPadEquals","","",87],[12,"F13","","",87],[12,"F14","","",87],[12,"F15","","",87],[12,"F16","","",87],[12,"F17","","",87],[12,"F18","","",87],[12,"F19","","",87],[12,"F20","","",87],[12,"F21","","",87],[12,"F22","","",87],[12,"F23","","",87],[12,"F24","","",87],[12,"Execute","","",87],[12,"Help","","",87],[12,"Menu","","",87],[12,"Select","","",87],[12,"Stop","","",87],[12,"Again","","",87],[12,"Undo","","",87],[12,"Cut","","",87],[12,"Copy","","",87],[12,"Paste","","",87],[12,"Find","","",87],[12,"Mute","","",87],[12,"VolumeUp","","",87],[12,"VolumeDown","","",87],[12,"NumPadComma","","",87],[12,"NumPadEqualsAS400","","",87],[12,"AltErase","","",87],[12,"Sysreq","","",87],[12,"Cancel","","",87],[12,"Clear","","",87],[12,"Prior","","",87],[12,"Return2","","",87],[12,"Separator","","",87],[12,"Out","","",87],[12,"Oper","","",87],[12,"ClearAgain","","",87],[12,"CrSel","","",87],[12,"ExSel","","",87],[12,"NumPad00","","",87],[12,"NumPad000","","",87],[12,"ThousandsSeparator","","",87],[12,"DecimalSeparator","","",87],[12,"CurrencyUnit","","",87],[12,"CurrencySubUnit","","",87],[12,"NumPadLeftParen","","",87],[12,"NumPadRightParen","","",87],[12,"NumPadLeftBrace","","",87],[12,"NumPadRightBrace","","",87],[12,"NumPadTab","","",87],[12,"NumPadBackspace","","",87],[12,"NumPadA","","",87],[12,"NumPadB","","",87],[12,"NumPadC","","",87],[12,"NumPadD","","",87],[12,"NumPadE","","",87],[12,"NumPadF","","",87],[12,"NumPadXor","","",87],[12,"NumPadPower","","",87],[12,"NumPadPercent","","",87],[12,"NumPadLess","","",87],[12,"NumPadGreater","","",87],[12,"NumPadAmpersand","","",87],[12,"NumPadDblAmpersand","","",87],[12,"NumPadVerticalBar","","",87],[12,"NumPadDblVerticalBar","","",87],[12,"NumPadColon","","",87],[12,"NumPadHash","","",87],[12,"NumPadSpace","","",87],[12,"NumPadAt","","",87],[12,"NumPadExclam","","",87],[12,"NumPadMemStore","","",87],[12,"NumPadMemRecall","","",87],[12,"NumPadMemClear","","",87],[12,"NumPadMemAdd","","",87],[12,"NumPadMemSubtract","","",87],[12,"NumPadMemMultiply","","",87],[12,"NumPadMemDivide","","",87],[12,"NumPadPlusMinus","","",87],[12,"NumPadClear","","",87],[12,"NumPadClearEntry","","",87],[12,"NumPadBinary","","",87],[12,"NumPadOctal","","",87],[12,"NumPadDecimal","","",87],[12,"NumPadHexadecimal","","",87],[12,"LCtrl","","",87],[12,"LShift","","",87],[12,"LAlt","","",87],[12,"LGui","","",87],[12,"RCtrl","","",87],[12,"RShift","","",87],[12,"RAlt","","",87],[12,"RGui","","",87],[12,"Mode","","",87],[12,"AudioNext","","",87],[12,"AudioPrev","","",87],[12,"AudioStop","","",87],[12,"AudioPlay","","",87],[12,"AudioMute","","",87],[12,"MediaSelect","","",87],[12,"Www","","",87],[12,"Mail","","",87],[12,"Calculator","","",87],[12,"Computer","","",87],[12,"AcSearch","","",87],[12,"AcHome","","",87],[12,"AcBack","","",87],[12,"AcForward","","",87],[12,"AcStop","","",87],[12,"AcRefresh","","",87],[12,"AcBookmarks","","",87],[12,"BrightnessDown","","",87],[12,"BrightnessUp","","",87],[12,"DisplaySwitch","","",87],[12,"KbdIllumToggle","","",87],[12,"KbdIllumDown","","",87],[12,"KbdIllumUp","","",87],[12,"Eject","","",87],[12,"Sleep","","",87],[0,"mouse","piston::input","Back-end agnostic mouse buttons."],[2,"Button","piston::input::mouse","Represent a mouse button."],[12,"Unknown","","Unknown mouse button.",88],[12,"Left","","Left mouse button.",88],[12,"Right","","Right mouse button.",88],[12,"Middle","","Middle mouse button.",88],[12,"X1","","Extra mouse button number 1.",88],[12,"X2","","Extra mouse button number 2.",88],[12,"Button6","","Mouse button number 6.",88],[12,"Button7","","Mouse button number 7.",88],[12,"Button8","","Mouse button number 8.",88],[2,"InputEvent","piston::input","Models input events."],[12,"KeyPress","","Pressed a keyboard key.",89],[12,"KeyRelease","","Released a keyboard key.",89],[12,"MousePress","","Pressed a mouse button.",89],[12,"MouseRelease","","Released a mouse button.",89],[12,"MouseMove","","Moved mouse cursor.",89],[12,"MouseRelativeMove","","Moved mouse relative, not bounded by cursor.",89],[12,"MouseScroll","","Scrolled mouse.",89],[0,"cam","piston",""],[10,"new","cam::first_person","Creates a new first person camera.",90],[10,"camera","","Computes camera.",90],[10,"update","","Updates the position.",90],[10,"input","","Handles game event and updates camera.",90],[10,"new","cam::camera","Constructs a new camera.",91],[10,"orthogonal","","Computes an orthogonal matrix for the camera.",91],[10,"look_at","","Orients the camera to look at a point.",91],[10,"set_yaw_pitch","","Sets yaw and pitch angle of camera in radians.",91],[10,"projection","","Computes a projection matrix for the camera perspective.",92],[10,"hash","cam::first_person","",93],[10,"cmp","","",93],[10,"partial_cmp","","",93],[10,"lt","","",93],[10,"le","","",93],[10,"gt","","",93],[10,"ge","","",93],[10,"lt","","",93],[10,"le","","",93],[10,"gt","","",93],[10,"ge","","",93],[10,"clone","","",93],[10,"clone_from","","",93],[10,"assert_receiver_is_total_eq","","",93],[10,"eq","","",93],[10,"ne","","",93],[10,"ne","","",93],[10,"empty","","Returns an empty set of flags.",93],[10,"all","","Returns the set containing all flags.",93],[10,"bits","","Returns the raw value of the flags currently stored.",93],[10,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",93],[10,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",93],[10,"is_empty","","Returns `true` if no flags are currently stored.",93],[10,"is_all","","Returns `true` if all flags are currently set.",93],[10,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",93],[10,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",93],[10,"insert","","Inserts the specified flags in-place.",93],[10,"remove","","Removes the specified flags in-place.",93],[10,"bitor","","Returns the union of the two sets of flags.",93],[10,"bitand","","Returns the intersection between the two sets of flags.",93],[10,"sub","","Returns the set difference of the two sets of flags.",93],[10,"not","","Returns the complement of this set of flags.",93],[10,"default","","Creates new first person camera settings with defaults.",94],[1,"FirstPerson","piston::cam","Models a flying first person camera."],[11,"settings","","The first person camera settings.",90],[11,"yaw","","The yaw angle (in radians).",90],[11,"pitch","","The pitch angle (in radians).",90],[11,"direction","","The direction we are heading.",90],[11,"position","","The position of the camera.",90],[11,"velocity","","The velocity we are moving in the direction.",90],[3,"model_view_projection","","Computes a model view projection matrix."],[1,"CameraPerspective","","Models camera perspective settings."],[11,"fov","","Field of view (in degrees).",92],[11,"near_clip","","The near clip distance.",92],[11,"far_clip","","The far clip distance.",92],[11,"aspect_ratio","","The aspect ratio, usually set to 1.0.",92],[1,"FirstPersonSettings","","First person camera settings."],[11,"move_forward_key","","Which key to press to move forward.",94],[11,"move_backward_key","","Which key to press to move backward.",94],[11,"strafe_left_key","","Which key to press to strafe left.",94],[11,"strafe_right_key","","Which key to press to strafe right.",94],[11,"fly_up_key","","Which key to press to fly up.",94],[11,"fly_down_key","","Which key to press to fly down.",94],[11,"move_faster_key","","Which key to press to move faster.",94],[11,"speed_horizontal","","The horizontal movement speed.",94],[11,"speed_vertical","","The vertical movement speed.",94],[1,"Camera","","Models a camera with position and directions."],[11,"position","","The camera position.",91],[11,"up","","The up direction.",91],[11,"right","","The right direction.",91],[11,"forward","","The forward direction.",91],[0,"gfx","piston",""],[0,"attrib","piston::gfx","Vertex attribute types."],[10,"fmt","device::attrib","",95],[10,"clone","","",95],[10,"clone_from","","",95],[10,"hash","","",95],[10,"partial_cmp","","",95],[10,"lt","","",95],[10,"le","","",95],[10,"gt","","",95],[10,"ge","","",95],[10,"lt","","",95],[10,"le","","",95],[10,"gt","","",95],[10,"ge","","",95],[10,"eq","","",95],[10,"ne","","",95],[10,"ne","","",95],[10,"cmp","","",95],[10,"assert_receiver_is_total_eq","","",95],[10,"fmt","","",96],[10,"clone","","",96],[10,"clone_from","","",96],[10,"hash","","",96],[10,"partial_cmp","","",96],[10,"lt","","",96],[10,"le","","",96],[10,"gt","","",96],[10,"ge","","",96],[10,"lt","","",96],[10,"le","","",96],[10,"gt","","",96],[10,"ge","","",96],[10,"eq","","",96],[10,"ne","","",96],[10,"ne","","",96],[10,"cmp","","",96],[10,"assert_receiver_is_total_eq","","",96],[10,"fmt","","",97],[10,"clone","","",97],[10,"clone_from","","",97],[10,"hash","","",97],[10,"partial_cmp","","",97],[10,"lt","","",97],[10,"le","","",97],[10,"gt","","",97],[10,"ge","","",97],[10,"lt","","",97],[10,"le","","",97],[10,"gt","","",97],[10,"ge","","",97],[10,"eq","","",97],[10,"ne","","",97],[10,"ne","","",97],[10,"cmp","","",97],[10,"assert_receiver_is_total_eq","","",97],[10,"fmt","","",98],[10,"clone","","",98],[10,"clone_from","","",98],[10,"hash","","",98],[10,"partial_cmp","","",98],[10,"lt","","",98],[10,"le","","",98],[10,"gt","","",98],[10,"ge","","",98],[10,"lt","","",98],[10,"le","","",98],[10,"gt","","",98],[10,"ge","","",98],[10,"eq","","",98],[10,"ne","","",98],[10,"ne","","",98],[10,"cmp","","",98],[10,"assert_receiver_is_total_eq","","",98],[10,"fmt","","",99],[10,"clone","","",99],[10,"clone_from","","",99],[10,"hash","","",99],[10,"partial_cmp","","",99],[10,"lt","","",99],[10,"le","","",99],[10,"gt","","",99],[10,"ge","","",99],[10,"lt","","",99],[10,"le","","",99],[10,"gt","","",99],[10,"ge","","",99],[10,"eq","","",99],[10,"ne","","",99],[10,"ne","","",99],[10,"cmp","","",99],[10,"assert_receiver_is_total_eq","","",99],[10,"fmt","","",100],[10,"clone","","",100],[10,"clone_from","","",100],[10,"hash","","",100],[10,"partial_cmp","","",100],[10,"lt","","",100],[10,"le","","",100],[10,"gt","","",100],[10,"ge","","",100],[10,"lt","","",100],[10,"le","","",100],[10,"gt","","",100],[10,"ge","","",100],[10,"eq","","",100],[10,"ne","","",100],[10,"ne","","",100],[10,"cmp","","",100],[10,"assert_receiver_is_total_eq","","",100],[10,"is_compatible","","",100],[10,"fmt","device::shade","",101],[10,"eq","","",101],[10,"ne","","",101],[10,"ne","","",101],[10,"clone","","",101],[10,"clone_from","","",101],[10,"fmt","","",102],[10,"eq","","",102],[10,"ne","","",102],[10,"ne","","",102],[10,"clone","","",102],[10,"clone_from","","",102],[10,"fmt","","",103],[10,"eq","","",103],[10,"ne","","",103],[10,"ne","","",103],[10,"clone","","",103],[10,"clone_from","","",103],[10,"fmt","","",104],[10,"eq","","",104],[10,"ne","","",104],[10,"ne","","",104],[10,"clone","","",104],[10,"clone_from","","",104],[10,"fmt","","",105],[10,"eq","","",105],[10,"ne","","",105],[10,"ne","","",105],[10,"clone","","",105],[10,"clone_from","","",105],[10,"fmt","","",106],[10,"eq","","",106],[10,"ne","","",106],[10,"ne","","",106],[10,"clone","","",106],[10,"clone_from","","",106],[10,"fmt","","",107],[10,"eq","","",107],[10,"ne","","",107],[10,"ne","","",107],[10,"clone","","",107],[10,"clone_from","","",107],[10,"fmt","","",108],[10,"eq","","",108],[10,"ne","","",108],[10,"ne","","",108],[10,"clone","","",108],[10,"clone_from","","",108],[10,"fmt","","",109],[10,"is_same_type","","Whether two `UniformValue`s have the same type.",110],[10,"clone","","",110],[10,"clone_from","","",110],[10,"fmt","","",110],[10,"fmt","","",111],[10,"clone","","",111],[10,"clone_from","","",111],[10,"fmt","","",112],[10,"clone","","",112],[10,"clone_from","","",112],[10,"fmt","","",113],[10,"clone","","",113],[10,"clone_from","","",113],[10,"fmt","","",114],[10,"clone","","",114],[10,"clone_from","","",114],[10,"fmt","","",115],[10,"clone","","",115],[10,"clone_from","","",115],[10,"fmt","","",116],[10,"is_compatible","","Whether a value is compatible with this variable. That is, whether the value can be stored\nin this variable.",112],[10,"clone","","",117],[10,"clone_from","","",117],[10,"eq","","",117],[10,"ne","","",117],[10,"ne","","",117],[10,"fmt","","",117],[10,"as_slice","","Get the byte data as a slice.",117],[10,"fmt","","",118],[10,"eq","","",118],[10,"ne","","",118],[10,"ne","","",118],[10,"clone","","",118],[10,"clone_from","","",118],[10,"fmt","","",119],[10,"eq","","",119],[10,"ne","","",119],[10,"ne","","",119],[10,"clone","","",119],[10,"clone_from","","",119],[10,"fmt","","",120],[10,"partial_cmp","","",120],[10,"lt","","",120],[10,"le","","",120],[10,"gt","","",120],[10,"ge","","",120],[10,"lt","","",120],[10,"le","","",120],[10,"gt","","",120],[10,"ge","","",120],[10,"eq","","",120],[10,"ne","","",120],[10,"ne","","",120],[10,"clone","","",120],[10,"clone_from","","",120],[10,"to_number","","Return the shader model as a numeric value.",120],[10,"fmt","device::state","",121],[10,"eq","","",121],[10,"ne","","",121],[10,"ne","","",121],[10,"clone","","",121],[10,"clone_from","","",121],[10,"fmt","","",122],[10,"eq","","",122],[10,"ne","","",122],[10,"ne","","",122],[10,"clone","","",122],[10,"clone_from","","",122],[10,"fmt","","",123],[10,"eq","","",123],[10,"ne","","",123],[10,"ne","","",123],[10,"clone","","",123],[10,"clone_from","","",123],[10,"fmt","","",124],[10,"eq","","",124],[10,"ne","","",124],[10,"ne","","",124],[10,"clone","","",124],[10,"clone_from","","",124],[10,"fmt","","",125],[10,"eq","","",125],[10,"ne","","",125],[10,"ne","","",125],[10,"clone","","",125],[10,"clone_from","","",125],[10,"get_cull_mode","","Get the cull mode, if any, for this primitive state.",125],[10,"default","","",125],[10,"fmt","","",126],[10,"eq","","",126],[10,"ne","","",126],[10,"ne","","",126],[10,"clone","","",126],[10,"clone_from","","",126],[10,"fmt","","",127],[10,"eq","","",127],[10,"ne","","",127],[10,"ne","","",127],[10,"clone","","",127],[10,"clone_from","","",127],[10,"fmt","","",128],[10,"eq","","",128],[10,"ne","","",128],[10,"ne","","",128],[10,"clone","","",128],[10,"clone_from","","",128],[10,"default","","",128],[10,"fmt","","",129],[10,"eq","","",129],[10,"ne","","",129],[10,"ne","","",129],[10,"clone","","",129],[10,"clone_from","","",129],[10,"fmt","","",130],[10,"eq","","",130],[10,"ne","","",130],[10,"ne","","",130],[10,"clone","","",130],[10,"clone_from","","",130],[10,"default","","",130],[10,"fmt","","",131],[10,"eq","","",131],[10,"ne","","",131],[10,"ne","","",131],[10,"clone","","",131],[10,"clone_from","","",131],[10,"fmt","","",132],[10,"eq","","",132],[10,"ne","","",132],[10,"ne","","",132],[10,"clone","","",132],[10,"clone_from","","",132],[10,"fmt","","",133],[10,"eq","","",133],[10,"ne","","",133],[10,"ne","","",133],[10,"clone","","",133],[10,"clone_from","","",133],[10,"fmt","","",134],[10,"eq","","",134],[10,"ne","","",134],[10,"ne","","",134],[10,"clone","","",134],[10,"clone_from","","",134],[10,"fmt","","",135],[10,"eq","","",135],[10,"ne","","",135],[10,"ne","","",135],[10,"clone","","",135],[10,"clone_from","","",135],[10,"default","","",135],[10,"default","","",136],[10,"eq","","",136],[10,"ne","","",136],[10,"clone","","",136],[10,"clone_from","","",136],[10,"fmt","","",136],[10,"hash","","",137],[10,"cmp","","",137],[10,"partial_cmp","","",137],[10,"lt","","",137],[10,"le","","",137],[10,"gt","","",137],[10,"ge","","",137],[10,"lt","","",137],[10,"le","","",137],[10,"gt","","",137],[10,"ge","","",137],[10,"clone","","",137],[10,"clone_from","","",137],[10,"assert_receiver_is_total_eq","","",137],[10,"eq","","",137],[10,"ne","","",137],[10,"ne","","",137],[10,"empty","","Returns an empty set of flags.",137],[10,"all","","Returns the set containing all flags.",137],[10,"bits","","Returns the raw value of the flags currently stored.",137],[10,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",137],[10,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",137],[10,"is_empty","","Returns `true` if no flags are currently stored.",137],[10,"is_all","","Returns `true` if all flags are currently set.",137],[10,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",137],[10,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",137],[10,"insert","","Inserts the specified flags in-place.",137],[10,"remove","","Removes the specified flags in-place.",137],[10,"bitor","","Returns the union of the two sets of flags.",137],[10,"bitand","","Returns the intersection between the two sets of flags.",137],[10,"sub","","Returns the set difference of the two sets of flags.",137],[10,"not","","Returns the complement of this set of flags.",137],[10,"fmt","","",137],[10,"fmt","device::target","",138],[10,"eq","","",138],[10,"ne","","",138],[10,"ne","","",138],[10,"clone","","",138],[10,"clone_from","","",138],[10,"clone","","",139],[10,"clone_from","","",139],[10,"fmt","","",139],[10,"fmt","","",140],[10,"clone","","",140],[10,"clone_from","","",140],[10,"fmt","device::tex","",141],[10,"eq","","",141],[10,"ne","","",141],[10,"ne","","",141],[10,"clone","","",141],[10,"clone_from","","",141],[10,"fmt","","",142],[10,"eq","","",142],[10,"ne","","",142],[10,"ne","","",142],[10,"clone","","",142],[10,"clone_from","","",142],[10,"fmt","","",143],[10,"clone","","",143],[10,"clone_from","","",143],[10,"hash","","",143],[10,"partial_cmp","","",143],[10,"lt","","",143],[10,"le","","",143],[10,"gt","","",143],[10,"ge","","",143],[10,"lt","","",143],[10,"le","","",143],[10,"gt","","",143],[10,"ge","","",143],[10,"eq","","",143],[10,"ne","","",143],[10,"ne","","",143],[10,"cmp","","",143],[10,"assert_receiver_is_total_eq","","",143],[10,"fmt","","",144],[10,"clone","","",144],[10,"clone_from","","",144],[10,"hash","","",144],[10,"partial_cmp","","",144],[10,"lt","","",144],[10,"le","","",144],[10,"gt","","",144],[10,"ge","","",144],[10,"lt","","",144],[10,"le","","",144],[10,"gt","","",144],[10,"ge","","",144],[10,"eq","","",144],[10,"ne","","",144],[10,"ne","","",144],[10,"cmp","","",144],[10,"assert_receiver_is_total_eq","","",144],[10,"fmt","","",145],[10,"clone","","",145],[10,"clone_from","","",145],[10,"hash","","",145],[10,"partial_cmp","","",145],[10,"lt","","",145],[10,"le","","",145],[10,"gt","","",145],[10,"ge","","",145],[10,"lt","","",145],[10,"le","","",145],[10,"gt","","",145],[10,"ge","","",145],[10,"eq","","",145],[10,"ne","","",145],[10,"ne","","",145],[10,"cmp","","",145],[10,"assert_receiver_is_total_eq","","",145],[10,"fmt","","",146],[10,"clone","","",146],[10,"clone_from","","",146],[10,"hash","","",146],[10,"partial_cmp","","",146],[10,"lt","","",146],[10,"le","","",146],[10,"gt","","",146],[10,"ge","","",146],[10,"lt","","",146],[10,"le","","",146],[10,"gt","","",146],[10,"ge","","",146],[10,"eq","","",146],[10,"ne","","",146],[10,"ne","","",146],[10,"cmp","","",146],[10,"assert_receiver_is_total_eq","","",146],[10,"fmt","","",147],[10,"clone","","",147],[10,"clone_from","","",147],[10,"hash","","",147],[10,"partial_cmp","","",147],[10,"lt","","",147],[10,"le","","",147],[10,"gt","","",147],[10,"ge","","",147],[10,"lt","","",147],[10,"le","","",147],[10,"gt","","",147],[10,"ge","","",147],[10,"eq","","",147],[10,"ne","","",147],[10,"ne","","",147],[10,"cmp","","",147],[10,"assert_receiver_is_total_eq","","",147],[10,"fmt","","",148],[10,"clone","","",148],[10,"clone_from","","",148],[10,"hash","","",148],[10,"partial_cmp","","",148],[10,"lt","","",148],[10,"le","","",148],[10,"gt","","",148],[10,"ge","","",148],[10,"lt","","",148],[10,"le","","",148],[10,"gt","","",148],[10,"ge","","",148],[10,"eq","","",148],[10,"ne","","",148],[10,"ne","","",148],[10,"cmp","","",148],[10,"assert_receiver_is_total_eq","","",148],[10,"fmt","","",149],[10,"clone","","",149],[10,"clone_from","","",149],[10,"hash","","",149],[10,"partial_cmp","","",149],[10,"lt","","",149],[10,"le","","",149],[10,"gt","","",149],[10,"ge","","",149],[10,"lt","","",149],[10,"le","","",149],[10,"gt","","",149],[10,"ge","","",149],[10,"eq","","",149],[10,"ne","","",149],[10,"ne","","",149],[10,"cmp","","",149],[10,"assert_receiver_is_total_eq","","",149],[10,"default","","",149],[10,"default","","",148],[10,"new","","Create a new empty texture info",148],[10,"to_image_info","","Convert to a default ImageInfo that could be used\nto update the contents of the whole texture",148],[10,"contains","","Check if given ImageInfo is a part of the texture",148],[10,"new","","Create a new `ImageInfo`, using default values.",149],[10,"fmt","","",150],[10,"clone","","",150],[10,"clone_from","","",150],[10,"hash","","",150],[10,"partial_cmp","","",150],[10,"lt","","",150],[10,"le","","",150],[10,"gt","","",150],[10,"ge","","",150],[10,"lt","","",150],[10,"le","","",150],[10,"gt","","",150],[10,"ge","","",150],[10,"eq","","",150],[10,"ne","","",150],[10,"ne","","",150],[10,"cmp","","",150],[10,"assert_receiver_is_total_eq","","",150],[10,"fmt","","",151],[10,"clone","","",151],[10,"clone_from","","",151],[10,"partial_cmp","","",151],[10,"lt","","",151],[10,"le","","",151],[10,"gt","","",151],[10,"ge","","",151],[10,"lt","","",151],[10,"le","","",151],[10,"gt","","",151],[10,"ge","","",151],[10,"eq","","",151],[10,"ne","","",151],[10,"ne","","",151],[10,"new","","Create a new sampler description with a given filter method and wrapping mode, using no LOD\nmodifications.",151],[10,"iter","device::gl::draw","",152],[10,"new","","",152],[10,"clear","","",152],[10,"bind_program","","",152],[10,"bind_array_buffer","","",152],[10,"bind_attribute","","",152],[10,"bind_index","","",152],[10,"bind_frame_buffer","","",152],[10,"unbind_target","","",152],[10,"bind_target_surface","","",152],[10,"bind_target_texture","","",152],[10,"bind_uniform_block","","",152],[10,"bind_uniform","","",152],[10,"bind_texture","","",152],[10,"set_primitive","","",152],[10,"set_viewport","","",152],[10,"set_scissor","","",152],[10,"set_depth_stencil","","",152],[10,"set_blend","","",152],[10,"set_color_mask","","",152],[10,"update_buffer","","",152],[10,"update_texture","","",152],[10,"call_clear","","",152],[10,"call_draw","","",152],[10,"call_draw_indexed","","",152],[10,"partial_cmp","device::gl::info","",153],[10,"lt","","",153],[10,"le","","",153],[10,"gt","","",153],[10,"ge","","",153],[10,"lt","","",153],[10,"le","","",153],[10,"gt","","",153],[10,"ge","","",153],[10,"cmp","","",153],[10,"eq","","",153],[10,"ne","","",153],[10,"ne","","",153],[10,"assert_receiver_is_total_eq","","",153],[10,"new","","Create a new OpenGL version number",153],[10,"parse","","According to the OpenGL specification, the version information is\nexpected to follow the following syntax:",153],[10,"fmt","","",153],[10,"fmt","","",154],[10,"eq","","",154],[10,"ne","","",154],[10,"ne","","",154],[10,"assert_receiver_is_total_eq","","",154],[10,"fmt","","",155],[10,"is_extension_supported","","Returns `true` if the implementation supports the extension",155],[10,"is_loaded","device::gl::gl","",156],[10,"load_with","","Load each OpenGL symbol using a custom load function. This allows for the\nuse of functions like `glfwGetProcAddress` or `SDL_GL_GetProcAddress`.",157],[10,"ActiveShaderProgram","","",157],[10,"ActiveTexture","","",157],[10,"AttachShader","","",157],[10,"BeginConditionalRender","","",157],[10,"BeginQuery","","",157],[10,"BeginQueryIndexed","","",157],[10,"BeginTransformFeedback","","",157],[10,"BindAttribLocation","","",157],[10,"BindBuffer","","",157],[10,"BindBufferBase","","",157],[10,"BindBufferRange","","",157],[10,"BindBuffersBase","","",157],[10,"BindBuffersRange","","",157],[10,"BindFragDataLocation","","",157],[10,"BindFragDataLocationIndexed","","",157],[10,"BindFramebuffer","","",157],[10,"BindImageTexture","","",157],[10,"BindImageTextures","","",157],[10,"BindProgramPipeline","","",157],[10,"BindRenderbuffer","","",157],[10,"BindSampler","","",157],[10,"BindSamplers","","",157],[10,"BindTexture","","",157],[10,"BindTextureUnit","","",157],[10,"BindTextures","","",157],[10,"BindTransformFeedback","","",157],[10,"BindVertexArray","","",157],[10,"BindVertexBuffer","","",157],[10,"BindVertexBuffers","","",157],[10,"BlendColor","","",157],[10,"BlendEquation","","",157],[10,"BlendEquationSeparate","","",157],[10,"BlendEquationSeparatei","","",157],[10,"BlendEquationi","","",157],[10,"BlendFunc","","",157],[10,"BlendFuncSeparate","","",157],[10,"BlendFuncSeparatei","","",157],[10,"BlendFunci","","",157],[10,"BlitFramebuffer","","",157],[10,"BlitNamedFramebuffer","","",157],[10,"BufferData","","",157],[10,"BufferStorage","","",157],[10,"BufferSubData","","",157],[10,"CheckFramebufferStatus","","",157],[10,"CheckNamedFramebufferStatus","","",157],[10,"ClampColor","","",157],[10,"Clear","","",157],[10,"ClearBufferData","","",157],[10,"ClearBufferSubData","","",157],[10,"ClearBufferfi","","",157],[10,"ClearBufferfv","","",157],[10,"ClearBufferiv","","",157],[10,"ClearBufferuiv","","",157],[10,"ClearColor","","",157],[10,"ClearDepth","","",157],[10,"ClearDepthf","","",157],[10,"ClearNamedBufferData","","",157],[10,"ClearNamedBufferSubData","","",157],[10,"ClearNamedFramebufferfi","","",157],[10,"ClearNamedFramebufferfv","","",157],[10,"ClearNamedFramebufferiv","","",157],[10,"ClearNamedFramebufferuiv","","",157],[10,"ClearStencil","","",157],[10,"ClearTexImage","","",157],[10,"ClearTexSubImage","","",157],[10,"ClientWaitSync","","",157],[10,"ClipControl","","",157],[10,"ColorMask","","",157],[10,"ColorMaski","","",157],[10,"ColorP3ui","","",157],[10,"ColorP3uiv","","",157],[10,"ColorP4ui","","",157],[10,"ColorP4uiv","","",157],[10,"CompileShader","","",157],[10,"CompressedTexImage1D","","",157],[10,"CompressedTexImage2D","","",157],[10,"CompressedTexImage3D","","",157],[10,"CompressedTexSubImage1D","","",157],[10,"CompressedTexSubImage2D","","",157],[10,"CompressedTexSubImage3D","","",157],[10,"CompressedTextureSubImage1D","","",157],[10,"CompressedTextureSubImage2D","","",157],[10,"CompressedTextureSubImage3D","","",157],[10,"CopyBufferSubData","","",157],[10,"CopyImageSubData","","",157],[10,"CopyNamedBufferSubData","","",157],[10,"CopyTexImage1D","","",157],[10,"CopyTexImage2D","","",157],[10,"CopyTexSubImage1D","","",157],[10,"CopyTexSubImage2D","","",157],[10,"CopyTexSubImage3D","","",157],[10,"CopyTextureSubImage1D","","",157],[10,"CopyTextureSubImage2D","","",157],[10,"CopyTextureSubImage3D","","",157],[10,"CreateBuffers","","",157],[10,"CreateFramebuffers","","",157],[10,"CreateProgram","","",157],[10,"CreateProgramPipelines","","",157],[10,"CreateQueries","","",157],[10,"CreateRenderbuffers","","",157],[10,"CreateSamplers","","",157],[10,"CreateShader","","",157],[10,"CreateShaderProgramv","","",157],[10,"CreateTextures","","",157],[10,"CreateTransformFeedbacks","","",157],[10,"CreateVertexArrays","","",157],[10,"CullFace","","",157],[10,"DebugMessageCallback","","",157],[10,"DebugMessageControl","","",157],[10,"DebugMessageInsert","","",157],[10,"DeleteBuffers","","",157],[10,"DeleteFramebuffers","","",157],[10,"DeleteProgram","","",157],[10,"DeleteProgramPipelines","","",157],[10,"DeleteQueries","","",157],[10,"DeleteRenderbuffers","","",157],[10,"DeleteSamplers","","",157],[10,"DeleteShader","","",157],[10,"DeleteSync","","",157],[10,"DeleteTextures","","",157],[10,"DeleteTransformFeedbacks","","",157],[10,"DeleteVertexArrays","","",157],[10,"DepthFunc","","",157],[10,"DepthMask","","",157],[10,"DepthRange","","",157],[10,"DepthRangeArrayv","","",157],[10,"DepthRangeIndexed","","",157],[10,"DepthRangef","","",157],[10,"DetachShader","","",157],[10,"Disable","","",157],[10,"DisableVertexArrayAttrib","","",157],[10,"DisableVertexAttribArray","","",157],[10,"Disablei","","",157],[10,"DispatchCompute","","",157],[10,"DispatchComputeIndirect","","",157],[10,"DrawArrays","","",157],[10,"DrawArraysIndirect","","",157],[10,"DrawArraysInstanced","","",157],[10,"DrawArraysInstancedBaseInstance","","",157],[10,"DrawBuffer","","",157],[10,"DrawBuffers","","",157],[10,"DrawElements","","",157],[10,"DrawElementsBaseVertex","","",157],[10,"DrawElementsIndirect","","",157],[10,"DrawElementsInstanced","","",157],[10,"DrawElementsInstancedBaseInstance","","",157],[10,"DrawElementsInstancedBaseVertex","","",157],[10,"DrawElementsInstancedBaseVertexBaseInstance","","",157],[10,"DrawRangeElements","","",157],[10,"DrawRangeElementsBaseVertex","","",157],[10,"DrawTransformFeedback","","",157],[10,"DrawTransformFeedbackInstanced","","",157],[10,"DrawTransformFeedbackStream","","",157],[10,"DrawTransformFeedbackStreamInstanced","","",157],[10,"Enable","","",157],[10,"EnableVertexArrayAttrib","","",157],[10,"EnableVertexAttribArray","","",157],[10,"Enablei","","",157],[10,"EndConditionalRender","","",157],[10,"EndQuery","","",157],[10,"EndQueryIndexed","","",157],[10,"EndTransformFeedback","","",157],[10,"FenceSync","","",157],[10,"Finish","","",157],[10,"Flush","","",157],[10,"FlushMappedBufferRange","","",157],[10,"FlushMappedNamedBufferRange","","",157],[10,"FramebufferParameteri","","",157],[10,"FramebufferRenderbuffer","","",157],[10,"FramebufferTexture","","",157],[10,"FramebufferTexture1D","","",157],[10,"FramebufferTexture2D","","",157],[10,"FramebufferTexture3D","","",157],[10,"FramebufferTextureLayer","","",157],[10,"FrontFace","","",157],[10,"GenBuffers","","",157],[10,"GenFramebuffers","","",157],[10,"GenProgramPipelines","","",157],[10,"GenQueries","","",157],[10,"GenRenderbuffers","","",157],[10,"GenSamplers","","",157],[10,"GenTextures","","",157],[10,"GenTransformFeedbacks","","",157],[10,"GenVertexArrays","","",157],[10,"GenerateMipmap","","",157],[10,"GenerateTextureMipmap","","",157],[10,"GetActiveAtomicCounterBufferiv","","",157],[10,"GetActiveAttrib","","",157],[10,"GetActiveSubroutineName","","",157],[10,"GetActiveSubroutineUniformName","","",157],[10,"GetActiveSubroutineUniformiv","","",157],[10,"GetActiveUniform","","",157],[10,"GetActiveUniformBlockName","","",157],[10,"GetActiveUniformBlockiv","","",157],[10,"GetActiveUniformName","","",157],[10,"GetActiveUniformsiv","","",157],[10,"GetAttachedShaders","","",157],[10,"GetAttribLocation","","",157],[10,"GetBooleani_v","","",157],[10,"GetBooleanv","","",157],[10,"GetBufferParameteri64v","","",157],[10,"GetBufferParameteriv","","",157],[10,"GetBufferPointerv","","",157],[10,"GetBufferSubData","","",157],[10,"GetCompressedTexImage","","",157],[10,"GetCompressedTextureImage","","",157],[10,"GetCompressedTextureSubImage","","",157],[10,"GetDebugMessageLog","","",157],[10,"GetDoublei_v","","",157],[10,"GetDoublev","","",157],[10,"GetError","","",157],[10,"GetFloati_v","","",157],[10,"GetFloatv","","",157],[10,"GetFragDataIndex","","",157],[10,"GetFragDataLocation","","",157],[10,"GetFramebufferAttachmentParameteriv","","",157],[10,"GetFramebufferParameteriv","","",157],[10,"GetGraphicsResetStatus","","",157],[10,"GetInteger64i_v","","",157],[10,"GetInteger64v","","",157],[10,"GetIntegeri_v","","",157],[10,"GetIntegerv","","",157],[10,"GetInternalformati64v","","",157],[10,"GetInternalformativ","","",157],[10,"GetMultisamplefv","","",157],[10,"GetNamedBufferParameteri64v","","",157],[10,"GetNamedBufferParameteriv","","",157],[10,"GetNamedBufferPointerv","","",157],[10,"GetNamedBufferSubData","","",157],[10,"GetNamedFramebufferAttachmentParameteriv","","",157],[10,"GetNamedFramebufferParameteriv","","",157],[10,"GetNamedRenderbufferParameteriv","","",157],[10,"GetObjectLabel","","",157],[10,"GetObjectPtrLabel","","",157],[10,"GetProgramBinary","","",157],[10,"GetProgramInfoLog","","",157],[10,"GetProgramInterfaceiv","","",157],[10,"GetProgramPipelineInfoLog","","",157],[10,"GetProgramPipelineiv","","",157],[10,"GetProgramResourceIndex","","",157],[10,"GetProgramResourceLocation","","",157],[10,"GetProgramResourceLocationIndex","","",157],[10,"GetProgramResourceName","","",157],[10,"GetProgramResourceiv","","",157],[10,"GetProgramStageiv","","",157],[10,"GetProgramiv","","",157],[10,"GetQueryIndexediv","","",157],[10,"GetQueryObjecti64v","","",157],[10,"GetQueryObjectiv","","",157],[10,"GetQueryObjectui64v","","",157],[10,"GetQueryObjectuiv","","",157],[10,"GetQueryiv","","",157],[10,"GetRenderbufferParameteriv","","",157],[10,"GetSamplerParameterIiv","","",157],[10,"GetSamplerParameterIuiv","","",157],[10,"GetSamplerParameterfv","","",157],[10,"GetSamplerParameteriv","","",157],[10,"GetShaderInfoLog","","",157],[10,"GetShaderPrecisionFormat","","",157],[10,"GetShaderSource","","",157],[10,"GetShaderiv","","",157],[10,"GetString","","",157],[10,"GetStringi","","",157],[10,"GetSubroutineIndex","","",157],[10,"GetSubroutineUniformLocation","","",157],[10,"GetSynciv","","",157],[10,"GetTexImage","","",157],[10,"GetTexLevelParameterfv","","",157],[10,"GetTexLevelParameteriv","","",157],[10,"GetTexParameterIiv","","",157],[10,"GetTexParameterIuiv","","",157],[10,"GetTexParameterfv","","",157],[10,"GetTexParameteriv","","",157],[10,"GetTextureImage","","",157],[10,"GetTextureLevelParameterfv","","",157],[10,"GetTextureLevelParameteriv","","",157],[10,"GetTextureParameterIiv","","",157],[10,"GetTextureParameterIuiv","","",157],[10,"GetTextureParameterfv","","",157],[10,"GetTextureParameteriv","","",157],[10,"GetTextureSubImage","","",157],[10,"GetTransformFeedbackVarying","","",157],[10,"GetTransformFeedbacki64_v","","",157],[10,"GetTransformFeedbacki_v","","",157],[10,"GetTransformFeedbackiv","","",157],[10,"GetUniformBlockIndex","","",157],[10,"GetUniformIndices","","",157],[10,"GetUniformLocation","","",157],[10,"GetUniformSubroutineuiv","","",157],[10,"GetUniformdv","","",157],[10,"GetUniformfv","","",157],[10,"GetUniformiv","","",157],[10,"GetUniformuiv","","",157],[10,"GetVertexArrayIndexed64iv","","",157],[10,"GetVertexArrayIndexediv","","",157],[10,"GetVertexArrayiv","","",157],[10,"GetVertexAttribIiv","","",157],[10,"GetVertexAttribIuiv","","",157],[10,"GetVertexAttribLdv","","",157],[10,"GetVertexAttribPointerv","","",157],[10,"GetVertexAttribdv","","",157],[10,"GetVertexAttribfv","","",157],[10,"GetVertexAttribiv","","",157],[10,"GetnColorTable","","",157],[10,"GetnCompressedTexImage","","",157],[10,"GetnConvolutionFilter","","",157],[10,"GetnHistogram","","",157],[10,"GetnMapdv","","",157],[10,"GetnMapfv","","",157],[10,"GetnMapiv","","",157],[10,"GetnMinmax","","",157],[10,"GetnPixelMapfv","","",157],[10,"GetnPixelMapuiv","","",157],[10,"GetnPixelMapusv","","",157],[10,"GetnPolygonStipple","","",157],[10,"GetnSeparableFilter","","",157],[10,"GetnTexImage","","",157],[10,"GetnUniformdv","","",157],[10,"GetnUniformfv","","",157],[10,"GetnUniformiv","","",157],[10,"GetnUniformuiv","","",157],[10,"Hint","","",157],[10,"InvalidateBufferData","","",157],[10,"InvalidateBufferSubData","","",157],[10,"InvalidateFramebuffer","","",157],[10,"InvalidateNamedFramebufferData","","",157],[10,"InvalidateNamedFramebufferSubData","","",157],[10,"InvalidateSubFramebuffer","","",157],[10,"InvalidateTexImage","","",157],[10,"InvalidateTexSubImage","","",157],[10,"IsBuffer","","",157],[10,"IsEnabled","","",157],[10,"IsEnabledi","","",157],[10,"IsFramebuffer","","",157],[10,"IsProgram","","",157],[10,"IsProgramPipeline","","",157],[10,"IsQuery","","",157],[10,"IsRenderbuffer","","",157],[10,"IsSampler","","",157],[10,"IsShader","","",157],[10,"IsSync","","",157],[10,"IsTexture","","",157],[10,"IsTransformFeedback","","",157],[10,"IsVertexArray","","",157],[10,"LineWidth","","",157],[10,"LinkProgram","","",157],[10,"LogicOp","","",157],[10,"MapBuffer","","",157],[10,"MapBufferRange","","",157],[10,"MapNamedBuffer","","",157],[10,"MapNamedBufferRange","","",157],[10,"MemoryBarrier","","",157],[10,"MemoryBarrierByRegion","","",157],[10,"MinSampleShading","","",157],[10,"MultiDrawArrays","","",157],[10,"MultiDrawArraysIndirect","","",157],[10,"MultiDrawElements","","",157],[10,"MultiDrawElementsBaseVertex","","",157],[10,"MultiDrawElementsIndirect","","",157],[10,"MultiTexCoordP1ui","","",157],[10,"MultiTexCoordP1uiv","","",157],[10,"MultiTexCoordP2ui","","",157],[10,"MultiTexCoordP2uiv","","",157],[10,"MultiTexCoordP3ui","","",157],[10,"MultiTexCoordP3uiv","","",157],[10,"MultiTexCoordP4ui","","",157],[10,"MultiTexCoordP4uiv","","",157],[10,"NamedBufferData","","",157],[10,"NamedBufferStorage","","",157],[10,"NamedBufferSubData","","",157],[10,"NamedFramebufferDrawBuffer","","",157],[10,"NamedFramebufferDrawBuffers","","",157],[10,"NamedFramebufferParameteri","","",157],[10,"NamedFramebufferReadBuffer","","",157],[10,"NamedFramebufferRenderbuffer","","",157],[10,"NamedFramebufferTexture","","",157],[10,"NamedFramebufferTextureLayer","","",157],[10,"NamedRenderbufferStorage","","",157],[10,"NamedRenderbufferStorageMultisample","","",157],[10,"NormalP3ui","","",157],[10,"NormalP3uiv","","",157],[10,"ObjectLabel","","",157],[10,"ObjectPtrLabel","","",157],[10,"PatchParameterfv","","",157],[10,"PatchParameteri","","",157],[10,"PauseTransformFeedback","","",157],[10,"PixelStoref","","",157],[10,"PixelStorei","","",157],[10,"PointParameterf","","",157],[10,"PointParameterfv","","",157],[10,"PointParameteri","","",157],[10,"PointParameteriv","","",157],[10,"PointSize","","",157],[10,"PolygonMode","","",157],[10,"PolygonOffset","","",157],[10,"PopDebugGroup","","",157],[10,"PrimitiveRestartIndex","","",157],[10,"ProgramBinary","","",157],[10,"ProgramParameteri","","",157],[10,"ProgramUniform1d","","",157],[10,"ProgramUniform1dv","","",157],[10,"ProgramUniform1f","","",157],[10,"ProgramUniform1fv","","",157],[10,"ProgramUniform1i","","",157],[10,"ProgramUniform1iv","","",157],[10,"ProgramUniform1ui","","",157],[10,"ProgramUniform1uiv","","",157],[10,"ProgramUniform2d","","",157],[10,"ProgramUniform2dv","","",157],[10,"ProgramUniform2f","","",157],[10,"ProgramUniform2fv","","",157],[10,"ProgramUniform2i","","",157],[10,"ProgramUniform2iv","","",157],[10,"ProgramUniform2ui","","",157],[10,"ProgramUniform2uiv","","",157],[10,"ProgramUniform3d","","",157],[10,"ProgramUniform3dv","","",157],[10,"ProgramUniform3f","","",157],[10,"ProgramUniform3fv","","",157],[10,"ProgramUniform3i","","",157],[10,"ProgramUniform3iv","","",157],[10,"ProgramUniform3ui","","",157],[10,"ProgramUniform3uiv","","",157],[10,"ProgramUniform4d","","",157],[10,"ProgramUniform4dv","","",157],[10,"ProgramUniform4f","","",157],[10,"ProgramUniform4fv","","",157],[10,"ProgramUniform4i","","",157],[10,"ProgramUniform4iv","","",157],[10,"ProgramUniform4ui","","",157],[10,"ProgramUniform4uiv","","",157],[10,"ProgramUniformMatrix2dv","","",157],[10,"ProgramUniformMatrix2fv","","",157],[10,"ProgramUniformMatrix2x3dv","","",157],[10,"ProgramUniformMatrix2x3fv","","",157],[10,"ProgramUniformMatrix2x4dv","","",157],[10,"ProgramUniformMatrix2x4fv","","",157],[10,"ProgramUniformMatrix3dv","","",157],[10,"ProgramUniformMatrix3fv","","",157],[10,"ProgramUniformMatrix3x2dv","","",157],[10,"ProgramUniformMatrix3x2fv","","",157],[10,"ProgramUniformMatrix3x4dv","","",157],[10,"ProgramUniformMatrix3x4fv","","",157],[10,"ProgramUniformMatrix4dv","","",157],[10,"ProgramUniformMatrix4fv","","",157],[10,"ProgramUniformMatrix4x2dv","","",157],[10,"ProgramUniformMatrix4x2fv","","",157],[10,"ProgramUniformMatrix4x3dv","","",157],[10,"ProgramUniformMatrix4x3fv","","",157],[10,"ProvokingVertex","","",157],[10,"PushDebugGroup","","",157],[10,"QueryCounter","","",157],[10,"ReadBuffer","","",157],[10,"ReadPixels","","",157],[10,"ReadnPixels","","",157],[10,"ReleaseShaderCompiler","","",157],[10,"RenderbufferStorage","","",157],[10,"RenderbufferStorageMultisample","","",157],[10,"ResumeTransformFeedback","","",157],[10,"SampleCoverage","","",157],[10,"SampleMaski","","",157],[10,"SamplerParameterIiv","","",157],[10,"SamplerParameterIuiv","","",157],[10,"SamplerParameterf","","",157],[10,"SamplerParameterfv","","",157],[10,"SamplerParameteri","","",157],[10,"SamplerParameteriv","","",157],[10,"Scissor","","",157],[10,"ScissorArrayv","","",157],[10,"ScissorIndexed","","",157],[10,"ScissorIndexedv","","",157],[10,"SecondaryColorP3ui","","",157],[10,"SecondaryColorP3uiv","","",157],[10,"ShaderBinary","","",157],[10,"ShaderSource","","",157],[10,"ShaderStorageBlockBinding","","",157],[10,"StencilFunc","","",157],[10,"StencilFuncSeparate","","",157],[10,"StencilMask","","",157],[10,"StencilMaskSeparate","","",157],[10,"StencilOp","","",157],[10,"StencilOpSeparate","","",157],[10,"TexBuffer","","",157],[10,"TexBufferRange","","",157],[10,"TexCoordP1ui","","",157],[10,"TexCoordP1uiv","","",157],[10,"TexCoordP2ui","","",157],[10,"TexCoordP2uiv","","",157],[10,"TexCoordP3ui","","",157],[10,"TexCoordP3uiv","","",157],[10,"TexCoordP4ui","","",157],[10,"TexCoordP4uiv","","",157],[10,"TexImage1D","","",157],[10,"TexImage2D","","",157],[10,"TexImage2DMultisample","","",157],[10,"TexImage3D","","",157],[10,"TexImage3DMultisample","","",157],[10,"TexParameterIiv","","",157],[10,"TexParameterIuiv","","",157],[10,"TexParameterf","","",157],[10,"TexParameterfv","","",157],[10,"TexParameteri","","",157],[10,"TexParameteriv","","",157],[10,"TexStorage1D","","",157],[10,"TexStorage2D","","",157],[10,"TexStorage2DMultisample","","",157],[10,"TexStorage3D","","",157],[10,"TexStorage3DMultisample","","",157],[10,"TexSubImage1D","","",157],[10,"TexSubImage2D","","",157],[10,"TexSubImage3D","","",157],[10,"TextureBarrier","","",157],[10,"TextureBuffer","","",157],[10,"TextureBufferRange","","",157],[10,"TextureParameterIiv","","",157],[10,"TextureParameterIuiv","","",157],[10,"TextureParameterf","","",157],[10,"TextureParameterfv","","",157],[10,"TextureParameteri","","",157],[10,"TextureParameteriv","","",157],[10,"TextureStorage1D","","",157],[10,"TextureStorage2D","","",157],[10,"TextureStorage2DMultisample","","",157],[10,"TextureStorage3D","","",157],[10,"TextureStorage3DMultisample","","",157],[10,"TextureSubImage1D","","",157],[10,"TextureSubImage2D","","",157],[10,"TextureSubImage3D","","",157],[10,"TextureView","","",157],[10,"TransformFeedbackBufferBase","","",157],[10,"TransformFeedbackBufferRange","","",157],[10,"TransformFeedbackVaryings","","",157],[10,"Uniform1d","","",157],[10,"Uniform1dv","","",157],[10,"Uniform1f","","",157],[10,"Uniform1fv","","",157],[10,"Uniform1i","","",157],[10,"Uniform1iv","","",157],[10,"Uniform1ui","","",157],[10,"Uniform1uiv","","",157],[10,"Uniform2d","","",157],[10,"Uniform2dv","","",157],[10,"Uniform2f","","",157],[10,"Uniform2fv","","",157],[10,"Uniform2i","","",157],[10,"Uniform2iv","","",157],[10,"Uniform2ui","","",157],[10,"Uniform2uiv","","",157],[10,"Uniform3d","","",157],[10,"Uniform3dv","","",157],[10,"Uniform3f","","",157],[10,"Uniform3fv","","",157],[10,"Uniform3i","","",157],[10,"Uniform3iv","","",157],[10,"Uniform3ui","","",157],[10,"Uniform3uiv","","",157],[10,"Uniform4d","","",157],[10,"Uniform4dv","","",157],[10,"Uniform4f","","",157],[10,"Uniform4fv","","",157],[10,"Uniform4i","","",157],[10,"Uniform4iv","","",157],[10,"Uniform4ui","","",157],[10,"Uniform4uiv","","",157],[10,"UniformBlockBinding","","",157],[10,"UniformMatrix2dv","","",157],[10,"UniformMatrix2fv","","",157],[10,"UniformMatrix2x3dv","","",157],[10,"UniformMatrix2x3fv","","",157],[10,"UniformMatrix2x4dv","","",157],[10,"UniformMatrix2x4fv","","",157],[10,"UniformMatrix3dv","","",157],[10,"UniformMatrix3fv","","",157],[10,"UniformMatrix3x2dv","","",157],[10,"UniformMatrix3x2fv","","",157],[10,"UniformMatrix3x4dv","","",157],[10,"UniformMatrix3x4fv","","",157],[10,"UniformMatrix4dv","","",157],[10,"UniformMatrix4fv","","",157],[10,"UniformMatrix4x2dv","","",157],[10,"UniformMatrix4x2fv","","",157],[10,"UniformMatrix4x3dv","","",157],[10,"UniformMatrix4x3fv","","",157],[10,"UniformSubroutinesuiv","","",157],[10,"UnmapBuffer","","",157],[10,"UnmapNamedBuffer","","",157],[10,"UseProgram","","",157],[10,"UseProgramStages","","",157],[10,"ValidateProgram","","",157],[10,"ValidateProgramPipeline","","",157],[10,"VertexArrayAttribBinding","","",157],[10,"VertexArrayAttribFormat","","",157],[10,"VertexArrayAttribIFormat","","",157],[10,"VertexArrayAttribLFormat","","",157],[10,"VertexArrayBindingDivisor","","",157],[10,"VertexArrayElementBuffer","","",157],[10,"VertexArrayVertexBuffer","","",157],[10,"VertexArrayVertexBuffers","","",157],[10,"VertexAttrib1d","","",157],[10,"VertexAttrib1dv","","",157],[10,"VertexAttrib1f","","",157],[10,"VertexAttrib1fv","","",157],[10,"VertexAttrib1s","","",157],[10,"VertexAttrib1sv","","",157],[10,"VertexAttrib2d","","",157],[10,"VertexAttrib2dv","","",157],[10,"VertexAttrib2f","","",157],[10,"VertexAttrib2fv","","",157],[10,"VertexAttrib2s","","",157],[10,"VertexAttrib2sv","","",157],[10,"VertexAttrib3d","","",157],[10,"VertexAttrib3dv","","",157],[10,"VertexAttrib3f","","",157],[10,"VertexAttrib3fv","","",157],[10,"VertexAttrib3s","","",157],[10,"VertexAttrib3sv","","",157],[10,"VertexAttrib4Nbv","","",157],[10,"VertexAttrib4Niv","","",157],[10,"VertexAttrib4Nsv","","",157],[10,"VertexAttrib4Nub","","",157],[10,"VertexAttrib4Nubv","","",157],[10,"VertexAttrib4Nuiv","","",157],[10,"VertexAttrib4Nusv","","",157],[10,"VertexAttrib4bv","","",157],[10,"VertexAttrib4d","","",157],[10,"VertexAttrib4dv","","",157],[10,"VertexAttrib4f","","",157],[10,"VertexAttrib4fv","","",157],[10,"VertexAttrib4iv","","",157],[10,"VertexAttrib4s","","",157],[10,"VertexAttrib4sv","","",157],[10,"VertexAttrib4ubv","","",157],[10,"VertexAttrib4uiv","","",157],[10,"VertexAttrib4usv","","",157],[10,"VertexAttribBinding","","",157],[10,"VertexAttribDivisor","","",157],[10,"VertexAttribFormat","","",157],[10,"VertexAttribI1i","","",157],[10,"VertexAttribI1iv","","",157],[10,"VertexAttribI1ui","","",157],[10,"VertexAttribI1uiv","","",157],[10,"VertexAttribI2i","","",157],[10,"VertexAttribI2iv","","",157],[10,"VertexAttribI2ui","","",157],[10,"VertexAttribI2uiv","","",157],[10,"VertexAttribI3i","","",157],[10,"VertexAttribI3iv","","",157],[10,"VertexAttribI3ui","","",157],[10,"VertexAttribI3uiv","","",157],[10,"VertexAttribI4bv","","",157],[10,"VertexAttribI4i","","",157],[10,"VertexAttribI4iv","","",157],[10,"VertexAttribI4sv","","",157],[10,"VertexAttribI4ubv","","",157],[10,"VertexAttribI4ui","","",157],[10,"VertexAttribI4uiv","","",157],[10,"VertexAttribI4usv","","",157],[10,"VertexAttribIFormat","","",157],[10,"VertexAttribIPointer","","",157],[10,"VertexAttribL1d","","",157],[10,"VertexAttribL1dv","","",157],[10,"VertexAttribL2d","","",157],[10,"VertexAttribL2dv","","",157],[10,"VertexAttribL3d","","",157],[10,"VertexAttribL3dv","","",157],[10,"VertexAttribL4d","","",157],[10,"VertexAttribL4dv","","",157],[10,"VertexAttribLFormat","","",157],[10,"VertexAttribLPointer","","",157],[10,"VertexAttribP1ui","","",157],[10,"VertexAttribP1uiv","","",157],[10,"VertexAttribP2ui","","",157],[10,"VertexAttribP2uiv","","",157],[10,"VertexAttribP3ui","","",157],[10,"VertexAttribP3uiv","","",157],[10,"VertexAttribP4ui","","",157],[10,"VertexAttribP4uiv","","",157],[10,"VertexAttribPointer","","",157],[10,"VertexBindingDivisor","","",157],[10,"VertexP2ui","","",157],[10,"VertexP2uiv","","",157],[10,"VertexP3ui","","",157],[10,"VertexP3uiv","","",157],[10,"VertexP4ui","","",157],[10,"VertexP4uiv","","",157],[10,"Viewport","","",157],[10,"ViewportArrayv","","",157],[10,"ViewportIndexedf","","",157],[10,"ViewportIndexedfv","","",157],[10,"WaitSync","","",157],[10,"fmt","device::gl","",158],[10,"eq","","",158],[10,"ne","","",158],[10,"ne","","",158],[10,"assert_receiver_is_total_eq","","",158],[10,"new","","Load OpenGL symbols and detect driver information",159],[10,"get_info","","Get the OpenGL-specific driver information",159],[10,"get_capabilities","","",159],[10,"create_buffer_raw","","",159],[10,"create_buffer_static","","",159],[10,"create_array_buffer","","",159],[10,"create_shader","","",159],[10,"create_program","","",159],[10,"create_frame_buffer","","",159],[10,"create_surface","","",159],[10,"create_texture","","",159],[10,"create_sampler","","",159],[10,"delete_buffer_raw","","",159],[10,"delete_shader","","",159],[10,"delete_program","","",159],[10,"delete_surface","","",159],[10,"delete_texture","","",159],[10,"delete_sampler","","",159],[10,"update_buffer_raw","","",159],[10,"update_texture_raw","","",159],[10,"generate_mipmap","","",159],[10,"submit","","",159],[10,"create_buffer","","",159],[10,"delete_buffer","","",159],[10,"update_buffer","","",159],[10,"update_texture","","",159],[10,"fmt","device","",160],[10,"clone","","",160],[10,"clone_from","","",160],[10,"get_name","","Get the internal name",160],[10,"get_info","","Get the info reference",160],[10,"eq","","",160],[10,"ne","","",160],[10,"clone","","",161],[10,"clone_from","","",161],[10,"fmt","","",161],[10,"from_raw","","Create a type-safe BufferHandle from a RawBufferHandle",161],[10,"cast","","Cast the type this BufferHandle references",161],[10,"get_name","","Get the underlying GL name for this BufferHandle",161],[10,"get_info","","Get the associated information about the buffer",161],[10,"raw","","Get the underlying raw Handle",161],[10,"fmt","","",162],[10,"cast","alloc::boxed","",163],[10,"get_address","collections::vec","",164],[10,"get_size","","",164],[10,"fmt","alloc::boxed","",163],[10,"fmt","device","",165],[10,"eq","","",165],[10,"ne","","",165],[10,"ne","","",165],[10,"clone","","",165],[10,"clone_from","","",165],[10,"fmt","","",166],[10,"eq","","",166],[10,"ne","","",166],[10,"ne","","",166],[10,"clone","","",166],[10,"clone_from","","",166],[10,"fmt","","",167],[10,"eq","","",167],[10,"ne","","",167],[10,"ne","","",167],[10,"clone","","",167],[10,"clone_from","","",167],[10,"fmt","","",168],[4,"Count","piston::gfx::attrib",""],[4,"Offset","",""],[4,"Stride","",""],[2,"SignFlag","",""],[12,"Signed","","",95],[12,"Unsigned","","",95],[2,"IntSubType","",""],[12,"IntRaw","","",96],[12,"IntNormalized","","",96],[12,"IntAsFloat","","",96],[2,"IntSize","",""],[12,"U8","","",97],[12,"U16","","",97],[12,"U32","","",97],[2,"FloatSubType","",""],[12,"FloatDefault","","",98],[12,"FloatPrecision","","",98],[2,"FloatSize","",""],[12,"F16","","",99],[12,"F32","","",99],[12,"F64","","",99],[2,"Type","",""],[12,"Int","","",100],[12,"Float","","",100],[12,"Special","","",100],[10,"new","render::mesh","Create a new mesh, which is a `TriangleList` with no attributes and `nv` vertices.",169],[10,"from","","Create a new `Mesh` from a struct that implements `VertexFormat` and a buffer.",169],[10,"get_slice","","Return a vertex slice of the whole mesh",169],[10,"fmt","render::front","",170],[10,"fmt","","",171],[10,"fmt","","",172],[10,"fmt","","",173],[10,"eq","","",173],[10,"ne","","",173],[10,"ne","","",173],[10,"clone","","",173],[10,"clone_from","","",173],[10,"reset","","Reset all commands for the command buffer re-usal.",174],[10,"as_buffer","","Get a command buffer to be submitted",174],[10,"clone_empty","","Clone the renderer shared data but ignore the commands",174],[10,"clear","","Clear the `Frame` as the `ClearData` specifies.",174],[10,"draw","","Draw `slice` of `mesh` into `frame`, using a program shell, and a given draw state.",174],[10,"update_buffer_vec","","Update a buffer with data from a vector.",174],[10,"update_buffer_struct","","Update a buffer with data from a single type.",174],[10,"update_texture","","Update the contents of a texture.",174],[10,"fmt","render::mesh","",175],[10,"eq","","",175],[10,"ne","","",175],[10,"ne","","",175],[10,"clone","","",175],[10,"clone_from","","",175],[10,"fmt","","",169],[10,"clone","","",169],[10,"clone_from","","",169],[10,"fmt","","",176],[10,"clone","","",176],[10,"clone_from","","",176],[10,"eq","render::shade","",177],[10,"ne","","",177],[10,"ne","","",177],[10,"clone","","",177],[10,"clone_from","","",177],[10,"fmt","","",177],[10,"clone","","",178],[10,"clone_from","","",178],[10,"connect","","Connect a shader program with a parameter structure",178],[10,"connect","","Connect a shader program with a parameter structure",179],[10,"fmt","render::state","",180],[10,"eq","","",180],[10,"ne","","",180],[10,"ne","","",180],[10,"clone","","",180],[10,"clone_from","","",180],[10,"fmt","","",181],[10,"eq","","",181],[10,"ne","","",181],[10,"ne","","",181],[10,"clone","","",181],[10,"clone_from","","",181],[10,"new","","Create a default `DrawState`. Uses counter-clockwise winding, culls the backface of each\nprimitive, and does no scissor/stencil/depth/blend/color masking.",180],[10,"stencil","","Set the stencil test to a simple expression",180],[10,"depth","","Set the depth test with the mask",180],[10,"blend","","Set the blend mode to one of the presets",180],[10,"fmt","render::target","",182],[10,"eq","","",182],[10,"ne","","",182],[10,"ne","","",182],[10,"clone","","",182],[10,"clone_from","","",182],[10,"new","","Create an empty `Frame`, which corresponds to the 'default framebuffer', which for now\nrenders directly to the window that was created with the OpenGL context.",183],[10,"is_default","","Returns true if this framebuffer is associated with the main window (matches `Frame::new`\nexactly).",183],[1,"Mesh","piston::gfx","Describes geometry to render."],[11,"num_vertices","","Number of vertices in the mesh.",169],[11,"attributes","","Vertex attributes to use.",169],[0,"front","","Frontend\nRendering front-end"],[2,"ParameterError","piston::gfx::front","An error with an invalid texture or uniform block."],[12,"ErrorParamUniform","","Error from a uniform value",170],[12,"ErrorParamBlock","","Error from a uniform block.",170],[12,"ErrorParamTexture","","Error from a texture.",170],[12,"ErrorParamSampler","","Error from a sampler",170],[2,"MeshError","","An error with a defined Mesh."],[12,"ErrorAttributeMissing","","A required attribute was missing.",171],[12,"ErrorAttributeType","","An attribute's type from the vertex format differed from the type used in the shader.",171],[2,"DrawError","","An error that can happen when trying to draw."],[12,"ErrorProgram","","Error with a program.",172],[12,"ErrorParameter","","Error with the program shell.",172],[12,"ErrorMesh","","Error with the mesh.",172],[12,"ErrorSlice","","Error with the mesh slice",172],[2,"ProgramError","","Program linking error"],[12,"ErrorVertex","","Unable to compile the vertex shader",173],[12,"ErrorFragment","","Unable to compile the fragment shader",173],[12,"ErrorLink","","Unable to link",173],[12,"ErrorParameters","","Unable to connect parameters",173],[6,"DeviceHelper","","Backend extension trait for convenience methods"],[9,"create_renderer","","Create a new renderer",184],[9,"create_mesh","","Create a new mesh from the given vertex data.\nConvenience function around `create_buffer` and `Mesh::from`.",184],[9,"link_program","","Create a simple program given a vertex shader with a fragment one.\nThe return type can not be derived from the arguments, so you need to\nprovide it explicitly:",184],[1,"Renderer","","Renderer front-end"],[1,"BufferHandle","piston::gfx","Type-safe buffer handle"],[4,"Layer","",""],[0,"state","","Fixed-function hardware state."],[2,"WindingOrder","piston::gfx::state","The winding order of a set of vertices."],[12,"Clockwise","","Clockwise winding order.",121],[12,"CounterClockwise","","Counter-clockwise winding order.",121],[4,"LineWidth","",""],[4,"OffsetFactor","",""],[4,"OffsetUnits","",""],[2,"OffsetType","","How to offset vertices in screen space, if at all."],[12,"NoOffset","","",122],[12,"Offset","","",122],[2,"CullMode","","Which face, if any, to cull."],[12,"CullNothing","","",123],[12,"CullFront","","",123],[12,"CullBack","","",123],[2,"RasterMethod","","How to rasterize a primitive."],[12,"Point","","Rasterize as a point.",124],[12,"Line","","Rasterize as a line with the given width.",124],[12,"Fill","","Rasterize as a face with a given cull mode.",124],[1,"Primitive","","Primitive rasterization state. Note that GL allows different raster\nmethod to be used for front and back, while this abstraction does not."],[11,"front_face","","Which vertex winding is considered to be the front face for culling.",125],[11,"method","","How to rasterize this primitive.",125],[11,"offset","","Any polygon offset to apply.",125],[2,"Comparison","","A pixel-wise comparison function."],[12,"Never","","`false`",126],[12,"Less","","`x < y`",126],[12,"LessEqual","","`x <= y`",126],[12,"Equal","","`x == y`",126],[12,"GreaterEqual","","`x >= y`",126],[12,"Greater","","`x > y`",126],[12,"NotEqual","","`x != y`",126],[12,"Always","","`true`",126],[2,"StencilOp","","Stencil mask operation."],[12,"OpKeep","","Keep the current value in the stencil buffer (no change).",127],[12,"OpZero","","Set the value in the stencil buffer to zero.",127],[12,"OpReplace","","Set the stencil buffer value to `value` from `StencilSide`",127],[12,"OpIncrementClamp","","Increment the stencil buffer value, clamping to its maximum value.",127],[12,"OpIncrementWrap","","Increment the stencil buffer value, wrapping around to 0 on overflow.",127],[12,"OpDecrementClamp","","Decrement the stencil buffer value, clamping to its minimum value.",127],[12,"OpDecrementWrap","","Decrement the stencil buffer value, wrapping around to the maximum value on overflow.",127],[12,"OpInvert","","Bitwise invert the current value in the stencil buffer.",127],[1,"StencilSide","","Complete stencil state for a given side of a face."],[11,"fun","","Comparison function to use to determine if the stencil test passes.",128],[11,"value","","Reference value to compare the value in the stencil buffer with.",128],[11,"mask_read","","A mask that is ANDd with both the stencil buffer value and the reference value when they\nare read before doing the stencil test.",128],[11,"mask_write","","This is unused!",128],[11,"op_fail","","What operation to do if the stencil test fails.",128],[11,"op_depth_fail","","What operation to do if the stenil test passes but the depth test fails.",128],[11,"op_pass","","What operation to do if both the depth and stencil test pass.",128],[1,"Stencil","","Complete stencil state, specifying how to handle the front and back side of a face."],[11,"front","","",129],[11,"back","","",129],[1,"Depth","","Depth test state."],[11,"fun","","Comparison function to use.",130],[11,"write","","Specify whether to write to the depth buffer or not.",130],[2,"Equation","",""],[12,"FuncAdd","","",131],[12,"FuncSub","","",131],[12,"FuncRevSub","","",131],[12,"FuncMin","","",131],[12,"FuncMax","","",131],[2,"InverseFlag","",""],[12,"Normal","","",132],[12,"Inverse","","",132],[2,"BlendValue","",""],[12,"Zero","","",133],[12,"SourceColor","","",133],[12,"SourceAlpha","","",133],[12,"SourceAlphaSaturated","","",133],[12,"DestColor","","",133],[12,"DestAlpha","","",133],[12,"ConstColor","","",133],[12,"ConstAlpha","","",133],[1,"Factor","",""],[1,"BlendChannel","",""],[11,"equation","","",135],[11,"source","","",135],[11,"destination","","",135],[1,"Blend","",""],[11,"color","","",136],[11,"alpha","","",136],[11,"value","","",136],[1,"ColorMask","",""],[5,"Red","",""],[5,"Green","",""],[5,"Blue","",""],[5,"Alpha","",""],[5,"MaskAll","",""],[4,"IndexCount","piston::gfx",""],[1,"ProgramInfo","","Metadata about a program."],[11,"attributes","","Attributes in the program.",115],[11,"uniforms","","Uniforms in the program",115],[11,"blocks","","Uniform blocks in the program",115],[11,"textures","","Samplers in the program",115],[1,"ClearData","","How to clear a frame."],[11,"color","","If set, the color buffer of the frame will be cleared to this.",139],[11,"depth","","If set, the depth buffer of the frame will be cleared to this.",139],[11,"stencil","","If set, the stencil buffer of the frame will be cleared to this.",139],[4,"RawBufferHandle","",""],[6,"Device","","An interface for performing draw calls using a specific graphics API"],[9,"get_capabilities","","Returns the capabilities available to the specific API implementation",185],[9,"create_buffer_raw","","",185],[9,"create_buffer","","",185],[9,"create_buffer_static","","",185],[9,"create_array_buffer","","",185],[9,"create_shader","","",185],[9,"create_program","","",185],[9,"create_frame_buffer","","",185],[9,"create_surface","","",185],[9,"create_texture","","",185],[9,"create_sampler","","",185],[9,"delete_buffer_raw","","",185],[9,"delete_buffer","","",185],[9,"delete_shader","","",185],[9,"delete_program","","",185],[9,"delete_surface","","",185],[9,"delete_texture","","",185],[9,"delete_sampler","","",185],[9,"update_buffer_raw","","Update the information stored in a specific buffer",185],[9,"update_buffer","","",185],[9,"update_texture_raw","","Update the information stored in a texture",185],[9,"update_texture","","",185],[9,"generate_mipmap","","",185],[9,"submit","","Submit a command buffer for execution",185],[1,"Frame","","A complete `Frame`, which is the result of rendering."],[11,"width","","The width of the viewport.",183],[11,"height","","The height of the viewport.",183],[11,"colors","","Each color component has its own buffer.",183],[11,"depth","","The depth buffer for this frame.",183],[11,"stencil","","The stencil buffer for this frame.",183],[4,"ShaderHandle","",""],[1,"ShaderSource","","A type storing shader source for different graphics APIs and versions."],[11,"glsl_120","","",118],[11,"glsl_150","","",118],[2,"UniformValue","","A value that can be uploaded to the device as a uniform."],[12,"ValueI32","","",110],[12,"ValueF32","","",110],[12,"ValueI32Vector2","","",110],[12,"ValueI32Vector3","","",110],[12,"ValueI32Vector4","","",110],[12,"ValueF32Vector2","","",110],[12,"ValueF32Vector3","","",110],[12,"ValueF32Vector4","","",110],[12,"ValueF32Matrix2","","",110],[12,"ValueF32Matrix3","","",110],[12,"ValueF32Matrix4","","",110],[2,"BufferUsage","","A hint as to how this buffer will be used."],[12,"UsageStatic","","Once uploaded, this buffer will rarely change, but will be read from often.",166],[12,"UsageDynamic","","This buffer will be updated \"frequently\", and will be read from multiple times between\nupdates.",166],[12,"UsageStream","","This buffer always or almost always be updated after each read.",166],[4,"TextureHandle","",""],[2,"Slice","","Description of a subset of `Mesh` data to render.\nWe provide a primitive type in a slice because it is how we interpret mesh\ncontents. For example, we can have a `Point` typed vertex slice to do shape\nblending, while still rendereing it as an indexed `TriangleList`."],[12,"VertexSlice","","Render vertex data directly from the `Mesh`'s buffer, using only the vertices between the two\nendpoints.",176],[12,"IndexSlice8","","The `IndexSlice*` buffer contains a list of indices into the `Mesh` data, so every vertex\nattribute does not need to be duplicated, only its position in the `Mesh`.  For example,\nwhen drawing a square, two triangles are needed.  Using only `VertexSlice`, one would need\n6 separate vertices, 3 for each triangle. However, two of the vertices will be identical,\nwasting space for the duplicated attributes.  Instead, the `Mesh` can store 4 vertices and\nan `IndexSlice8` can be used instead.",176],[12,"IndexSlice16","","As `IndexSlice8` but with `u16` indices",176],[12,"IndexSlice32","","As `IndexSlice8` but with `u32` indices",176],[6,"VertexFormat","","A trait implemented automatically for user vertex structure by\n`#[vertex_format] attribute"],[9,"generate","","Create the attributes for this type, using the given buffer.",186],[1,"GlDevice","","An OpenGL device with GLSL shaders"],[6,"DeviceHelper","","Backend extension trait for convenience methods"],[9,"create_renderer","","Create a new renderer",184],[9,"create_mesh","","Create a new mesh from the given vertex data.\nConvenience function around `create_buffer` and `Mesh::from`.",184],[9,"link_program","","Create a simple program given a vertex shader with a fragment one.\nThe return type can not be derived from the arguments, so you need to\nprovide it explicitly:",184],[4,"Level","",""],[4,"Color","",""],[6,"Blob","","A trait that slice-like types implement."],[9,"get_address","","Get the address to the data this `Blob` stores.",187],[9,"get_size","","Get the number of bytes in this blob.",187],[1,"BufferInfo","","An information block that is immutable and associated with each buffer"],[11,"usage","","Usage hint",167],[11,"size","","Size in bytes",167],[4,"SurfaceHandle","",""],[4,"ProgramHandle","",""],[0,"tex","","Texture creation and modification."],[2,"SurfaceError","piston::gfx::tex","Surface creation/update error."],[12,"UnsupportedSurfaceFormat","","Failed to map a given format to the device",141],[2,"TextureError","","Texture creation/update error."],[12,"UnsupportedTextureFormat","","Failed to map a given format to the device",142],[4,"Bits","",""],[2,"Components","","Describes the component layout of each texel."],[12,"R","","Red only",143],[12,"RG","","Red and green",143],[12,"RGB","","Red, green, blue",143],[12,"RGBA","","Red, green, blue, alpha",143],[2,"Format","","Describes the layout of each texel within a surface/texture."],[12,"Float","","Floating point.",144],[12,"Integer","","Signed integer.",144],[12,"Unsigned","","Unsigned integer.",144],[12,"R3G3B2","","Normalized integer, with 3 bits for R and G, but only 2 for B.",144],[12,"RGB5A1","","5 bits each for RGB, 1 for Alpha.",144],[12,"RGB10A2","","10 bits each for RGB, 2 for Alpha.",144],[12,"RGB10A2UI","","10 bits each for RGB, 2 for Alpha, as unsigned integers.",144],[12,"R11FG11FB10F","","This uses special 11 and 10-bit floating-point values without sign bits.",144],[12,"RGB9E5","","This s an RGB format of type floating-point. The 3 color values have\n9 bits of precision, and they share a single exponent.",144],[12,"DEPTH24STENCIL8","","24 bits for depth, 8 for stencil",144],[5,"RGBA8","",""],[1,"SurfaceInfo","","Describes the storage of a surface"],[11,"width","","",145],[11,"height","","",145],[11,"format","","",145],[2,"FilterMethod","","How to [filter](https://en.wikipedia.org/wiki/Texture_filtering) the\ntexture when sampling. They correspond to increasing levels of quality,\nbut also cost. They \"layer\" on top of each other: it is not possible to\nhave bilinear filtering without mipmapping, for example."],[12,"Scale","","The dumbest filtering possible, nearest-neighbor interpolation.",146],[12,"Mipmap","","Add simple mipmapping.",146],[12,"Bilinear","","Sample multiple texels within a single mipmap level to increase\nquality.",146],[12,"Trilinear","","Sample multiple texels across two mipmap levels to increase quality.",146],[12,"Anisotropic","","Anisotropic filtering with a given \"max\", must be between 1 and 16,\ninclusive.",146],[2,"TextureKind","","Specifies how a given texture may be used. The available texture types are\nrestricted by what Metal exposes, though this could conceivably be\nextended in the future. Note that a single texture can *only* ever be of\none kind. A texture created as `Texture2D` will forever be `Texture2D`."],[12,"Texture1D","","A single row of texels.",147],[12,"Texture1DArray","","An array of rows of texels. Equivalent to Texture2D except that texels\nin a different row are not sampled.",147],[12,"Texture2D","","A traditional 2D texture, with rows arranged contiguously.",147],[12,"Texture2DArray","","An array of 2D textures. Equivalent to Texture3D except that texels in\na different depth level are not sampled.",147],[12,"TextureCube","","A set of 6 2D textures, one for each face of a cube.",147],[12,"Texture3D","","A volume texture, with each 2D layer arranged contiguously.",147],[1,"TextureInfo","","Describes the storage of a texture."],[11,"width","","",148],[11,"height","","",148],[11,"depth","","",148],[11,"levels","","Number of mipmap levels. Defaults to -1, which stands for unlimited.\nMipmap levels at equal or above `levels` can not be loaded or sampled\nby the shader. width and height of each consecutive mipmap level is\nhalved, starting from level 0.",148],[11,"kind","","",148],[11,"format","","",148],[1,"ImageInfo","","Describes a subvolume of a texture, which image data can be uploaded into."],[11,"xoffset","","",149],[11,"yoffset","","",149],[11,"zoffset","","",149],[11,"width","","",149],[11,"height","","",149],[11,"depth","","",149],[11,"format","","Format of each texel.",149],[11,"mipmap","","Which mipmap to select.",149],[2,"WrapMode","","Specifies how texture coordinates outside the range `[0, 1]` are handled."],[12,"Tile","","Tile the texture. That is, sample the coordinate modulo `1.0`. This is\nthe default.",150],[12,"Mirror","","Mirror the texture. Like tile, but uses abs(coord) before the modulo.",150],[12,"Clamp","","Clamp the texture to the value at `0.0` or `1.0` respectively.",150],[1,"SamplerInfo","","Specifies how to sample from a texture."],[11,"filtering","","Filter method to use.",151],[11,"wrap_mode","","Wrapping mode for each of the U, V, and W axis (S, T, and R in OpenGL\nspeak)",151],[11,"lod_bias","","This bias is added to every computed mipmap level (N + lod_bias). For\nexample, if it would select mipmap level 2 and lod_bias is 1, it will\nuse mipmap level 3.",151],[11,"lod_range","","This range is used to clamp LOD level used for sampling",151],[2,"Plane","piston::gfx","A single buffer that can be bound to a render target."],[12,"PlaneEmpty","","No buffer, the results will not be stored.",182],[12,"PlaneSurface","","Render to a `Surface` (corresponds to a renderbuffer in GL).",182],[12,"PlaneTexture","","Render to a texture at a specific mipmap level\nIf `Layer` is set, it is selecting a single 2D slice of a given 3D texture",182],[1,"DrawState","","An assembly of states that affect regular draw calls"],[11,"primitive","","How to rasterize geometric primitives.",180],[11,"scissor","","Stencil mask to use. If set, no pixel outside of this rectangle (in screen space) will be\nwritten to as a result of rendering.",180],[11,"stencil","","Stencil test to use. If None, no stencil testing is done.",180],[11,"depth","","Depth test to use. If None, no depth testing is done.",180],[11,"blend","","Blend function to use. If None, no blending is done.",180],[11,"color_mask","","Color mask to use. Each flag indicates that the given color channel can be written to, and\nthey can be OR'd together.",180],[4,"VertexCount","",""],[1,"Renderer","","Renderer front-end"],[1,"Attribute","","Describes a single attribute of a vertex buffer, including its type, name, etc."],[11,"buffer","","Vertex buffer to contain the data",175],[11,"elem_count","","Number of elements per vertex",175],[11,"elem_type","","Type of a single element",175],[11,"offset","","Offset in bytes to the first vertex",175],[11,"stride","","Stride in bytes between consecutive vertices",175],[11,"name","","A name to match the shader input",175],[0,"shade","","Shaders\nShader parameter handling."],[6,"ToUniform","piston::gfx::shade","Helper trait to transform base types into their corresponding uniforms"],[9,"to_uniform","","Create a `UniformValue` representing this value.",188],[4,"VarUniform","",""],[4,"VarBlock","",""],[4,"VarTexture","",""],[4,"TextureParam","",""],[1,"ParamValues","","A borrowed mutable storage for shader parameter values."],[11,"uniforms","","uniform values to be provided",189],[11,"blocks","","uniform buffers to be provided",189],[11,"textures","","textures to be provided",189],[6,"Program","","Encloses a shader program handle with its parameter"],[9,"get_handle","","Get the contained program handle",190],[9,"fill_params","","Get all the contained parameter values",190],[2,"ParameterError","","An error type on either the parameter storage or the program side"],[12,"ErrorInternal","","Internal error",177],[12,"ErrorUniform","","Error with the named uniform",177],[12,"ErrorBlock","","Error with the named uniform block",177],[12,"ErrorTexture","","Error with the named texture.",177],[6,"ShaderParam","","Abstracts the shader parameter structure, generated by the `shader_param` attribute"],[9,"create_link","","Creates a new link, self is passed as a workaround for Rust to not be lost in generics",191],[9,"fill_params","","Get all the contained parameter values, using a given link.",191],[1,"UserProgram","","A bundle that encapsulates a program and a custom user-provided\nstructure containing the program parameters.\n# Type parameters:"],[4,"EmptyProgram","",""],[1,"NamedCell","","A named cell containing arbitrary value"],[11,"name","","Name",192],[11,"value","","Value",192],[1,"ParamDictionary","","A dictionary of parameters, meant to be shared between different programs"],[11,"uniforms","","Uniform dictionary",193],[11,"blocks","","Block dictionary",193],[11,"textures","","Texture dictionary",193],[1,"ParamDictionaryLink","","An associated link structure for `ParamDictionary` that redirects program\ninput to the relevant dictionary cell."],[1,"DictionaryProgram","","A shader program with dictionary of parameters"]],"paths":[[1,"GameIterator"],[1,"GameIteratorSettings"],[1,"RenderArgs"],[1,"UpdateArgs"],[2,"GameEvent"],[1,"GameWindowSettings"],[2,"Event"],[6,"GameWindow"],[2,"OpenGL"],[2,"GLSL"],[2,"VersionRange"],[1,"WebpDecoder"],[1,"BoolReader"],[1,"Frame"],[1,"Segment"],[1,"VP8Decoder"],[1,"PPMEncoder"],[2,"FilterType"],[2,"PNGState"],[1,"PNGDecoder"],[1,"IDATReader"],[1,"PNGEncoder"],[1,"ZlibDecoder"],[2,"TableElement"],[1,"Inflater"],[1,"HuffReader"],[1,"Adler32"],[1,"Crc32"],[1,"JPEGEncoder"],[1,"Component"],[2,"JPEGState"],[1,"JPEGDecoder"],[1,"HuffTable"],[1,"HuffDecoder"],[1,"GIFDecoder"],[1,"LZWReader"],[2,"ImageError"],[2,"ImageFormat"],[1,"Pixels"],[1,"MutPixels"],[1,"ImageBuf"],[1,"SubImage"],[2,"DynamicImage"],[2,"ColorType"],[1,"Luma"],[1,"LumaA"],[1,"Rgb"],[1,"Rgba"],[2,"FilterType"],[6,"Pixel"],[6,"ImageDecoder"],[6,"MutableRefImage"],[6,"GenericImage"],[1,"Context"],[1,"Shape"],[6,"CanColor"],[6,"CanRectangle"],[6,"CanSourceRectangle"],[6,"CanTransform"],[6,"CanViewTransform"],[6,"HasColor"],[6,"HasRectangle"],[6,"HasSourceRectangle"],[6,"HasTransform"],[6,"HasViewTransform"],[6,"AddRoundBorder"],[6,"RelativeRectangle"],[6,"AddColor"],[6,"BackEnd"],[6,"RelativeTransform2d"],[6,"RelativeColor"],[6,"AddPolygons"],[6,"AddBevelBorder"],[6,"AddEllipse"],[6,"ImageSize"],[6,"AddBorder"],[6,"AddLine"],[6,"AddSquareBorder"],[6,"RelativeSourceRectangle"],[6,"AddImage"],[6,"AddTween"],[6,"AddRectangle"],[6,"Draw"],[6,"AddPolygon"],[6,"View"],[6,"AddBevel"],[6,"AddRound"],[2,"Key"],[2,"Button"],[2,"InputEvent"],[1,"FirstPerson"],[1,"Camera"],[1,"CameraPerspective"],[1,"Keys"],[1,"FirstPersonSettings"],[2,"SignFlag"],[2,"IntSubType"],[2,"IntSize"],[2,"FloatSubType"],[2,"FloatSize"],[2,"Type"],[2,"IsArray"],[2,"IsShadow"],[2,"IsMultiSample"],[2,"IsRect"],[2,"MatrixFormat"],[2,"SamplerType"],[2,"BaseType"],[2,"ContainerType"],[2,"Stage"],[2,"UniformValue"],[1,"Attribute"],[1,"UniformVar"],[1,"BlockVar"],[1,"SamplerVar"],[1,"ProgramInfo"],[2,"CompatibilityError"],[2,"Bytes"],[1,"ShaderSource"],[2,"CreateShaderError"],[2,"ShaderModel"],[2,"WindingOrder"],[2,"OffsetType"],[2,"CullMode"],[2,"RasterMethod"],[1,"Primitive"],[2,"Comparison"],[2,"StencilOp"],[1,"StencilSide"],[1,"Stencil"],[1,"Depth"],[2,"Equation"],[2,"InverseFlag"],[2,"BlendValue"],[1,"Factor"],[1,"BlendChannel"],[1,"Blend"],[1,"ColorMask"],[1,"Rect"],[1,"ClearData"],[2,"Target"],[2,"SurfaceError"],[2,"TextureError"],[2,"Components"],[2,"Format"],[1,"SurfaceInfo"],[2,"FilterMethod"],[2,"TextureKind"],[1,"TextureInfo"],[1,"ImageInfo"],[2,"WrapMode"],[1,"SamplerInfo"],[1,"GlCommandBuffer"],[1,"Version"],[1,"PlatformName"],[1,"Info"],[1,"FnPtr"],[1,"Gl"],[2,"ErrorType"],[1,"GlDevice"],[1,"Handle"],[1,"BufferHandle"],[1,"Capabilities"],[1,"Box"],[1,"Vec"],[2,"PrimitiveType"],[2,"BufferUsage"],[1,"BufferInfo"],[2,"Command"],[1,"Mesh"],[2,"ParameterError"],[2,"MeshError"],[2,"DrawError"],[2,"ProgramError"],[1,"Renderer"],[1,"Attribute"],[2,"Slice"],[2,"ParameterError"],[1,"UserProgram"],[1,"DictionaryProgram"],[1,"DrawState"],[2,"BlendPreset"],[2,"Plane"],[1,"Frame"],[6,"DeviceHelper"],[6,"Device"],[6,"VertexFormat"],[6,"Blob"],[6,"ToUniform"],[1,"ParamValues"],[6,"Program"],[6,"ShaderParam"],[1,"NamedCell"],[1,"ParamDictionary"]]};
searchIndex['gfx'] = {"items":[[0,"","gfx","An efficient, low-level, bindless graphics API for Rust. See [the\nblog](http://gfx-rs.github.io/) for explanations and annotated examples."],[0,"front","","Frontend\nRendering front-end"],[10,"fmt","render::front","",0],[10,"fmt","","",1],[10,"fmt","","",2],[10,"fmt","","",3],[10,"eq","","",3],[10,"ne","","",3],[10,"ne","","",3],[10,"clone","","",3],[10,"clone_from","","",3],[10,"reset","","Reset all commands for the command buffer re-usal.",4],[10,"as_buffer","","Get a command buffer to be submitted",4],[10,"clone_empty","","Clone the renderer shared data but ignore the commands",4],[10,"clear","","Clear the `Frame` as the `ClearData` specifies.",4],[10,"draw","","Draw `slice` of `mesh` into `frame`, using a program shell, and a given draw state.",4],[10,"update_buffer_vec","","Update a buffer with data from a vector.",4],[10,"update_buffer_struct","","Update a buffer with data from a single type.",4],[10,"update_texture","","Update the contents of a texture.",4],[10,"fmt","render::mesh","",5],[10,"eq","","",5],[10,"ne","","",5],[10,"ne","","",5],[10,"clone","","",5],[10,"clone_from","","",5],[10,"fmt","","",6],[10,"clone","","",6],[10,"clone_from","","",6],[10,"new","","Create a new mesh, which is a `TriangleList` with no attributes and `nv` vertices.",6],[10,"from","","Create a new `Mesh` from a struct that implements `VertexFormat` and a buffer.",6],[10,"get_slice","","Return a vertex slice of the whole mesh",6],[10,"fmt","","",7],[10,"clone","","",7],[10,"clone_from","","",7],[10,"eq","render::shade","",8],[10,"ne","","",8],[10,"ne","","",8],[10,"clone","","",8],[10,"clone_from","","",8],[10,"fmt","","",8],[10,"clone","","",9],[10,"clone_from","","",9],[10,"connect","","Connect a shader program with a parameter structure",9],[10,"connect","","Connect a shader program with a parameter structure",10],[10,"fmt","render::state","",11],[10,"eq","","",11],[10,"ne","","",11],[10,"ne","","",11],[10,"clone","","",11],[10,"clone_from","","",11],[10,"fmt","","",12],[10,"eq","","",12],[10,"ne","","",12],[10,"ne","","",12],[10,"clone","","",12],[10,"clone_from","","",12],[10,"new","","Create a default `DrawState`. Uses counter-clockwise winding, culls the backface of each\nprimitive, and does no scissor/stencil/depth/blend/color masking.",11],[10,"stencil","","Set the stencil test to a simple expression",11],[10,"depth","","Set the depth test with the mask",11],[10,"blend","","Set the blend mode to one of the presets",11],[10,"fmt","render::target","",13],[10,"eq","","",13],[10,"ne","","",13],[10,"ne","","",13],[10,"clone","","",13],[10,"clone_from","","",13],[10,"new","","Create an empty `Frame`, which corresponds to the 'default framebuffer', which for now\nrenders directly to the window that was created with the OpenGL context.",14],[10,"is_default","","Returns true if this framebuffer is associated with the main window (matches `Frame::new`\nexactly).",14],[2,"ParameterError","gfx::front","An error with an invalid texture or uniform block."],[12,"ErrorParamUniform","","Error from a uniform value",0],[12,"ErrorParamBlock","","Error from a uniform block.",0],[12,"ErrorParamTexture","","Error from a texture.",0],[12,"ErrorParamSampler","","Error from a sampler",0],[2,"MeshError","","An error with a defined Mesh."],[12,"ErrorAttributeMissing","","A required attribute was missing.",1],[12,"ErrorAttributeType","","An attribute's type from the vertex format differed from the type used in the shader.",1],[2,"DrawError","","An error that can happen when trying to draw."],[12,"ErrorProgram","","Error with a program.",2],[12,"ErrorParameter","","Error with the program shell.",2],[12,"ErrorMesh","","Error with the mesh.",2],[12,"ErrorSlice","","Error with the mesh slice",2],[2,"ProgramError","","Program linking error"],[12,"ErrorVertex","","Unable to compile the vertex shader",3],[12,"ErrorFragment","","Unable to compile the fragment shader",3],[12,"ErrorLink","","Unable to link",3],[12,"ErrorParameters","","Unable to connect parameters",3],[6,"DeviceHelper","","Backend extension trait for convenience methods"],[9,"create_renderer","","Create a new renderer",15],[9,"create_mesh","","Create a new mesh from the given vertex data.\nConvenience function around `create_buffer` and `Mesh::from`.",15],[9,"link_program","","Create a simple program given a vertex shader with a fragment one.\nThe return type can not be derived from the arguments, so you need to\nprovide it explicitly:",15],[1,"Renderer","","Renderer front-end"],[6,"DeviceHelper","gfx","Backend extension trait for convenience methods"],[9,"create_renderer","","Create a new renderer",15],[9,"create_mesh","","Create a new mesh from the given vertex data.\nConvenience function around `create_buffer` and `Mesh::from`.",15],[9,"link_program","","Create a simple program given a vertex shader with a fragment one.\nThe return type can not be derived from the arguments, so you need to\nprovide it explicitly:",15],[1,"Renderer","","Renderer front-end"],[1,"Attribute","","Describes a single attribute of a vertex buffer, including its type, name, etc."],[11,"buffer","","Vertex buffer to contain the data",5],[11,"elem_count","","Number of elements per vertex",5],[11,"elem_type","","Type of a single element",5],[11,"offset","","Offset in bytes to the first vertex",5],[11,"stride","","Stride in bytes between consecutive vertices",5],[11,"name","","A name to match the shader input",5],[1,"Mesh","","Describes geometry to render."],[11,"num_vertices","","Number of vertices in the mesh.",6],[11,"attributes","","Vertex attributes to use.",6],[6,"VertexFormat","","A trait implemented automatically for user vertex structure by\n`#[vertex_format] attribute"],[9,"generate","","Create the attributes for this type, using the given buffer.",16],[2,"Slice","","Description of a subset of `Mesh` data to render.\nWe provide a primitive type in a slice because it is how we interpret mesh\ncontents. For example, we can have a `Point` typed vertex slice to do shape\nblending, while still rendereing it as an indexed `TriangleList`."],[12,"VertexSlice","","Render vertex data directly from the `Mesh`'s buffer, using only the vertices between the two\nendpoints.",7],[12,"IndexSlice8","","The `IndexSlice*` buffer contains a list of indices into the `Mesh` data, so every vertex\nattribute does not need to be duplicated, only its position in the `Mesh`.  For example,\nwhen drawing a square, two triangles are needed.  Using only `VertexSlice`, one would need\n6 separate vertices, 3 for each triangle. However, two of the vertices will be identical,\nwasting space for the duplicated attributes.  Instead, the `Mesh` can store 4 vertices and\nan `IndexSlice8` can be used instead.",7],[12,"IndexSlice16","","As `IndexSlice8` but with `u16` indices",7],[12,"IndexSlice32","","As `IndexSlice8` but with `u32` indices",7],[1,"DrawState","","An assembly of states that affect regular draw calls"],[11,"primitive","","How to rasterize geometric primitives.",11],[11,"scissor","","Stencil mask to use. If set, no pixel outside of this rectangle (in screen space) will be\nwritten to as a result of rendering.",11],[11,"stencil","","Stencil test to use. If None, no stencil testing is done.",11],[11,"depth","","Depth test to use. If None, no depth testing is done.",11],[11,"blend","","Blend function to use. If None, no blending is done.",11],[11,"color_mask","","Color mask to use. Each flag indicates that the given color channel can be written to, and\nthey can be OR'd together.",11],[0,"shade","","Shaders\nShader parameter handling."],[6,"ToUniform","gfx::shade","Helper trait to transform base types into their corresponding uniforms"],[9,"to_uniform","","Create a `UniformValue` representing this value.",17],[4,"VarUniform","",""],[4,"VarBlock","",""],[4,"VarTexture","",""],[4,"TextureParam","",""],[1,"ParamValues","","A borrowed mutable storage for shader parameter values."],[11,"uniforms","","uniform values to be provided",18],[11,"blocks","","uniform buffers to be provided",18],[11,"textures","","textures to be provided",18],[6,"Program","","Encloses a shader program handle with its parameter"],[9,"get_handle","","Get the contained program handle",19],[9,"fill_params","","Get all the contained parameter values",19],[2,"ParameterError","","An error type on either the parameter storage or the program side"],[12,"ErrorInternal","","Internal error",8],[12,"ErrorUniform","","Error with the named uniform",8],[12,"ErrorBlock","","Error with the named uniform block",8],[12,"ErrorTexture","","Error with the named texture.",8],[6,"ShaderParam","","Abstracts the shader parameter structure, generated by the `shader_param` attribute"],[9,"create_link","","Creates a new link, self is passed as a workaround for Rust to not be lost in generics",20],[9,"fill_params","","Get all the contained parameter values, using a given link.",20],[1,"UserProgram","","A bundle that encapsulates a program and a custom user-provided\nstructure containing the program parameters.\n# Type parameters:"],[4,"EmptyProgram","",""],[1,"NamedCell","","A named cell containing arbitrary value"],[11,"name","","Name",21],[11,"value","","Value",21],[1,"ParamDictionary","","A dictionary of parameters, meant to be shared between different programs"],[11,"uniforms","","Uniform dictionary",22],[11,"blocks","","Block dictionary",22],[11,"textures","","Texture dictionary",22],[1,"ParamDictionaryLink","","An associated link structure for `ParamDictionary` that redirects program\ninput to the relevant dictionary cell."],[1,"DictionaryProgram","","A shader program with dictionary of parameters"],[1,"Frame","gfx","A complete `Frame`, which is the result of rendering."],[11,"width","","The width of the viewport.",14],[11,"height","","The height of the viewport.",14],[11,"colors","","Each color component has its own buffer.",14],[11,"depth","","The depth buffer for this frame.",14],[11,"stencil","","The stencil buffer for this frame.",14],[2,"Plane","","A single buffer that can be bound to a render target."],[12,"PlaneEmpty","","No buffer, the results will not be stored.",13],[12,"PlaneSurface","","Render to a `Surface` (corresponds to a renderbuffer in GL).",13],[12,"PlaneTexture","","Render to a texture at a specific mipmap level\nIf `Layer` is set, it is selecting a single 2D slice of a given 3D texture",13],[6,"Device","","An interface for performing draw calls using a specific graphics API"],[9,"get_capabilities","","Returns the capabilities available to the specific API implementation",23],[9,"create_buffer_raw","","",23],[9,"create_buffer","","",23],[9,"create_buffer_static","","",23],[9,"create_array_buffer","","",23],[9,"create_shader","","",23],[9,"create_program","","",23],[9,"create_frame_buffer","","",23],[9,"create_surface","","",23],[9,"create_texture","","",23],[9,"create_sampler","","",23],[9,"delete_buffer_raw","","",23],[9,"delete_buffer","","",23],[9,"delete_shader","","",23],[9,"delete_program","","",23],[9,"delete_surface","","",23],[9,"delete_texture","","",23],[9,"delete_sampler","","",23],[9,"update_buffer_raw","","Update the information stored in a specific buffer",23],[9,"update_buffer","","",23],[9,"update_texture_raw","","Update the information stored in a texture",23],[9,"update_texture","","",23],[9,"generate_mipmap","","",23],[9,"submit","","Submit a command buffer for execution",23],[10,"new","device::gl","Load OpenGL symbols and detect driver information",24],[10,"get_info","","Get the OpenGL-specific driver information",24],[10,"fmt","device::attrib","",25],[10,"clone","","",25],[10,"clone_from","","",25],[10,"hash","","",25],[10,"partial_cmp","","",25],[10,"lt","","",25],[10,"le","","",25],[10,"gt","","",25],[10,"ge","","",25],[10,"lt","","",25],[10,"le","","",25],[10,"gt","","",25],[10,"ge","","",25],[10,"eq","","",25],[10,"ne","","",25],[10,"ne","","",25],[10,"cmp","","",25],[10,"assert_receiver_is_total_eq","","",25],[10,"fmt","","",26],[10,"clone","","",26],[10,"clone_from","","",26],[10,"hash","","",26],[10,"partial_cmp","","",26],[10,"lt","","",26],[10,"le","","",26],[10,"gt","","",26],[10,"ge","","",26],[10,"lt","","",26],[10,"le","","",26],[10,"gt","","",26],[10,"ge","","",26],[10,"eq","","",26],[10,"ne","","",26],[10,"ne","","",26],[10,"cmp","","",26],[10,"assert_receiver_is_total_eq","","",26],[10,"fmt","","",27],[10,"clone","","",27],[10,"clone_from","","",27],[10,"hash","","",27],[10,"partial_cmp","","",27],[10,"lt","","",27],[10,"le","","",27],[10,"gt","","",27],[10,"ge","","",27],[10,"lt","","",27],[10,"le","","",27],[10,"gt","","",27],[10,"ge","","",27],[10,"eq","","",27],[10,"ne","","",27],[10,"ne","","",27],[10,"cmp","","",27],[10,"assert_receiver_is_total_eq","","",27],[10,"fmt","","",28],[10,"clone","","",28],[10,"clone_from","","",28],[10,"hash","","",28],[10,"partial_cmp","","",28],[10,"lt","","",28],[10,"le","","",28],[10,"gt","","",28],[10,"ge","","",28],[10,"lt","","",28],[10,"le","","",28],[10,"gt","","",28],[10,"ge","","",28],[10,"eq","","",28],[10,"ne","","",28],[10,"ne","","",28],[10,"cmp","","",28],[10,"assert_receiver_is_total_eq","","",28],[10,"fmt","","",29],[10,"clone","","",29],[10,"clone_from","","",29],[10,"hash","","",29],[10,"partial_cmp","","",29],[10,"lt","","",29],[10,"le","","",29],[10,"gt","","",29],[10,"ge","","",29],[10,"lt","","",29],[10,"le","","",29],[10,"gt","","",29],[10,"ge","","",29],[10,"eq","","",29],[10,"ne","","",29],[10,"ne","","",29],[10,"cmp","","",29],[10,"assert_receiver_is_total_eq","","",29],[10,"fmt","","",30],[10,"clone","","",30],[10,"clone_from","","",30],[10,"hash","","",30],[10,"partial_cmp","","",30],[10,"lt","","",30],[10,"le","","",30],[10,"gt","","",30],[10,"ge","","",30],[10,"lt","","",30],[10,"le","","",30],[10,"gt","","",30],[10,"ge","","",30],[10,"eq","","",30],[10,"ne","","",30],[10,"ne","","",30],[10,"cmp","","",30],[10,"assert_receiver_is_total_eq","","",30],[10,"is_compatible","","",30],[10,"fmt","device::shade","",31],[10,"eq","","",31],[10,"ne","","",31],[10,"ne","","",31],[10,"clone","","",31],[10,"clone_from","","",31],[10,"fmt","","",32],[10,"eq","","",32],[10,"ne","","",32],[10,"ne","","",32],[10,"clone","","",32],[10,"clone_from","","",32],[10,"fmt","","",33],[10,"eq","","",33],[10,"ne","","",33],[10,"ne","","",33],[10,"clone","","",33],[10,"clone_from","","",33],[10,"fmt","","",34],[10,"eq","","",34],[10,"ne","","",34],[10,"ne","","",34],[10,"clone","","",34],[10,"clone_from","","",34],[10,"fmt","","",35],[10,"eq","","",35],[10,"ne","","",35],[10,"ne","","",35],[10,"clone","","",35],[10,"clone_from","","",35],[10,"fmt","","",36],[10,"eq","","",36],[10,"ne","","",36],[10,"ne","","",36],[10,"clone","","",36],[10,"clone_from","","",36],[10,"fmt","","",37],[10,"eq","","",37],[10,"ne","","",37],[10,"ne","","",37],[10,"clone","","",37],[10,"clone_from","","",37],[10,"fmt","","",38],[10,"eq","","",38],[10,"ne","","",38],[10,"ne","","",38],[10,"clone","","",38],[10,"clone_from","","",38],[10,"fmt","","",39],[10,"is_same_type","","Whether two `UniformValue`s have the same type.",40],[10,"clone","","",40],[10,"clone_from","","",40],[10,"fmt","","",40],[10,"fmt","","",41],[10,"clone","","",41],[10,"clone_from","","",41],[10,"fmt","","",42],[10,"clone","","",42],[10,"clone_from","","",42],[10,"fmt","","",43],[10,"clone","","",43],[10,"clone_from","","",43],[10,"fmt","","",44],[10,"clone","","",44],[10,"clone_from","","",44],[10,"fmt","","",45],[10,"clone","","",45],[10,"clone_from","","",45],[10,"fmt","","",46],[10,"is_compatible","","Whether a value is compatible with this variable. That is, whether the value can be stored\nin this variable.",42],[10,"clone","","",47],[10,"clone_from","","",47],[10,"eq","","",47],[10,"ne","","",47],[10,"ne","","",47],[10,"fmt","","",47],[10,"as_slice","","Get the byte data as a slice.",47],[10,"fmt","","",48],[10,"eq","","",48],[10,"ne","","",48],[10,"ne","","",48],[10,"clone","","",48],[10,"clone_from","","",48],[10,"fmt","","",49],[10,"eq","","",49],[10,"ne","","",49],[10,"ne","","",49],[10,"clone","","",49],[10,"clone_from","","",49],[10,"fmt","","",50],[10,"partial_cmp","","",50],[10,"lt","","",50],[10,"le","","",50],[10,"gt","","",50],[10,"ge","","",50],[10,"lt","","",50],[10,"le","","",50],[10,"gt","","",50],[10,"ge","","",50],[10,"eq","","",50],[10,"ne","","",50],[10,"ne","","",50],[10,"clone","","",50],[10,"clone_from","","",50],[10,"to_number","","Return the shader model as a numeric value.",50],[10,"fmt","device::state","",51],[10,"eq","","",51],[10,"ne","","",51],[10,"ne","","",51],[10,"clone","","",51],[10,"clone_from","","",51],[10,"fmt","","",52],[10,"eq","","",52],[10,"ne","","",52],[10,"ne","","",52],[10,"clone","","",52],[10,"clone_from","","",52],[10,"fmt","","",53],[10,"eq","","",53],[10,"ne","","",53],[10,"ne","","",53],[10,"clone","","",53],[10,"clone_from","","",53],[10,"fmt","","",54],[10,"eq","","",54],[10,"ne","","",54],[10,"ne","","",54],[10,"clone","","",54],[10,"clone_from","","",54],[10,"fmt","","",55],[10,"eq","","",55],[10,"ne","","",55],[10,"ne","","",55],[10,"clone","","",55],[10,"clone_from","","",55],[10,"get_cull_mode","","Get the cull mode, if any, for this primitive state.",55],[10,"default","","",55],[10,"fmt","","",56],[10,"eq","","",56],[10,"ne","","",56],[10,"ne","","",56],[10,"clone","","",56],[10,"clone_from","","",56],[10,"fmt","","",57],[10,"eq","","",57],[10,"ne","","",57],[10,"ne","","",57],[10,"clone","","",57],[10,"clone_from","","",57],[10,"fmt","","",58],[10,"eq","","",58],[10,"ne","","",58],[10,"ne","","",58],[10,"clone","","",58],[10,"clone_from","","",58],[10,"default","","",58],[10,"fmt","","",59],[10,"eq","","",59],[10,"ne","","",59],[10,"ne","","",59],[10,"clone","","",59],[10,"clone_from","","",59],[10,"fmt","","",60],[10,"eq","","",60],[10,"ne","","",60],[10,"ne","","",60],[10,"clone","","",60],[10,"clone_from","","",60],[10,"default","","",60],[10,"fmt","","",61],[10,"eq","","",61],[10,"ne","","",61],[10,"ne","","",61],[10,"clone","","",61],[10,"clone_from","","",61],[10,"fmt","","",62],[10,"eq","","",62],[10,"ne","","",62],[10,"ne","","",62],[10,"clone","","",62],[10,"clone_from","","",62],[10,"fmt","","",63],[10,"eq","","",63],[10,"ne","","",63],[10,"ne","","",63],[10,"clone","","",63],[10,"clone_from","","",63],[10,"fmt","","",64],[10,"eq","","",64],[10,"ne","","",64],[10,"ne","","",64],[10,"clone","","",64],[10,"clone_from","","",64],[10,"fmt","","",65],[10,"eq","","",65],[10,"ne","","",65],[10,"ne","","",65],[10,"clone","","",65],[10,"clone_from","","",65],[10,"default","","",65],[10,"default","","",66],[10,"eq","","",66],[10,"ne","","",66],[10,"clone","","",66],[10,"clone_from","","",66],[10,"fmt","","",66],[10,"hash","","",67],[10,"cmp","","",67],[10,"partial_cmp","","",67],[10,"lt","","",67],[10,"le","","",67],[10,"gt","","",67],[10,"ge","","",67],[10,"lt","","",67],[10,"le","","",67],[10,"gt","","",67],[10,"ge","","",67],[10,"clone","","",67],[10,"clone_from","","",67],[10,"assert_receiver_is_total_eq","","",67],[10,"eq","","",67],[10,"ne","","",67],[10,"ne","","",67],[10,"empty","","Returns an empty set of flags.",67],[10,"all","","Returns the set containing all flags.",67],[10,"bits","","Returns the raw value of the flags currently stored.",67],[10,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",67],[10,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",67],[10,"is_empty","","Returns `true` if no flags are currently stored.",67],[10,"is_all","","Returns `true` if all flags are currently set.",67],[10,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",67],[10,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",67],[10,"insert","","Inserts the specified flags in-place.",67],[10,"remove","","Removes the specified flags in-place.",67],[10,"bitor","","Returns the union of the two sets of flags.",67],[10,"bitand","","Returns the intersection between the two sets of flags.",67],[10,"sub","","Returns the set difference of the two sets of flags.",67],[10,"not","","Returns the complement of this set of flags.",67],[10,"fmt","","",67],[10,"fmt","device::target","",68],[10,"eq","","",68],[10,"ne","","",68],[10,"ne","","",68],[10,"clone","","",68],[10,"clone_from","","",68],[10,"clone","","",69],[10,"clone_from","","",69],[10,"fmt","","",69],[10,"fmt","","",70],[10,"clone","","",70],[10,"clone_from","","",70],[10,"fmt","device::tex","",71],[10,"eq","","",71],[10,"ne","","",71],[10,"ne","","",71],[10,"clone","","",71],[10,"clone_from","","",71],[10,"fmt","","",72],[10,"eq","","",72],[10,"ne","","",72],[10,"ne","","",72],[10,"clone","","",72],[10,"clone_from","","",72],[10,"fmt","","",73],[10,"clone","","",73],[10,"clone_from","","",73],[10,"hash","","",73],[10,"partial_cmp","","",73],[10,"lt","","",73],[10,"le","","",73],[10,"gt","","",73],[10,"ge","","",73],[10,"lt","","",73],[10,"le","","",73],[10,"gt","","",73],[10,"ge","","",73],[10,"eq","","",73],[10,"ne","","",73],[10,"ne","","",73],[10,"cmp","","",73],[10,"assert_receiver_is_total_eq","","",73],[10,"fmt","","",74],[10,"clone","","",74],[10,"clone_from","","",74],[10,"hash","","",74],[10,"partial_cmp","","",74],[10,"lt","","",74],[10,"le","","",74],[10,"gt","","",74],[10,"ge","","",74],[10,"lt","","",74],[10,"le","","",74],[10,"gt","","",74],[10,"ge","","",74],[10,"eq","","",74],[10,"ne","","",74],[10,"ne","","",74],[10,"cmp","","",74],[10,"assert_receiver_is_total_eq","","",74],[10,"fmt","","",75],[10,"clone","","",75],[10,"clone_from","","",75],[10,"hash","","",75],[10,"partial_cmp","","",75],[10,"lt","","",75],[10,"le","","",75],[10,"gt","","",75],[10,"ge","","",75],[10,"lt","","",75],[10,"le","","",75],[10,"gt","","",75],[10,"ge","","",75],[10,"eq","","",75],[10,"ne","","",75],[10,"ne","","",75],[10,"cmp","","",75],[10,"assert_receiver_is_total_eq","","",75],[10,"fmt","","",76],[10,"clone","","",76],[10,"clone_from","","",76],[10,"hash","","",76],[10,"partial_cmp","","",76],[10,"lt","","",76],[10,"le","","",76],[10,"gt","","",76],[10,"ge","","",76],[10,"lt","","",76],[10,"le","","",76],[10,"gt","","",76],[10,"ge","","",76],[10,"eq","","",76],[10,"ne","","",76],[10,"ne","","",76],[10,"cmp","","",76],[10,"assert_receiver_is_total_eq","","",76],[10,"fmt","","",77],[10,"clone","","",77],[10,"clone_from","","",77],[10,"hash","","",77],[10,"partial_cmp","","",77],[10,"lt","","",77],[10,"le","","",77],[10,"gt","","",77],[10,"ge","","",77],[10,"lt","","",77],[10,"le","","",77],[10,"gt","","",77],[10,"ge","","",77],[10,"eq","","",77],[10,"ne","","",77],[10,"ne","","",77],[10,"cmp","","",77],[10,"assert_receiver_is_total_eq","","",77],[10,"fmt","","",78],[10,"clone","","",78],[10,"clone_from","","",78],[10,"hash","","",78],[10,"partial_cmp","","",78],[10,"lt","","",78],[10,"le","","",78],[10,"gt","","",78],[10,"ge","","",78],[10,"lt","","",78],[10,"le","","",78],[10,"gt","","",78],[10,"ge","","",78],[10,"eq","","",78],[10,"ne","","",78],[10,"ne","","",78],[10,"cmp","","",78],[10,"assert_receiver_is_total_eq","","",78],[10,"fmt","","",79],[10,"clone","","",79],[10,"clone_from","","",79],[10,"hash","","",79],[10,"partial_cmp","","",79],[10,"lt","","",79],[10,"le","","",79],[10,"gt","","",79],[10,"ge","","",79],[10,"lt","","",79],[10,"le","","",79],[10,"gt","","",79],[10,"ge","","",79],[10,"eq","","",79],[10,"ne","","",79],[10,"ne","","",79],[10,"cmp","","",79],[10,"assert_receiver_is_total_eq","","",79],[10,"default","","",79],[10,"default","","",78],[10,"new","","Create a new empty texture info",78],[10,"to_image_info","","Convert to a default ImageInfo that could be used\nto update the contents of the whole texture",78],[10,"contains","","Check if given ImageInfo is a part of the texture",78],[10,"new","","Create a new `ImageInfo`, using default values.",79],[10,"fmt","","",80],[10,"clone","","",80],[10,"clone_from","","",80],[10,"hash","","",80],[10,"partial_cmp","","",80],[10,"lt","","",80],[10,"le","","",80],[10,"gt","","",80],[10,"ge","","",80],[10,"lt","","",80],[10,"le","","",80],[10,"gt","","",80],[10,"ge","","",80],[10,"eq","","",80],[10,"ne","","",80],[10,"ne","","",80],[10,"cmp","","",80],[10,"assert_receiver_is_total_eq","","",80],[10,"fmt","","",81],[10,"clone","","",81],[10,"clone_from","","",81],[10,"partial_cmp","","",81],[10,"lt","","",81],[10,"le","","",81],[10,"gt","","",81],[10,"ge","","",81],[10,"lt","","",81],[10,"le","","",81],[10,"gt","","",81],[10,"ge","","",81],[10,"eq","","",81],[10,"ne","","",81],[10,"ne","","",81],[10,"new","","Create a new sampler description with a given filter method and wrapping mode, using no LOD\nmodifications.",81],[10,"iter","device::gl::draw","",82],[10,"new","","",82],[10,"clear","","",82],[10,"bind_program","","",82],[10,"bind_array_buffer","","",82],[10,"bind_attribute","","",82],[10,"bind_index","","",82],[10,"bind_frame_buffer","","",82],[10,"unbind_target","","",82],[10,"bind_target_surface","","",82],[10,"bind_target_texture","","",82],[10,"bind_uniform_block","","",82],[10,"bind_uniform","","",82],[10,"bind_texture","","",82],[10,"set_primitive","","",82],[10,"set_viewport","","",82],[10,"set_scissor","","",82],[10,"set_depth_stencil","","",82],[10,"set_blend","","",82],[10,"set_color_mask","","",82],[10,"update_buffer","","",82],[10,"update_texture","","",82],[10,"call_clear","","",82],[10,"call_draw","","",82],[10,"call_draw_indexed","","",82],[10,"partial_cmp","device::gl::info","",83],[10,"lt","","",83],[10,"le","","",83],[10,"gt","","",83],[10,"ge","","",83],[10,"lt","","",83],[10,"le","","",83],[10,"gt","","",83],[10,"ge","","",83],[10,"cmp","","",83],[10,"eq","","",83],[10,"ne","","",83],[10,"ne","","",83],[10,"assert_receiver_is_total_eq","","",83],[10,"new","","Create a new OpenGL version number",83],[10,"parse","","According to the OpenGL specification, the version information is\nexpected to follow the following syntax:",83],[10,"fmt","","",83],[10,"fmt","","",84],[10,"eq","","",84],[10,"ne","","",84],[10,"ne","","",84],[10,"assert_receiver_is_total_eq","","",84],[10,"fmt","","",85],[10,"is_extension_supported","","Returns `true` if the implementation supports the extension",85],[10,"is_loaded","device::gl::gl","",86],[10,"load_with","","Load each OpenGL symbol using a custom load function. This allows for the\nuse of functions like `glfwGetProcAddress` or `SDL_GL_GetProcAddress`.",87],[10,"ActiveShaderProgram","","",87],[10,"ActiveTexture","","",87],[10,"AttachShader","","",87],[10,"BeginConditionalRender","","",87],[10,"BeginQuery","","",87],[10,"BeginQueryIndexed","","",87],[10,"BeginTransformFeedback","","",87],[10,"BindAttribLocation","","",87],[10,"BindBuffer","","",87],[10,"BindBufferBase","","",87],[10,"BindBufferRange","","",87],[10,"BindBuffersBase","","",87],[10,"BindBuffersRange","","",87],[10,"BindFragDataLocation","","",87],[10,"BindFragDataLocationIndexed","","",87],[10,"BindFramebuffer","","",87],[10,"BindImageTexture","","",87],[10,"BindImageTextures","","",87],[10,"BindProgramPipeline","","",87],[10,"BindRenderbuffer","","",87],[10,"BindSampler","","",87],[10,"BindSamplers","","",87],[10,"BindTexture","","",87],[10,"BindTextureUnit","","",87],[10,"BindTextures","","",87],[10,"BindTransformFeedback","","",87],[10,"BindVertexArray","","",87],[10,"BindVertexBuffer","","",87],[10,"BindVertexBuffers","","",87],[10,"BlendColor","","",87],[10,"BlendEquation","","",87],[10,"BlendEquationSeparate","","",87],[10,"BlendEquationSeparatei","","",87],[10,"BlendEquationi","","",87],[10,"BlendFunc","","",87],[10,"BlendFuncSeparate","","",87],[10,"BlendFuncSeparatei","","",87],[10,"BlendFunci","","",87],[10,"BlitFramebuffer","","",87],[10,"BlitNamedFramebuffer","","",87],[10,"BufferData","","",87],[10,"BufferStorage","","",87],[10,"BufferSubData","","",87],[10,"CheckFramebufferStatus","","",87],[10,"CheckNamedFramebufferStatus","","",87],[10,"ClampColor","","",87],[10,"Clear","","",87],[10,"ClearBufferData","","",87],[10,"ClearBufferSubData","","",87],[10,"ClearBufferfi","","",87],[10,"ClearBufferfv","","",87],[10,"ClearBufferiv","","",87],[10,"ClearBufferuiv","","",87],[10,"ClearColor","","",87],[10,"ClearDepth","","",87],[10,"ClearDepthf","","",87],[10,"ClearNamedBufferData","","",87],[10,"ClearNamedBufferSubData","","",87],[10,"ClearNamedFramebufferfi","","",87],[10,"ClearNamedFramebufferfv","","",87],[10,"ClearNamedFramebufferiv","","",87],[10,"ClearNamedFramebufferuiv","","",87],[10,"ClearStencil","","",87],[10,"ClearTexImage","","",87],[10,"ClearTexSubImage","","",87],[10,"ClientWaitSync","","",87],[10,"ClipControl","","",87],[10,"ColorMask","","",87],[10,"ColorMaski","","",87],[10,"ColorP3ui","","",87],[10,"ColorP3uiv","","",87],[10,"ColorP4ui","","",87],[10,"ColorP4uiv","","",87],[10,"CompileShader","","",87],[10,"CompressedTexImage1D","","",87],[10,"CompressedTexImage2D","","",87],[10,"CompressedTexImage3D","","",87],[10,"CompressedTexSubImage1D","","",87],[10,"CompressedTexSubImage2D","","",87],[10,"CompressedTexSubImage3D","","",87],[10,"CompressedTextureSubImage1D","","",87],[10,"CompressedTextureSubImage2D","","",87],[10,"CompressedTextureSubImage3D","","",87],[10,"CopyBufferSubData","","",87],[10,"CopyImageSubData","","",87],[10,"CopyNamedBufferSubData","","",87],[10,"CopyTexImage1D","","",87],[10,"CopyTexImage2D","","",87],[10,"CopyTexSubImage1D","","",87],[10,"CopyTexSubImage2D","","",87],[10,"CopyTexSubImage3D","","",87],[10,"CopyTextureSubImage1D","","",87],[10,"CopyTextureSubImage2D","","",87],[10,"CopyTextureSubImage3D","","",87],[10,"CreateBuffers","","",87],[10,"CreateFramebuffers","","",87],[10,"CreateProgram","","",87],[10,"CreateProgramPipelines","","",87],[10,"CreateQueries","","",87],[10,"CreateRenderbuffers","","",87],[10,"CreateSamplers","","",87],[10,"CreateShader","","",87],[10,"CreateShaderProgramv","","",87],[10,"CreateTextures","","",87],[10,"CreateTransformFeedbacks","","",87],[10,"CreateVertexArrays","","",87],[10,"CullFace","","",87],[10,"DebugMessageCallback","","",87],[10,"DebugMessageControl","","",87],[10,"DebugMessageInsert","","",87],[10,"DeleteBuffers","","",87],[10,"DeleteFramebuffers","","",87],[10,"DeleteProgram","","",87],[10,"DeleteProgramPipelines","","",87],[10,"DeleteQueries","","",87],[10,"DeleteRenderbuffers","","",87],[10,"DeleteSamplers","","",87],[10,"DeleteShader","","",87],[10,"DeleteSync","","",87],[10,"DeleteTextures","","",87],[10,"DeleteTransformFeedbacks","","",87],[10,"DeleteVertexArrays","","",87],[10,"DepthFunc","","",87],[10,"DepthMask","","",87],[10,"DepthRange","","",87],[10,"DepthRangeArrayv","","",87],[10,"DepthRangeIndexed","","",87],[10,"DepthRangef","","",87],[10,"DetachShader","","",87],[10,"Disable","","",87],[10,"DisableVertexArrayAttrib","","",87],[10,"DisableVertexAttribArray","","",87],[10,"Disablei","","",87],[10,"DispatchCompute","","",87],[10,"DispatchComputeIndirect","","",87],[10,"DrawArrays","","",87],[10,"DrawArraysIndirect","","",87],[10,"DrawArraysInstanced","","",87],[10,"DrawArraysInstancedBaseInstance","","",87],[10,"DrawBuffer","","",87],[10,"DrawBuffers","","",87],[10,"DrawElements","","",87],[10,"DrawElementsBaseVertex","","",87],[10,"DrawElementsIndirect","","",87],[10,"DrawElementsInstanced","","",87],[10,"DrawElementsInstancedBaseInstance","","",87],[10,"DrawElementsInstancedBaseVertex","","",87],[10,"DrawElementsInstancedBaseVertexBaseInstance","","",87],[10,"DrawRangeElements","","",87],[10,"DrawRangeElementsBaseVertex","","",87],[10,"DrawTransformFeedback","","",87],[10,"DrawTransformFeedbackInstanced","","",87],[10,"DrawTransformFeedbackStream","","",87],[10,"DrawTransformFeedbackStreamInstanced","","",87],[10,"Enable","","",87],[10,"EnableVertexArrayAttrib","","",87],[10,"EnableVertexAttribArray","","",87],[10,"Enablei","","",87],[10,"EndConditionalRender","","",87],[10,"EndQuery","","",87],[10,"EndQueryIndexed","","",87],[10,"EndTransformFeedback","","",87],[10,"FenceSync","","",87],[10,"Finish","","",87],[10,"Flush","","",87],[10,"FlushMappedBufferRange","","",87],[10,"FlushMappedNamedBufferRange","","",87],[10,"FramebufferParameteri","","",87],[10,"FramebufferRenderbuffer","","",87],[10,"FramebufferTexture","","",87],[10,"FramebufferTexture1D","","",87],[10,"FramebufferTexture2D","","",87],[10,"FramebufferTexture3D","","",87],[10,"FramebufferTextureLayer","","",87],[10,"FrontFace","","",87],[10,"GenBuffers","","",87],[10,"GenFramebuffers","","",87],[10,"GenProgramPipelines","","",87],[10,"GenQueries","","",87],[10,"GenRenderbuffers","","",87],[10,"GenSamplers","","",87],[10,"GenTextures","","",87],[10,"GenTransformFeedbacks","","",87],[10,"GenVertexArrays","","",87],[10,"GenerateMipmap","","",87],[10,"GenerateTextureMipmap","","",87],[10,"GetActiveAtomicCounterBufferiv","","",87],[10,"GetActiveAttrib","","",87],[10,"GetActiveSubroutineName","","",87],[10,"GetActiveSubroutineUniformName","","",87],[10,"GetActiveSubroutineUniformiv","","",87],[10,"GetActiveUniform","","",87],[10,"GetActiveUniformBlockName","","",87],[10,"GetActiveUniformBlockiv","","",87],[10,"GetActiveUniformName","","",87],[10,"GetActiveUniformsiv","","",87],[10,"GetAttachedShaders","","",87],[10,"GetAttribLocation","","",87],[10,"GetBooleani_v","","",87],[10,"GetBooleanv","","",87],[10,"GetBufferParameteri64v","","",87],[10,"GetBufferParameteriv","","",87],[10,"GetBufferPointerv","","",87],[10,"GetBufferSubData","","",87],[10,"GetCompressedTexImage","","",87],[10,"GetCompressedTextureImage","","",87],[10,"GetCompressedTextureSubImage","","",87],[10,"GetDebugMessageLog","","",87],[10,"GetDoublei_v","","",87],[10,"GetDoublev","","",87],[10,"GetError","","",87],[10,"GetFloati_v","","",87],[10,"GetFloatv","","",87],[10,"GetFragDataIndex","","",87],[10,"GetFragDataLocation","","",87],[10,"GetFramebufferAttachmentParameteriv","","",87],[10,"GetFramebufferParameteriv","","",87],[10,"GetGraphicsResetStatus","","",87],[10,"GetInteger64i_v","","",87],[10,"GetInteger64v","","",87],[10,"GetIntegeri_v","","",87],[10,"GetIntegerv","","",87],[10,"GetInternalformati64v","","",87],[10,"GetInternalformativ","","",87],[10,"GetMultisamplefv","","",87],[10,"GetNamedBufferParameteri64v","","",87],[10,"GetNamedBufferParameteriv","","",87],[10,"GetNamedBufferPointerv","","",87],[10,"GetNamedBufferSubData","","",87],[10,"GetNamedFramebufferAttachmentParameteriv","","",87],[10,"GetNamedFramebufferParameteriv","","",87],[10,"GetNamedRenderbufferParameteriv","","",87],[10,"GetObjectLabel","","",87],[10,"GetObjectPtrLabel","","",87],[10,"GetProgramBinary","","",87],[10,"GetProgramInfoLog","","",87],[10,"GetProgramInterfaceiv","","",87],[10,"GetProgramPipelineInfoLog","","",87],[10,"GetProgramPipelineiv","","",87],[10,"GetProgramResourceIndex","","",87],[10,"GetProgramResourceLocation","","",87],[10,"GetProgramResourceLocationIndex","","",87],[10,"GetProgramResourceName","","",87],[10,"GetProgramResourceiv","","",87],[10,"GetProgramStageiv","","",87],[10,"GetProgramiv","","",87],[10,"GetQueryIndexediv","","",87],[10,"GetQueryObjecti64v","","",87],[10,"GetQueryObjectiv","","",87],[10,"GetQueryObjectui64v","","",87],[10,"GetQueryObjectuiv","","",87],[10,"GetQueryiv","","",87],[10,"GetRenderbufferParameteriv","","",87],[10,"GetSamplerParameterIiv","","",87],[10,"GetSamplerParameterIuiv","","",87],[10,"GetSamplerParameterfv","","",87],[10,"GetSamplerParameteriv","","",87],[10,"GetShaderInfoLog","","",87],[10,"GetShaderPrecisionFormat","","",87],[10,"GetShaderSource","","",87],[10,"GetShaderiv","","",87],[10,"GetString","","",87],[10,"GetStringi","","",87],[10,"GetSubroutineIndex","","",87],[10,"GetSubroutineUniformLocation","","",87],[10,"GetSynciv","","",87],[10,"GetTexImage","","",87],[10,"GetTexLevelParameterfv","","",87],[10,"GetTexLevelParameteriv","","",87],[10,"GetTexParameterIiv","","",87],[10,"GetTexParameterIuiv","","",87],[10,"GetTexParameterfv","","",87],[10,"GetTexParameteriv","","",87],[10,"GetTextureImage","","",87],[10,"GetTextureLevelParameterfv","","",87],[10,"GetTextureLevelParameteriv","","",87],[10,"GetTextureParameterIiv","","",87],[10,"GetTextureParameterIuiv","","",87],[10,"GetTextureParameterfv","","",87],[10,"GetTextureParameteriv","","",87],[10,"GetTextureSubImage","","",87],[10,"GetTransformFeedbackVarying","","",87],[10,"GetTransformFeedbacki64_v","","",87],[10,"GetTransformFeedbacki_v","","",87],[10,"GetTransformFeedbackiv","","",87],[10,"GetUniformBlockIndex","","",87],[10,"GetUniformIndices","","",87],[10,"GetUniformLocation","","",87],[10,"GetUniformSubroutineuiv","","",87],[10,"GetUniformdv","","",87],[10,"GetUniformfv","","",87],[10,"GetUniformiv","","",87],[10,"GetUniformuiv","","",87],[10,"GetVertexArrayIndexed64iv","","",87],[10,"GetVertexArrayIndexediv","","",87],[10,"GetVertexArrayiv","","",87],[10,"GetVertexAttribIiv","","",87],[10,"GetVertexAttribIuiv","","",87],[10,"GetVertexAttribLdv","","",87],[10,"GetVertexAttribPointerv","","",87],[10,"GetVertexAttribdv","","",87],[10,"GetVertexAttribfv","","",87],[10,"GetVertexAttribiv","","",87],[10,"GetnColorTable","","",87],[10,"GetnCompressedTexImage","","",87],[10,"GetnConvolutionFilter","","",87],[10,"GetnHistogram","","",87],[10,"GetnMapdv","","",87],[10,"GetnMapfv","","",87],[10,"GetnMapiv","","",87],[10,"GetnMinmax","","",87],[10,"GetnPixelMapfv","","",87],[10,"GetnPixelMapuiv","","",87],[10,"GetnPixelMapusv","","",87],[10,"GetnPolygonStipple","","",87],[10,"GetnSeparableFilter","","",87],[10,"GetnTexImage","","",87],[10,"GetnUniformdv","","",87],[10,"GetnUniformfv","","",87],[10,"GetnUniformiv","","",87],[10,"GetnUniformuiv","","",87],[10,"Hint","","",87],[10,"InvalidateBufferData","","",87],[10,"InvalidateBufferSubData","","",87],[10,"InvalidateFramebuffer","","",87],[10,"InvalidateNamedFramebufferData","","",87],[10,"InvalidateNamedFramebufferSubData","","",87],[10,"InvalidateSubFramebuffer","","",87],[10,"InvalidateTexImage","","",87],[10,"InvalidateTexSubImage","","",87],[10,"IsBuffer","","",87],[10,"IsEnabled","","",87],[10,"IsEnabledi","","",87],[10,"IsFramebuffer","","",87],[10,"IsProgram","","",87],[10,"IsProgramPipeline","","",87],[10,"IsQuery","","",87],[10,"IsRenderbuffer","","",87],[10,"IsSampler","","",87],[10,"IsShader","","",87],[10,"IsSync","","",87],[10,"IsTexture","","",87],[10,"IsTransformFeedback","","",87],[10,"IsVertexArray","","",87],[10,"LineWidth","","",87],[10,"LinkProgram","","",87],[10,"LogicOp","","",87],[10,"MapBuffer","","",87],[10,"MapBufferRange","","",87],[10,"MapNamedBuffer","","",87],[10,"MapNamedBufferRange","","",87],[10,"MemoryBarrier","","",87],[10,"MemoryBarrierByRegion","","",87],[10,"MinSampleShading","","",87],[10,"MultiDrawArrays","","",87],[10,"MultiDrawArraysIndirect","","",87],[10,"MultiDrawElements","","",87],[10,"MultiDrawElementsBaseVertex","","",87],[10,"MultiDrawElementsIndirect","","",87],[10,"MultiTexCoordP1ui","","",87],[10,"MultiTexCoordP1uiv","","",87],[10,"MultiTexCoordP2ui","","",87],[10,"MultiTexCoordP2uiv","","",87],[10,"MultiTexCoordP3ui","","",87],[10,"MultiTexCoordP3uiv","","",87],[10,"MultiTexCoordP4ui","","",87],[10,"MultiTexCoordP4uiv","","",87],[10,"NamedBufferData","","",87],[10,"NamedBufferStorage","","",87],[10,"NamedBufferSubData","","",87],[10,"NamedFramebufferDrawBuffer","","",87],[10,"NamedFramebufferDrawBuffers","","",87],[10,"NamedFramebufferParameteri","","",87],[10,"NamedFramebufferReadBuffer","","",87],[10,"NamedFramebufferRenderbuffer","","",87],[10,"NamedFramebufferTexture","","",87],[10,"NamedFramebufferTextureLayer","","",87],[10,"NamedRenderbufferStorage","","",87],[10,"NamedRenderbufferStorageMultisample","","",87],[10,"NormalP3ui","","",87],[10,"NormalP3uiv","","",87],[10,"ObjectLabel","","",87],[10,"ObjectPtrLabel","","",87],[10,"PatchParameterfv","","",87],[10,"PatchParameteri","","",87],[10,"PauseTransformFeedback","","",87],[10,"PixelStoref","","",87],[10,"PixelStorei","","",87],[10,"PointParameterf","","",87],[10,"PointParameterfv","","",87],[10,"PointParameteri","","",87],[10,"PointParameteriv","","",87],[10,"PointSize","","",87],[10,"PolygonMode","","",87],[10,"PolygonOffset","","",87],[10,"PopDebugGroup","","",87],[10,"PrimitiveRestartIndex","","",87],[10,"ProgramBinary","","",87],[10,"ProgramParameteri","","",87],[10,"ProgramUniform1d","","",87],[10,"ProgramUniform1dv","","",87],[10,"ProgramUniform1f","","",87],[10,"ProgramUniform1fv","","",87],[10,"ProgramUniform1i","","",87],[10,"ProgramUniform1iv","","",87],[10,"ProgramUniform1ui","","",87],[10,"ProgramUniform1uiv","","",87],[10,"ProgramUniform2d","","",87],[10,"ProgramUniform2dv","","",87],[10,"ProgramUniform2f","","",87],[10,"ProgramUniform2fv","","",87],[10,"ProgramUniform2i","","",87],[10,"ProgramUniform2iv","","",87],[10,"ProgramUniform2ui","","",87],[10,"ProgramUniform2uiv","","",87],[10,"ProgramUniform3d","","",87],[10,"ProgramUniform3dv","","",87],[10,"ProgramUniform3f","","",87],[10,"ProgramUniform3fv","","",87],[10,"ProgramUniform3i","","",87],[10,"ProgramUniform3iv","","",87],[10,"ProgramUniform3ui","","",87],[10,"ProgramUniform3uiv","","",87],[10,"ProgramUniform4d","","",87],[10,"ProgramUniform4dv","","",87],[10,"ProgramUniform4f","","",87],[10,"ProgramUniform4fv","","",87],[10,"ProgramUniform4i","","",87],[10,"ProgramUniform4iv","","",87],[10,"ProgramUniform4ui","","",87],[10,"ProgramUniform4uiv","","",87],[10,"ProgramUniformMatrix2dv","","",87],[10,"ProgramUniformMatrix2fv","","",87],[10,"ProgramUniformMatrix2x3dv","","",87],[10,"ProgramUniformMatrix2x3fv","","",87],[10,"ProgramUniformMatrix2x4dv","","",87],[10,"ProgramUniformMatrix2x4fv","","",87],[10,"ProgramUniformMatrix3dv","","",87],[10,"ProgramUniformMatrix3fv","","",87],[10,"ProgramUniformMatrix3x2dv","","",87],[10,"ProgramUniformMatrix3x2fv","","",87],[10,"ProgramUniformMatrix3x4dv","","",87],[10,"ProgramUniformMatrix3x4fv","","",87],[10,"ProgramUniformMatrix4dv","","",87],[10,"ProgramUniformMatrix4fv","","",87],[10,"ProgramUniformMatrix4x2dv","","",87],[10,"ProgramUniformMatrix4x2fv","","",87],[10,"ProgramUniformMatrix4x3dv","","",87],[10,"ProgramUniformMatrix4x3fv","","",87],[10,"ProvokingVertex","","",87],[10,"PushDebugGroup","","",87],[10,"QueryCounter","","",87],[10,"ReadBuffer","","",87],[10,"ReadPixels","","",87],[10,"ReadnPixels","","",87],[10,"ReleaseShaderCompiler","","",87],[10,"RenderbufferStorage","","",87],[10,"RenderbufferStorageMultisample","","",87],[10,"ResumeTransformFeedback","","",87],[10,"SampleCoverage","","",87],[10,"SampleMaski","","",87],[10,"SamplerParameterIiv","","",87],[10,"SamplerParameterIuiv","","",87],[10,"SamplerParameterf","","",87],[10,"SamplerParameterfv","","",87],[10,"SamplerParameteri","","",87],[10,"SamplerParameteriv","","",87],[10,"Scissor","","",87],[10,"ScissorArrayv","","",87],[10,"ScissorIndexed","","",87],[10,"ScissorIndexedv","","",87],[10,"SecondaryColorP3ui","","",87],[10,"SecondaryColorP3uiv","","",87],[10,"ShaderBinary","","",87],[10,"ShaderSource","","",87],[10,"ShaderStorageBlockBinding","","",87],[10,"StencilFunc","","",87],[10,"StencilFuncSeparate","","",87],[10,"StencilMask","","",87],[10,"StencilMaskSeparate","","",87],[10,"StencilOp","","",87],[10,"StencilOpSeparate","","",87],[10,"TexBuffer","","",87],[10,"TexBufferRange","","",87],[10,"TexCoordP1ui","","",87],[10,"TexCoordP1uiv","","",87],[10,"TexCoordP2ui","","",87],[10,"TexCoordP2uiv","","",87],[10,"TexCoordP3ui","","",87],[10,"TexCoordP3uiv","","",87],[10,"TexCoordP4ui","","",87],[10,"TexCoordP4uiv","","",87],[10,"TexImage1D","","",87],[10,"TexImage2D","","",87],[10,"TexImage2DMultisample","","",87],[10,"TexImage3D","","",87],[10,"TexImage3DMultisample","","",87],[10,"TexParameterIiv","","",87],[10,"TexParameterIuiv","","",87],[10,"TexParameterf","","",87],[10,"TexParameterfv","","",87],[10,"TexParameteri","","",87],[10,"TexParameteriv","","",87],[10,"TexStorage1D","","",87],[10,"TexStorage2D","","",87],[10,"TexStorage2DMultisample","","",87],[10,"TexStorage3D","","",87],[10,"TexStorage3DMultisample","","",87],[10,"TexSubImage1D","","",87],[10,"TexSubImage2D","","",87],[10,"TexSubImage3D","","",87],[10,"TextureBarrier","","",87],[10,"TextureBuffer","","",87],[10,"TextureBufferRange","","",87],[10,"TextureParameterIiv","","",87],[10,"TextureParameterIuiv","","",87],[10,"TextureParameterf","","",87],[10,"TextureParameterfv","","",87],[10,"TextureParameteri","","",87],[10,"TextureParameteriv","","",87],[10,"TextureStorage1D","","",87],[10,"TextureStorage2D","","",87],[10,"TextureStorage2DMultisample","","",87],[10,"TextureStorage3D","","",87],[10,"TextureStorage3DMultisample","","",87],[10,"TextureSubImage1D","","",87],[10,"TextureSubImage2D","","",87],[10,"TextureSubImage3D","","",87],[10,"TextureView","","",87],[10,"TransformFeedbackBufferBase","","",87],[10,"TransformFeedbackBufferRange","","",87],[10,"TransformFeedbackVaryings","","",87],[10,"Uniform1d","","",87],[10,"Uniform1dv","","",87],[10,"Uniform1f","","",87],[10,"Uniform1fv","","",87],[10,"Uniform1i","","",87],[10,"Uniform1iv","","",87],[10,"Uniform1ui","","",87],[10,"Uniform1uiv","","",87],[10,"Uniform2d","","",87],[10,"Uniform2dv","","",87],[10,"Uniform2f","","",87],[10,"Uniform2fv","","",87],[10,"Uniform2i","","",87],[10,"Uniform2iv","","",87],[10,"Uniform2ui","","",87],[10,"Uniform2uiv","","",87],[10,"Uniform3d","","",87],[10,"Uniform3dv","","",87],[10,"Uniform3f","","",87],[10,"Uniform3fv","","",87],[10,"Uniform3i","","",87],[10,"Uniform3iv","","",87],[10,"Uniform3ui","","",87],[10,"Uniform3uiv","","",87],[10,"Uniform4d","","",87],[10,"Uniform4dv","","",87],[10,"Uniform4f","","",87],[10,"Uniform4fv","","",87],[10,"Uniform4i","","",87],[10,"Uniform4iv","","",87],[10,"Uniform4ui","","",87],[10,"Uniform4uiv","","",87],[10,"UniformBlockBinding","","",87],[10,"UniformMatrix2dv","","",87],[10,"UniformMatrix2fv","","",87],[10,"UniformMatrix2x3dv","","",87],[10,"UniformMatrix2x3fv","","",87],[10,"UniformMatrix2x4dv","","",87],[10,"UniformMatrix2x4fv","","",87],[10,"UniformMatrix3dv","","",87],[10,"UniformMatrix3fv","","",87],[10,"UniformMatrix3x2dv","","",87],[10,"UniformMatrix3x2fv","","",87],[10,"UniformMatrix3x4dv","","",87],[10,"UniformMatrix3x4fv","","",87],[10,"UniformMatrix4dv","","",87],[10,"UniformMatrix4fv","","",87],[10,"UniformMatrix4x2dv","","",87],[10,"UniformMatrix4x2fv","","",87],[10,"UniformMatrix4x3dv","","",87],[10,"UniformMatrix4x3fv","","",87],[10,"UniformSubroutinesuiv","","",87],[10,"UnmapBuffer","","",87],[10,"UnmapNamedBuffer","","",87],[10,"UseProgram","","",87],[10,"UseProgramStages","","",87],[10,"ValidateProgram","","",87],[10,"ValidateProgramPipeline","","",87],[10,"VertexArrayAttribBinding","","",87],[10,"VertexArrayAttribFormat","","",87],[10,"VertexArrayAttribIFormat","","",87],[10,"VertexArrayAttribLFormat","","",87],[10,"VertexArrayBindingDivisor","","",87],[10,"VertexArrayElementBuffer","","",87],[10,"VertexArrayVertexBuffer","","",87],[10,"VertexArrayVertexBuffers","","",87],[10,"VertexAttrib1d","","",87],[10,"VertexAttrib1dv","","",87],[10,"VertexAttrib1f","","",87],[10,"VertexAttrib1fv","","",87],[10,"VertexAttrib1s","","",87],[10,"VertexAttrib1sv","","",87],[10,"VertexAttrib2d","","",87],[10,"VertexAttrib2dv","","",87],[10,"VertexAttrib2f","","",87],[10,"VertexAttrib2fv","","",87],[10,"VertexAttrib2s","","",87],[10,"VertexAttrib2sv","","",87],[10,"VertexAttrib3d","","",87],[10,"VertexAttrib3dv","","",87],[10,"VertexAttrib3f","","",87],[10,"VertexAttrib3fv","","",87],[10,"VertexAttrib3s","","",87],[10,"VertexAttrib3sv","","",87],[10,"VertexAttrib4Nbv","","",87],[10,"VertexAttrib4Niv","","",87],[10,"VertexAttrib4Nsv","","",87],[10,"VertexAttrib4Nub","","",87],[10,"VertexAttrib4Nubv","","",87],[10,"VertexAttrib4Nuiv","","",87],[10,"VertexAttrib4Nusv","","",87],[10,"VertexAttrib4bv","","",87],[10,"VertexAttrib4d","","",87],[10,"VertexAttrib4dv","","",87],[10,"VertexAttrib4f","","",87],[10,"VertexAttrib4fv","","",87],[10,"VertexAttrib4iv","","",87],[10,"VertexAttrib4s","","",87],[10,"VertexAttrib4sv","","",87],[10,"VertexAttrib4ubv","","",87],[10,"VertexAttrib4uiv","","",87],[10,"VertexAttrib4usv","","",87],[10,"VertexAttribBinding","","",87],[10,"VertexAttribDivisor","","",87],[10,"VertexAttribFormat","","",87],[10,"VertexAttribI1i","","",87],[10,"VertexAttribI1iv","","",87],[10,"VertexAttribI1ui","","",87],[10,"VertexAttribI1uiv","","",87],[10,"VertexAttribI2i","","",87],[10,"VertexAttribI2iv","","",87],[10,"VertexAttribI2ui","","",87],[10,"VertexAttribI2uiv","","",87],[10,"VertexAttribI3i","","",87],[10,"VertexAttribI3iv","","",87],[10,"VertexAttribI3ui","","",87],[10,"VertexAttribI3uiv","","",87],[10,"VertexAttribI4bv","","",87],[10,"VertexAttribI4i","","",87],[10,"VertexAttribI4iv","","",87],[10,"VertexAttribI4sv","","",87],[10,"VertexAttribI4ubv","","",87],[10,"VertexAttribI4ui","","",87],[10,"VertexAttribI4uiv","","",87],[10,"VertexAttribI4usv","","",87],[10,"VertexAttribIFormat","","",87],[10,"VertexAttribIPointer","","",87],[10,"VertexAttribL1d","","",87],[10,"VertexAttribL1dv","","",87],[10,"VertexAttribL2d","","",87],[10,"VertexAttribL2dv","","",87],[10,"VertexAttribL3d","","",87],[10,"VertexAttribL3dv","","",87],[10,"VertexAttribL4d","","",87],[10,"VertexAttribL4dv","","",87],[10,"VertexAttribLFormat","","",87],[10,"VertexAttribLPointer","","",87],[10,"VertexAttribP1ui","","",87],[10,"VertexAttribP1uiv","","",87],[10,"VertexAttribP2ui","","",87],[10,"VertexAttribP2uiv","","",87],[10,"VertexAttribP3ui","","",87],[10,"VertexAttribP3uiv","","",87],[10,"VertexAttribP4ui","","",87],[10,"VertexAttribP4uiv","","",87],[10,"VertexAttribPointer","","",87],[10,"VertexBindingDivisor","","",87],[10,"VertexP2ui","","",87],[10,"VertexP2uiv","","",87],[10,"VertexP3ui","","",87],[10,"VertexP3uiv","","",87],[10,"VertexP4ui","","",87],[10,"VertexP4uiv","","",87],[10,"Viewport","","",87],[10,"ViewportArrayv","","",87],[10,"ViewportIndexedf","","",87],[10,"ViewportIndexedfv","","",87],[10,"WaitSync","","",87],[10,"fmt","device::gl","",88],[10,"eq","","",88],[10,"ne","","",88],[10,"ne","","",88],[10,"assert_receiver_is_total_eq","","",88],[10,"get_capabilities","","",24],[10,"create_buffer_raw","","",24],[10,"create_buffer_static","","",24],[10,"create_array_buffer","","",24],[10,"create_shader","","",24],[10,"create_program","","",24],[10,"create_frame_buffer","","",24],[10,"create_surface","","",24],[10,"create_texture","","",24],[10,"create_sampler","","",24],[10,"delete_buffer_raw","","",24],[10,"delete_shader","","",24],[10,"delete_program","","",24],[10,"delete_surface","","",24],[10,"delete_texture","","",24],[10,"delete_sampler","","",24],[10,"update_buffer_raw","","",24],[10,"update_texture_raw","","",24],[10,"generate_mipmap","","",24],[10,"submit","","",24],[10,"create_buffer","","",24],[10,"delete_buffer","","",24],[10,"update_buffer","","",24],[10,"update_texture","","",24],[10,"fmt","device","",89],[10,"clone","","",89],[10,"clone_from","","",89],[10,"get_name","","Get the internal name",89],[10,"get_info","","Get the info reference",89],[10,"eq","","",89],[10,"ne","","",89],[10,"clone","","",90],[10,"clone_from","","",90],[10,"fmt","","",90],[10,"from_raw","","Create a type-safe BufferHandle from a RawBufferHandle",90],[10,"cast","","Cast the type this BufferHandle references",90],[10,"get_name","","Get the underlying GL name for this BufferHandle",90],[10,"get_info","","Get the associated information about the buffer",90],[10,"raw","","Get the underlying raw Handle",90],[10,"fmt","","",91],[10,"cast","alloc::boxed","",92],[10,"get_address","collections::vec","",93],[10,"get_size","","",93],[10,"fmt","alloc::boxed","",92],[10,"fmt","device","",94],[10,"eq","","",94],[10,"ne","","",94],[10,"ne","","",94],[10,"clone","","",94],[10,"clone_from","","",94],[10,"fmt","","",95],[10,"eq","","",95],[10,"ne","","",95],[10,"ne","","",95],[10,"clone","","",95],[10,"clone_from","","",95],[10,"fmt","","",96],[10,"eq","","",96],[10,"ne","","",96],[10,"ne","","",96],[10,"clone","","",96],[10,"clone_from","","",96],[10,"fmt","","",97],[1,"GlDevice","gfx","An OpenGL device with GLSL shaders"],[0,"attrib","","Vertex attribute types."],[4,"Count","gfx::attrib",""],[4,"Offset","",""],[4,"Stride","",""],[2,"SignFlag","",""],[12,"Signed","","",25],[12,"Unsigned","","",25],[2,"IntSubType","",""],[12,"IntRaw","","",26],[12,"IntNormalized","","",26],[12,"IntAsFloat","","",26],[2,"IntSize","",""],[12,"U8","","",27],[12,"U16","","",27],[12,"U32","","",27],[2,"FloatSubType","",""],[12,"FloatDefault","","",28],[12,"FloatPrecision","","",28],[2,"FloatSize","",""],[12,"F16","","",29],[12,"F32","","",29],[12,"F64","","",29],[2,"Type","",""],[12,"Int","","",30],[12,"Float","","",30],[12,"Special","","",30],[0,"state","gfx","Fixed-function hardware state."],[2,"WindingOrder","gfx::state","The winding order of a set of vertices."],[12,"Clockwise","","Clockwise winding order.",51],[12,"CounterClockwise","","Counter-clockwise winding order.",51],[4,"LineWidth","",""],[4,"OffsetFactor","",""],[4,"OffsetUnits","",""],[2,"OffsetType","","How to offset vertices in screen space, if at all."],[12,"NoOffset","","",52],[12,"Offset","","",52],[2,"CullMode","","Which face, if any, to cull."],[12,"CullNothing","","",53],[12,"CullFront","","",53],[12,"CullBack","","",53],[2,"RasterMethod","","How to rasterize a primitive."],[12,"Point","","Rasterize as a point.",54],[12,"Line","","Rasterize as a line with the given width.",54],[12,"Fill","","Rasterize as a face with a given cull mode.",54],[1,"Primitive","","Primitive rasterization state. Note that GL allows different raster\nmethod to be used for front and back, while this abstraction does not."],[11,"front_face","","Which vertex winding is considered to be the front face for culling.",55],[11,"method","","How to rasterize this primitive.",55],[11,"offset","","Any polygon offset to apply.",55],[2,"Comparison","","A pixel-wise comparison function."],[12,"Never","","`false`",56],[12,"Less","","`x < y`",56],[12,"LessEqual","","`x <= y`",56],[12,"Equal","","`x == y`",56],[12,"GreaterEqual","","`x >= y`",56],[12,"Greater","","`x > y`",56],[12,"NotEqual","","`x != y`",56],[12,"Always","","`true`",56],[2,"StencilOp","","Stencil mask operation."],[12,"OpKeep","","Keep the current value in the stencil buffer (no change).",57],[12,"OpZero","","Set the value in the stencil buffer to zero.",57],[12,"OpReplace","","Set the stencil buffer value to `value` from `StencilSide`",57],[12,"OpIncrementClamp","","Increment the stencil buffer value, clamping to its maximum value.",57],[12,"OpIncrementWrap","","Increment the stencil buffer value, wrapping around to 0 on overflow.",57],[12,"OpDecrementClamp","","Decrement the stencil buffer value, clamping to its minimum value.",57],[12,"OpDecrementWrap","","Decrement the stencil buffer value, wrapping around to the maximum value on overflow.",57],[12,"OpInvert","","Bitwise invert the current value in the stencil buffer.",57],[1,"StencilSide","","Complete stencil state for a given side of a face."],[11,"fun","","Comparison function to use to determine if the stencil test passes.",58],[11,"value","","Reference value to compare the value in the stencil buffer with.",58],[11,"mask_read","","A mask that is ANDd with both the stencil buffer value and the reference value when they\nare read before doing the stencil test.",58],[11,"mask_write","","This is unused!",58],[11,"op_fail","","What operation to do if the stencil test fails.",58],[11,"op_depth_fail","","What operation to do if the stenil test passes but the depth test fails.",58],[11,"op_pass","","What operation to do if both the depth and stencil test pass.",58],[1,"Stencil","","Complete stencil state, specifying how to handle the front and back side of a face."],[11,"front","","",59],[11,"back","","",59],[1,"Depth","","Depth test state."],[11,"fun","","Comparison function to use.",60],[11,"write","","Specify whether to write to the depth buffer or not.",60],[2,"Equation","",""],[12,"FuncAdd","","",61],[12,"FuncSub","","",61],[12,"FuncRevSub","","",61],[12,"FuncMin","","",61],[12,"FuncMax","","",61],[2,"InverseFlag","",""],[12,"Normal","","",62],[12,"Inverse","","",62],[2,"BlendValue","",""],[12,"Zero","","",63],[12,"SourceColor","","",63],[12,"SourceAlpha","","",63],[12,"SourceAlphaSaturated","","",63],[12,"DestColor","","",63],[12,"DestAlpha","","",63],[12,"ConstColor","","",63],[12,"ConstAlpha","","",63],[1,"Factor","",""],[1,"BlendChannel","",""],[11,"equation","","",65],[11,"source","","",65],[11,"destination","","",65],[1,"Blend","",""],[11,"color","","",66],[11,"alpha","","",66],[11,"value","","",66],[1,"ColorMask","",""],[5,"Red","",""],[5,"Green","",""],[5,"Blue","",""],[5,"Alpha","",""],[5,"MaskAll","",""],[0,"tex","gfx","Texture creation and modification."],[2,"SurfaceError","gfx::tex","Surface creation/update error."],[12,"UnsupportedSurfaceFormat","","Failed to map a given format to the device",71],[2,"TextureError","","Texture creation/update error."],[12,"UnsupportedTextureFormat","","Failed to map a given format to the device",72],[4,"Bits","",""],[2,"Components","","Describes the component layout of each texel."],[12,"R","","Red only",73],[12,"RG","","Red and green",73],[12,"RGB","","Red, green, blue",73],[12,"RGBA","","Red, green, blue, alpha",73],[2,"Format","","Describes the layout of each texel within a surface/texture."],[12,"Float","","Floating point.",74],[12,"Integer","","Signed integer.",74],[12,"Unsigned","","Unsigned integer.",74],[12,"R3G3B2","","Normalized integer, with 3 bits for R and G, but only 2 for B.",74],[12,"RGB5A1","","5 bits each for RGB, 1 for Alpha.",74],[12,"RGB10A2","","10 bits each for RGB, 2 for Alpha.",74],[12,"RGB10A2UI","","10 bits each for RGB, 2 for Alpha, as unsigned integers.",74],[12,"R11FG11FB10F","","This uses special 11 and 10-bit floating-point values without sign bits.",74],[12,"RGB9E5","","This s an RGB format of type floating-point. The 3 color values have\n9 bits of precision, and they share a single exponent.",74],[12,"DEPTH24STENCIL8","","24 bits for depth, 8 for stencil",74],[5,"RGBA8","",""],[1,"SurfaceInfo","","Describes the storage of a surface"],[11,"width","","",75],[11,"height","","",75],[11,"format","","",75],[2,"FilterMethod","","How to [filter](https://en.wikipedia.org/wiki/Texture_filtering) the\ntexture when sampling. They correspond to increasing levels of quality,\nbut also cost. They \"layer\" on top of each other: it is not possible to\nhave bilinear filtering without mipmapping, for example."],[12,"Scale","","The dumbest filtering possible, nearest-neighbor interpolation.",76],[12,"Mipmap","","Add simple mipmapping.",76],[12,"Bilinear","","Sample multiple texels within a single mipmap level to increase\nquality.",76],[12,"Trilinear","","Sample multiple texels across two mipmap levels to increase quality.",76],[12,"Anisotropic","","Anisotropic filtering with a given \"max\", must be between 1 and 16,\ninclusive.",76],[2,"TextureKind","","Specifies how a given texture may be used. The available texture types are\nrestricted by what Metal exposes, though this could conceivably be\nextended in the future. Note that a single texture can *only* ever be of\none kind. A texture created as `Texture2D` will forever be `Texture2D`."],[12,"Texture1D","","A single row of texels.",77],[12,"Texture1DArray","","An array of rows of texels. Equivalent to Texture2D except that texels\nin a different row are not sampled.",77],[12,"Texture2D","","A traditional 2D texture, with rows arranged contiguously.",77],[12,"Texture2DArray","","An array of 2D textures. Equivalent to Texture3D except that texels in\na different depth level are not sampled.",77],[12,"TextureCube","","A set of 6 2D textures, one for each face of a cube.",77],[12,"Texture3D","","A volume texture, with each 2D layer arranged contiguously.",77],[1,"TextureInfo","","Describes the storage of a texture."],[11,"width","","",78],[11,"height","","",78],[11,"depth","","",78],[11,"levels","","Number of mipmap levels. Defaults to -1, which stands for unlimited.\nMipmap levels at equal or above `levels` can not be loaded or sampled\nby the shader. width and height of each consecutive mipmap level is\nhalved, starting from level 0.",78],[11,"kind","","",78],[11,"format","","",78],[1,"ImageInfo","","Describes a subvolume of a texture, which image data can be uploaded into."],[11,"xoffset","","",79],[11,"yoffset","","",79],[11,"zoffset","","",79],[11,"width","","",79],[11,"height","","",79],[11,"depth","","",79],[11,"format","","Format of each texel.",79],[11,"mipmap","","Which mipmap to select.",79],[2,"WrapMode","","Specifies how texture coordinates outside the range `[0, 1]` are handled."],[12,"Tile","","Tile the texture. That is, sample the coordinate modulo `1.0`. This is\nthe default.",80],[12,"Mirror","","Mirror the texture. Like tile, but uses abs(coord) before the modulo.",80],[12,"Clamp","","Clamp the texture to the value at `0.0` or `1.0` respectively.",80],[1,"SamplerInfo","","Specifies how to sample from a texture."],[11,"filtering","","Filter method to use.",81],[11,"wrap_mode","","Wrapping mode for each of the U, V, and W axis (S, T, and R in OpenGL\nspeak)",81],[11,"lod_bias","","This bias is added to every computed mipmap level (N + lod_bias). For\nexample, if it would select mipmap level 2 and lod_bias is 1, it will\nuse mipmap level 3.",81],[11,"lod_range","","This range is used to clamp LOD level used for sampling",81],[1,"BufferHandle","gfx","Type-safe buffer handle"],[1,"BufferInfo","","An information block that is immutable and associated with each buffer"],[11,"usage","","Usage hint",96],[11,"size","","Size in bytes",96],[4,"RawBufferHandle","",""],[4,"ShaderHandle","",""],[4,"ProgramHandle","",""],[4,"SurfaceHandle","",""],[4,"TextureHandle","",""],[2,"BufferUsage","","A hint as to how this buffer will be used."],[12,"UsageStatic","","Once uploaded, this buffer will rarely change, but will be read from often.",95],[12,"UsageDynamic","","This buffer will be updated \"frequently\", and will be read from multiple times between\nupdates.",95],[12,"UsageStream","","This buffer always or almost always be updated after each read.",95],[6,"Blob","","A trait that slice-like types implement."],[9,"get_address","","Get the address to the data this `Blob` stores.",98],[9,"get_size","","Get the number of bytes in this blob.",98],[4,"VertexCount","",""],[4,"IndexCount","",""],[2,"UniformValue","","A value that can be uploaded to the device as a uniform."],[12,"ValueI32","","",40],[12,"ValueF32","","",40],[12,"ValueI32Vector2","","",40],[12,"ValueI32Vector3","","",40],[12,"ValueI32Vector4","","",40],[12,"ValueF32Vector2","","",40],[12,"ValueF32Vector3","","",40],[12,"ValueF32Vector4","","",40],[12,"ValueF32Matrix2","","",40],[12,"ValueF32Matrix3","","",40],[12,"ValueF32Matrix4","","",40],[1,"ShaderSource","","A type storing shader source for different graphics APIs and versions."],[11,"glsl_120","","",48],[11,"glsl_150","","",48],[1,"ProgramInfo","","Metadata about a program."],[11,"attributes","","Attributes in the program.",45],[11,"uniforms","","Uniforms in the program",45],[11,"blocks","","Uniform blocks in the program",45],[11,"textures","","Samplers in the program",45],[4,"Color","",""],[1,"ClearData","","How to clear a frame."],[11,"color","","If set, the color buffer of the frame will be cleared to this.",69],[11,"depth","","If set, the depth buffer of the frame will be cleared to this.",69],[11,"stencil","","If set, the stencil buffer of the frame will be cleared to this.",69],[4,"Layer","",""],[4,"Level","",""]],"paths":[[2,"ParameterError"],[2,"MeshError"],[2,"DrawError"],[2,"ProgramError"],[1,"Renderer"],[1,"Attribute"],[1,"Mesh"],[2,"Slice"],[2,"ParameterError"],[1,"UserProgram"],[1,"DictionaryProgram"],[1,"DrawState"],[2,"BlendPreset"],[2,"Plane"],[1,"Frame"],[6,"DeviceHelper"],[6,"VertexFormat"],[6,"ToUniform"],[1,"ParamValues"],[6,"Program"],[6,"ShaderParam"],[1,"NamedCell"],[1,"ParamDictionary"],[6,"Device"],[1,"GlDevice"],[2,"SignFlag"],[2,"IntSubType"],[2,"IntSize"],[2,"FloatSubType"],[2,"FloatSize"],[2,"Type"],[2,"IsArray"],[2,"IsShadow"],[2,"IsMultiSample"],[2,"IsRect"],[2,"MatrixFormat"],[2,"SamplerType"],[2,"BaseType"],[2,"ContainerType"],[2,"Stage"],[2,"UniformValue"],[1,"Attribute"],[1,"UniformVar"],[1,"BlockVar"],[1,"SamplerVar"],[1,"ProgramInfo"],[2,"CompatibilityError"],[2,"Bytes"],[1,"ShaderSource"],[2,"CreateShaderError"],[2,"ShaderModel"],[2,"WindingOrder"],[2,"OffsetType"],[2,"CullMode"],[2,"RasterMethod"],[1,"Primitive"],[2,"Comparison"],[2,"StencilOp"],[1,"StencilSide"],[1,"Stencil"],[1,"Depth"],[2,"Equation"],[2,"InverseFlag"],[2,"BlendValue"],[1,"Factor"],[1,"BlendChannel"],[1,"Blend"],[1,"ColorMask"],[1,"Rect"],[1,"ClearData"],[2,"Target"],[2,"SurfaceError"],[2,"TextureError"],[2,"Components"],[2,"Format"],[1,"SurfaceInfo"],[2,"FilterMethod"],[2,"TextureKind"],[1,"TextureInfo"],[1,"ImageInfo"],[2,"WrapMode"],[1,"SamplerInfo"],[1,"GlCommandBuffer"],[1,"Version"],[1,"PlatformName"],[1,"Info"],[1,"FnPtr"],[1,"Gl"],[2,"ErrorType"],[1,"Handle"],[1,"BufferHandle"],[1,"Capabilities"],[1,"Box"],[1,"Vec"],[2,"PrimitiveType"],[2,"BufferUsage"],[1,"BufferInfo"],[2,"Command"],[6,"Blob"]]};

searchIndex['render'] = {"items":[[0,"","render","High-level, platform independent, bindless rendering API."],[0,"front","","Frontend\nRendering front-end"],[1,"Renderer","render::front","Renderer front-end"],[2,"ParameterError","","An error with an invalid texture or uniform block."],[12,"ErrorParamUniform","","Error from a uniform value",0],[12,"ErrorParamBlock","","Error from a uniform block.",0],[12,"ErrorParamTexture","","Error from a texture.",0],[12,"ErrorParamSampler","","Error from a sampler",0],[2,"MeshError","","An error with a defined Mesh."],[12,"ErrorAttributeMissing","","A required attribute was missing.",1],[12,"ErrorAttributeType","","An attribute's type from the vertex format differed from the type used in the shader.",1],[2,"DrawError","","An error that can happen when trying to draw."],[12,"ErrorProgram","","Error with a program.",2],[12,"ErrorParameter","","Error with the program shell.",2],[12,"ErrorMesh","","Error with the mesh.",2],[12,"ErrorSlice","","Error with the mesh slice",2],[2,"ProgramError","","Program linking error"],[12,"ErrorVertex","","Unable to compile the vertex shader",3],[12,"ErrorFragment","","Unable to compile the fragment shader",3],[12,"ErrorLink","","Unable to link",3],[12,"ErrorParameters","","Unable to connect parameters",3],[6,"DeviceHelper","","Backend extension trait for convenience methods"],[9,"create_renderer","","Create a new renderer",4],[9,"create_mesh","","Create a new mesh from the given vertex data.\nConvenience function around `create_buffer` and `Mesh::from`.",4],[9,"link_program","","Create a simple program given a vertex shader with a fragment one.\nThe return type can not be derived from the arguments, so you need to\nprovide it explicitly:",4],[10,"fmt","","",0],[10,"fmt","","",1],[10,"fmt","","",2],[10,"fmt","","",3],[10,"eq","","",3],[10,"ne","","",3],[10,"clone","","",3],[10,"reset","","Reset all commands for the command buffer re-usal.",5],[10,"as_buffer","","Get a command buffer to be submitted",5],[10,"clone_empty","","Clone the renderer shared data but ignore the commands",5],[10,"clear","","Clear the `Frame` as the `ClearData` specifies.",5],[10,"draw","","Draw `slice` of `mesh` into `frame`, using a program shell, and a given draw state.",5],[10,"update_buffer_vec","","Update a buffer with data from a vector.",5],[10,"update_buffer_struct","","Update a buffer with data from a single type.",5],[10,"update_texture","","Update the contents of a texture.",5],[0,"mesh","render","Meshes\nMesh loading."],[1,"Attribute","render::mesh","Describes a single attribute of a vertex buffer, including its type, name, etc."],[11,"buffer","","Vertex buffer to contain the data",6],[11,"elem_count","","Number of elements per vertex",6],[11,"elem_type","","Type of a single element",6],[11,"offset","","Offset in bytes to the first vertex",6],[11,"stride","","Stride in bytes between consecutive vertices",6],[11,"name","","A name to match the shader input",6],[1,"Mesh","","Describes geometry to render."],[11,"num_vertices","","Number of vertices in the mesh.",7],[11,"attributes","","Vertex attributes to use.",7],[2,"Slice","","Description of a subset of `Mesh` data to render.\nWe provide a primitive type in a slice because it is how we interpret mesh\ncontents. For example, we can have a `Point` typed vertex slice to do shape\nblending, while still rendereing it as an indexed `TriangleList`."],[12,"VertexSlice","","Render vertex data directly from the `Mesh`'s buffer, using only the vertices between the two\nendpoints.",8],[12,"IndexSlice8","","The `IndexSlice*` buffer contains a list of indices into the `Mesh` data, so every vertex\nattribute does not need to be duplicated, only its position in the `Mesh`.  For example,\nwhen drawing a square, two triangles are needed.  Using only `VertexSlice`, one would need\n6 separate vertices, 3 for each triangle. However, two of the vertices will be identical,\nwasting space for the duplicated attributes.  Instead, the `Mesh` can store 4 vertices and\nan `IndexSlice8` can be used instead.",8],[12,"IndexSlice16","","As `IndexSlice8` but with `u16` indices",8],[12,"IndexSlice32","","As `IndexSlice8` but with `u32` indices",8],[6,"VertexFormat","","A trait implemented automatically for user vertex structure by\n`#[vertex_format] attribute"],[9,"generate","","Create the attributes for this type, using the given buffer.",9],[10,"fmt","","",6],[10,"eq","","",6],[10,"ne","","",6],[10,"clone","","",6],[10,"fmt","","",7],[10,"clone","","",7],[10,"new","","Create a new mesh, which is a `TriangleList` with no attributes and `nv` vertices.",7],[10,"from","","Create a new `Mesh` from a struct that implements `VertexFormat` and a buffer.",7],[10,"get_slice","","Return a vertex slice of the whole mesh",7],[10,"fmt","","",8],[10,"clone","","",8],[0,"shade","render","Shaders\nShader parameter handling."],[1,"ParamValues","render::shade","A borrowed mutable storage for shader parameter values."],[11,"uniforms","","uniform values to be provided",10],[11,"blocks","","uniform buffers to be provided",10],[11,"textures","","textures to be provided",10],[1,"UserProgram","","A bundle that encapsulates a program and a custom user-provided\nstructure containing the program parameters.\n# Type parameters:"],[1,"NamedCell","","A named cell containing arbitrary value"],[11,"name","","Name",11],[11,"value","","Value",11],[1,"ParamDictionary","","A dictionary of parameters, meant to be shared between different programs"],[11,"uniforms","","Uniform dictionary",12],[11,"blocks","","Block dictionary",12],[11,"textures","","Texture dictionary",12],[1,"ParamDictionaryLink","","An associated link structure for `ParamDictionary` that redirects program\ninput to the relevant dictionary cell."],[1,"DictionaryProgram","","A shader program with dictionary of parameters"],[2,"ParameterError","","An error type on either the parameter storage or the program side"],[12,"ErrorInternal","","Internal error",13],[12,"ErrorUniform","","Error with the named uniform",13],[12,"ErrorBlock","","Error with the named uniform block",13],[12,"ErrorTexture","","Error with the named texture.",13],[4,"VarUniform","","Variable index of a uniform."],[4,"VarBlock","","Variable index of a uniform block."],[4,"VarTexture","","Variable index of a texture."],[4,"TextureParam","","A texture parameter: consists of a texture handle with an optional sampler."],[4,"EmptyProgram","",""],[6,"ToUniform","","Helper trait to transform base types into their corresponding uniforms"],[9,"to_uniform","","Create a `UniformValue` representing this value.",14],[6,"Program","","Encloses a shader program handle with its parameter"],[9,"get_handle","","Get the contained program handle",15],[9,"fill_params","","Get all the contained parameter values",15],[6,"ShaderParam","","Abstracts the shader parameter structure, generated by the `shader_param` attribute"],[9,"create_link","","Creates a new link, self is passed as a workaround for Rust to not be lost in generics",16],[9,"fill_params","","Get all the contained parameter values, using a given link.",16],[10,"eq","","",13],[10,"ne","","",13],[10,"clone","","",13],[10,"fmt","","",13],[10,"clone","","",17],[10,"connect","","Connect a shader program with a parameter structure",17],[10,"connect","","Connect a shader program with a parameter structure",18],[0,"state","render","Draw state\nFixed-function hardware state."],[1,"DrawState","render::state","An assembly of states that affect regular draw calls"],[11,"primitive","","How to rasterize geometric primitives.",19],[11,"scissor","","Stencil mask to use. If set, no pixel outside of this rectangle (in screen space) will be\nwritten to as a result of rendering.",19],[11,"stencil","","Stencil test to use. If None, no stencil testing is done.",19],[11,"depth","","Depth test to use. If None, no depth testing is done.",19],[11,"blend","","Blend function to use. If None, no blending is done.",19],[11,"color_mask","","Color mask to use. Each flag indicates that the given color channel can be written to, and\nthey can be OR'd together.",19],[2,"BlendPreset","","Blend function presets for ease of use."],[12,"BlendAdditive","","When combining two fragments, add their values together, saturating at 1.0",20],[12,"BlendAlpha","","When combining two fragments, add the value of the source times its alpha channel with the\nvalue of the destination multiplied by the inverse of the source alpha channel. Has the\nusual transparency effect: mixes the two colors using a fraction of each one specified by\nthe alpha of the source.",20],[10,"fmt","","",19],[10,"eq","","",19],[10,"ne","","",19],[10,"clone","","",19],[10,"fmt","","",20],[10,"eq","","",20],[10,"ne","","",20],[10,"clone","","",20],[10,"new","","Create a default `DrawState`. Uses counter-clockwise winding, culls the backface of each\nprimitive, and does no scissor/stencil/depth/blend/color masking.",19],[10,"stencil","","Set the stencil test to a simple expression",19],[10,"depth","","Set the depth test with the mask",19],[10,"blend","","Set the blend mode to one of the presets",19],[0,"target","render","Render targets\nRender target specification."],[1,"Frame","render::target","A complete `Frame`, which is the result of rendering."],[11,"width","","The width of the viewport.",21],[11,"height","","The height of the viewport.",21],[11,"colors","","Each color component has its own buffer.",21],[11,"depth","","The depth buffer for this frame.",21],[11,"stencil","","The stencil buffer for this frame.",21],[2,"Plane","","A single buffer that can be bound to a render target."],[12,"PlaneEmpty","","No buffer, the results will not be stored.",22],[12,"PlaneSurface","","Render to a `Surface` (corresponds to a renderbuffer in GL).",22],[12,"PlaneTexture","","Render to a texture at a specific mipmap level\nIf `Layer` is set, it is selecting a single 2D slice of a given 3D texture",22],[10,"fmt","","",22],[10,"eq","","",22],[10,"ne","","",22],[10,"clone","","",22],[10,"new","","Create an empty `Frame`, which corresponds to the 'default framebuffer', which for now\nrenders directly to the window that was created with the OpenGL context.",21],[10,"is_default","","Returns true if this framebuffer is associated with the main window (matches `Frame::new`\nexactly).",21]],"paths":[[2,"ParameterError"],[2,"MeshError"],[2,"DrawError"],[2,"ProgramError"],[6,"DeviceHelper"],[1,"Renderer"],[1,"Attribute"],[1,"Mesh"],[2,"Slice"],[6,"VertexFormat"],[1,"ParamValues"],[1,"NamedCell"],[1,"ParamDictionary"],[2,"ParameterError"],[6,"ToUniform"],[6,"Program"],[6,"ShaderParam"],[1,"UserProgram"],[1,"DictionaryProgram"],[1,"DrawState"],[2,"BlendPreset"],[1,"Frame"],[2,"Plane"]]};

searchIndex['device'] = {"items":[[0,"","device","Graphics device. Not meant for direct use."],[1,"GlDevice","","An OpenGL device with GLSL shaders"],[1,"GlCommandBuffer","",""],[1,"Handle","","A generic handle struct"],[1,"BufferHandle","","Type-safe buffer handle"],[1,"Capabilities","","Features that the device supports."],[11,"shader_model","","",0],[11,"max_draw_buffers","","",0],[11,"max_texture_size","","",0],[11,"max_vertex_attributes","","",0],[11,"uniform_block_supported","","",0],[11,"array_buffer_supported","","",0],[11,"sampler_objects_supported","","",0],[11,"immutable_storage_supported","","",0],[1,"BufferInfo","","An information block that is immutable and associated with each buffer"],[11,"usage","","Usage hint",1],[11,"size","","Size in bytes",1],[2,"PrimitiveType","","Describes what geometric primitives are created from vertex data."],[12,"Point","","Each vertex represents a single point.",2],[12,"Line","","Each pair of vertices represent a single line segment. For example, with `[a, b, c, d,\ne]`, `a` and `b` form a line, `c` and `d` form a line, and `e` is discarded.",2],[12,"LineStrip","","Every two consecutive vertices represent a single line segment. Visually forms a \"path\" of\nlines, as they are all connected. For example, with `[a, b, c]`, `a` and `b` form a line\nline, and `b` and `c` form a line.",2],[12,"TriangleList","","Each triplet of vertices represent a single triangle. For example, with `[a, b, c, d, e]`,\n`a`, `b`, and `c` form a triangle, `d` and `e` are discarded.",2],[12,"TriangleStrip","","Every three consecutive vertices represent a single triangle. For example, with `[a, b, c,\nd]`, `a`, `b`, and `c` form a triangle, and `b`, `c`, and `d` form a triangle.",2],[12,"TriangleFan","","The first vertex with the last two are forming a triangle. For example, with `[a, b, c, d\n]`, `a` , `b`, and `c` form a triangle, and `a`, `c`, and `d` form a triangle.",2],[2,"BufferUsage","","A hint as to how this buffer will be used."],[12,"UsageStatic","","Once uploaded, this buffer will rarely change, but will be read from often.",3],[12,"UsageDynamic","","This buffer will be updated \"frequently\", and will be read from multiple times between\nupdates.",3],[12,"UsageStream","","This buffer always or almost always be updated after each read.",3],[2,"Command","","Serialized device command.\nWhile this is supposed to be an internal detail of a device,\nthis particular representation may be used by different backends,\nsuch as OpenGL (prior to GLNG) and DirectX (prior to DX12)"],[12,"BindProgram","","",4],[12,"BindArrayBuffer","","",4],[12,"BindAttribute","","",4],[12,"BindIndex","","",4],[12,"BindFrameBuffer","","",4],[12,"UnbindTarget","","Unbind any surface from the specified target slot",4],[12,"BindTargetSurface","","Bind a surface to the specified target slot",4],[12,"BindTargetTexture","","Bind a level of the texture to the specified target slot",4],[12,"BindUniformBlock","","",4],[12,"BindUniform","","",4],[12,"BindTexture","","",4],[12,"SetPrimitiveState","","",4],[12,"SetViewport","","",4],[12,"SetScissor","","",4],[12,"SetDepthStencilState","","",4],[12,"SetBlendState","","",4],[12,"SetColorMask","","",4],[12,"UpdateBuffer","","",4],[12,"UpdateTexture","","",4],[12,"Clear","","",4],[12,"Draw","","",4],[12,"DrawIndexed","","",4],[3,"make_fake_buffer","","A helper method to test `#[vertex_format]` without GL context"],[3,"get_main_frame_buffer","","Return the framebuffer handle for the screen"],[0,"attrib","","Vertex attribute types."],[2,"SignFlag","device::attrib",""],[12,"Signed","","",5],[12,"Unsigned","","",5],[2,"IntSubType","",""],[12,"IntRaw","","",6],[12,"IntNormalized","","",6],[12,"IntAsFloat","","",6],[2,"IntSize","",""],[12,"U8","","",7],[12,"U16","","",7],[12,"U32","","",7],[2,"FloatSubType","",""],[12,"FloatDefault","","",8],[12,"FloatPrecision","","",8],[2,"FloatSize","",""],[12,"F16","","",9],[12,"F32","","",9],[12,"F64","","",9],[2,"Type","",""],[12,"Int","","",10],[12,"Float","","",10],[12,"Special","","",10],[4,"Count","",""],[4,"Offset","",""],[4,"Stride","",""],[10,"fmt","","",5],[10,"clone","","",5],[10,"hash","","",5],[10,"partial_cmp","","",5],[10,"lt","","",5],[10,"le","","",5],[10,"gt","","",5],[10,"ge","","",5],[10,"eq","","",5],[10,"ne","","",5],[10,"cmp","","",5],[10,"fmt","","",6],[10,"clone","","",6],[10,"hash","","",6],[10,"partial_cmp","","",6],[10,"lt","","",6],[10,"le","","",6],[10,"gt","","",6],[10,"ge","","",6],[10,"eq","","",6],[10,"ne","","",6],[10,"cmp","","",6],[10,"fmt","","",7],[10,"clone","","",7],[10,"hash","","",7],[10,"partial_cmp","","",7],[10,"lt","","",7],[10,"le","","",7],[10,"gt","","",7],[10,"ge","","",7],[10,"eq","","",7],[10,"ne","","",7],[10,"cmp","","",7],[10,"fmt","","",8],[10,"clone","","",8],[10,"hash","","",8],[10,"partial_cmp","","",8],[10,"lt","","",8],[10,"le","","",8],[10,"gt","","",8],[10,"ge","","",8],[10,"eq","","",8],[10,"ne","","",8],[10,"cmp","","",8],[10,"fmt","","",9],[10,"clone","","",9],[10,"hash","","",9],[10,"partial_cmp","","",9],[10,"lt","","",9],[10,"le","","",9],[10,"gt","","",9],[10,"ge","","",9],[10,"eq","","",9],[10,"ne","","",9],[10,"cmp","","",9],[10,"fmt","","",10],[10,"clone","","",10],[10,"hash","","",10],[10,"partial_cmp","","",10],[10,"lt","","",10],[10,"le","","",10],[10,"gt","","",10],[10,"ge","","",10],[10,"eq","","",10],[10,"ne","","",10],[10,"cmp","","",10],[10,"is_compatible","","",10],[0,"draw","device","Command Buffer device interface"],[6,"CommandBuffer","device::draw",""],[9,"new","","An empty constructor",11],[9,"clear","","Clear the command buffer contents, retain the allocated storage",11],[9,"bind_program","","",11],[9,"bind_array_buffer","","",11],[9,"bind_attribute","","",11],[9,"bind_index","","",11],[9,"bind_frame_buffer","","",11],[9,"unbind_target","","Unbind any surface from the specified target slot",11],[9,"bind_target_surface","","Bind a surface to the specified target slot",11],[9,"bind_target_texture","","Bind a level of the texture to the specified target slot",11],[9,"bind_uniform_block","","",11],[9,"bind_uniform","","",11],[9,"bind_texture","","",11],[9,"set_primitive","","",11],[9,"set_viewport","","",11],[9,"set_scissor","","",11],[9,"set_depth_stencil","","",11],[9,"set_blend","","",11],[9,"set_color_mask","","",11],[9,"update_buffer","","",11],[9,"update_texture","","",11],[9,"call_clear","","",11],[9,"call_draw","","",11],[9,"call_draw_indexed","","",11],[0,"shade","device","Shader handling."],[1,"Attribute","device::shade","Vertex information that a shader takes as input."],[11,"name","","Name of this attribute.",12],[11,"location","","Vertex attribute binding.",12],[11,"count","","Number of elements this attribute represents.",12],[11,"base_type","","Type that this attribute is composed of.",12],[11,"container","","\"Scalarness\" of this attribute.",12],[1,"UniformVar","","Uniform, a type of shader parameter representing data passed to the program."],[11,"name","","Name of this uniform.",13],[11,"location","","Location of this uniform in the program.",13],[11,"count","","Number of elements this uniform represents.",13],[11,"base_type","","Type that this uniform is composed of",13],[11,"container","","\"Scalarness\" of this uniform.",13],[1,"BlockVar","","A uniform block."],[11,"name","","Name of this uniform block.",14],[11,"size","","Size (in bytes) of this uniform block's data.",14],[11,"usage","","What program stage this uniform block can be used in, as a bitflag.",14],[1,"SamplerVar","","Sampler, a type of shader parameter representing a texture that can be sampled."],[11,"name","","Name of this sampler variable.",15],[11,"location","","Location of this sampler in the program.",15],[11,"base_type","","Base type for the sampler.",15],[11,"sampler_type","","Type of this sampler.",15],[1,"ProgramInfo","","Metadata about a program."],[11,"attributes","","Attributes in the program.",16],[11,"uniforms","","Uniforms in the program",16],[11,"blocks","","Uniform blocks in the program",16],[11,"textures","","Samplers in the program",16],[1,"ShaderSource","","A type storing shader source for different graphics APIs and versions."],[11,"glsl_120","","",17],[11,"glsl_150","","",17],[2,"IsArray","","Whether the sampler samples an array texture."],[12,"Array","","",18],[12,"NoArray","","",18],[2,"IsShadow","","Whether the sampler samples a shadow texture (texture with a depth comparison)"],[12,"Shadow","","",19],[12,"NoShadow","","",19],[2,"IsMultiSample","","Whether the sampler samples a multisample texture."],[12,"MultiSample","","",20],[12,"NoMultiSample","","",20],[2,"IsRect","","Whether the sampler samples a rectangle texture."],[12,"Rect","","",21],[12,"NoRect","","",21],[2,"MatrixFormat","","Whether the matrix is column or row major."],[12,"ColumnMajor","","",22],[12,"RowMajor","","",22],[2,"SamplerType","","What texture type this sampler samples from."],[12,"SamplerBuffer","","Sample from a buffer.",23],[12,"Sampler1D","","Sample from a 1D texture",23],[12,"Sampler2D","","Sample from a 2D texture",23],[12,"Sampler3D","","Sample from a 3D texture",23],[12,"SamplerCube","","Sample from a cubemap.",23],[2,"BaseType","","Base type of this shader parameter."],[12,"BaseF32","","",24],[12,"BaseF64","","",24],[12,"BaseI32","","",24],[12,"BaseU32","","",24],[12,"BaseBool","","",24],[2,"ContainerType","","Number of components this parameter represents."],[12,"Single","","Scalar value",25],[12,"Vector","","A vector with `Dimension` components.",25],[12,"Matrix","","A matrix.",25],[2,"Stage","","Which program stage this shader represents."],[12,"Vertex","","",26],[12,"Geometry","","",26],[12,"Fragment","","",26],[2,"UniformValue","","A value that can be uploaded to the device as a uniform."],[12,"ValueI32","","",27],[12,"ValueF32","","",27],[12,"ValueI32Vector2","","",27],[12,"ValueI32Vector3","","",27],[12,"ValueI32Vector4","","",27],[12,"ValueF32Vector2","","",27],[12,"ValueF32Vector3","","",27],[12,"ValueF32Vector4","","",27],[12,"ValueF32Matrix2","","",27],[12,"ValueF32Matrix3","","",27],[12,"ValueF32Matrix4","","",27],[2,"CompatibilityError","","Error type for trying to store a UniformValue in a UniformVar."],[12,"ErrorArraySize","","Array sizes differ between the value and the var (trying to upload a vec2 as a vec4, etc)",28],[12,"ErrorBaseType","","Base types differ between the value and the var (trying to upload a f32 as a u16, etc)",28],[12,"ErrorContainer","","Container-ness differs between the value and the var (trying to upload a scalar as a vec4,\netc)",28],[2,"Bytes","","Like `MaybeOwned` but for u8."],[12,"StaticBytes","","",29],[12,"OwnedBytes","","",29],[2,"CreateShaderError","","An error type for creating programs."],[12,"NoSupportedShaderProvided","","The device does not support any of the shaders supplied.",30],[12,"ShaderCompilationFailed","","The shader failed to compile.",30],[2,"ShaderModel","","Shader model supported by the device, corresponds to the HLSL shader models."],[12,"ModelUnsupported","","",31],[12,"Model30","","",31],[12,"Model40","","",31],[12,"Model41","","",31],[12,"Model50","","",31],[4,"Dimension","","Number of components in a container type (vectors/matrices)"],[4,"Location","","Location of a parameter in the program."],[10,"fmt","","",18],[10,"eq","","",18],[10,"ne","","",18],[10,"clone","","",18],[10,"fmt","","",19],[10,"eq","","",19],[10,"ne","","",19],[10,"clone","","",19],[10,"fmt","","",20],[10,"eq","","",20],[10,"ne","","",20],[10,"clone","","",20],[10,"fmt","","",21],[10,"eq","","",21],[10,"ne","","",21],[10,"clone","","",21],[10,"fmt","","",22],[10,"eq","","",22],[10,"ne","","",22],[10,"clone","","",22],[10,"fmt","","",23],[10,"eq","","",23],[10,"ne","","",23],[10,"clone","","",23],[10,"fmt","","",24],[10,"eq","","",24],[10,"ne","","",24],[10,"clone","","",24],[10,"fmt","","",25],[10,"eq","","",25],[10,"ne","","",25],[10,"clone","","",25],[10,"fmt","","",26],[10,"is_same_type","","Whether two `UniformValue`s have the same type.",27],[10,"clone","","",27],[10,"fmt","","",27],[10,"fmt","","",12],[10,"clone","","",12],[10,"fmt","","",13],[10,"clone","","",13],[10,"fmt","","",14],[10,"clone","","",14],[10,"fmt","","",15],[10,"clone","","",15],[10,"fmt","","",16],[10,"clone","","",16],[10,"fmt","","",28],[10,"is_compatible","","Whether a value is compatible with this variable. That is, whether the value can be stored\nin this variable.",13],[10,"clone","","",29],[10,"eq","","",29],[10,"ne","","",29],[10,"fmt","","",29],[10,"as_slice","","Get the byte data as a slice.",29],[10,"fmt","","",17],[10,"eq","","",17],[10,"ne","","",17],[10,"clone","","",17],[10,"fmt","","",30],[10,"eq","","",30],[10,"ne","","",30],[10,"clone","","",30],[10,"fmt","","",31],[10,"partial_cmp","","",31],[10,"lt","","",31],[10,"le","","",31],[10,"gt","","",31],[10,"ge","","",31],[10,"eq","","",31],[10,"ne","","",31],[10,"clone","","",31],[10,"to_number","","Return the shader model as a numeric value.",31],[0,"state","device","Fixed-function hardware state."],[1,"Primitive","device::state","Primitive rasterization state. Note that GL allows different raster\nmethod to be used for front and back, while this abstraction does not."],[11,"front_face","","Which vertex winding is considered to be the front face for culling.",32],[11,"method","","How to rasterize this primitive.",32],[11,"offset","","Any polygon offset to apply.",32],[1,"StencilSide","","Complete stencil state for a given side of a face."],[11,"fun","","Comparison function to use to determine if the stencil test passes.",33],[11,"value","","Reference value to compare the value in the stencil buffer with.",33],[11,"mask_read","","A mask that is ANDd with both the stencil buffer value and the reference value when they\nare read before doing the stencil test.",33],[11,"mask_write","","This is unused!",33],[11,"op_fail","","What operation to do if the stencil test fails.",33],[11,"op_depth_fail","","What operation to do if the stenil test passes but the depth test fails.",33],[11,"op_pass","","What operation to do if both the depth and stencil test pass.",33],[1,"Stencil","","Complete stencil state, specifying how to handle the front and back side of a face."],[11,"front","","",34],[11,"back","","",34],[1,"Depth","","Depth test state."],[11,"fun","","Comparison function to use.",35],[11,"write","","Specify whether to write to the depth buffer or not.",35],[1,"Factor","",""],[1,"BlendChannel","",""],[11,"equation","","",36],[11,"source","","",36],[11,"destination","","",36],[1,"Blend","",""],[11,"color","","",37],[11,"alpha","","",37],[11,"value","","",37],[1,"ColorMask","",""],[2,"WindingOrder","","The winding order of a set of vertices."],[12,"Clockwise","","Clockwise winding order.",38],[12,"CounterClockwise","","Counter-clockwise winding order.",38],[2,"OffsetType","","How to offset vertices in screen space, if at all."],[12,"NoOffset","","",39],[12,"Offset","","",39],[2,"CullMode","","Which face, if any, to cull."],[12,"CullNothing","","",40],[12,"CullFront","","",40],[12,"CullBack","","",40],[2,"RasterMethod","","How to rasterize a primitive."],[12,"Point","","Rasterize as a point.",41],[12,"Line","","Rasterize as a line with the given width.",41],[12,"Fill","","Rasterize as a face with a given cull mode.",41],[2,"Comparison","","A pixel-wise comparison function."],[12,"Never","","`false`",42],[12,"Less","","`x < y`",42],[12,"LessEqual","","`x <= y`",42],[12,"Equal","","`x == y`",42],[12,"GreaterEqual","","`x >= y`",42],[12,"Greater","","`x > y`",42],[12,"NotEqual","","`x != y`",42],[12,"Always","","`true`",42],[2,"StencilOp","","Stencil mask operation."],[12,"OpKeep","","Keep the current value in the stencil buffer (no change).",43],[12,"OpZero","","Set the value in the stencil buffer to zero.",43],[12,"OpReplace","","Set the stencil buffer value to `value` from `StencilSide`",43],[12,"OpIncrementClamp","","Increment the stencil buffer value, clamping to its maximum value.",43],[12,"OpIncrementWrap","","Increment the stencil buffer value, wrapping around to 0 on overflow.",43],[12,"OpDecrementClamp","","Decrement the stencil buffer value, clamping to its minimum value.",43],[12,"OpDecrementWrap","","Decrement the stencil buffer value, wrapping around to the maximum value on overflow.",43],[12,"OpInvert","","Bitwise invert the current value in the stencil buffer.",43],[2,"Equation","",""],[12,"FuncAdd","","",44],[12,"FuncSub","","",44],[12,"FuncRevSub","","",44],[12,"FuncMin","","",44],[12,"FuncMax","","",44],[2,"InverseFlag","",""],[12,"Normal","","",45],[12,"Inverse","","",45],[2,"BlendValue","",""],[12,"Zero","","",46],[12,"SourceColor","","",46],[12,"SourceAlpha","","",46],[12,"SourceAlphaSaturated","","",46],[12,"DestColor","","",46],[12,"DestAlpha","","",46],[12,"ConstColor","","",46],[12,"ConstAlpha","","",46],[4,"LineWidth","","Width of a line."],[4,"OffsetFactor","",""],[4,"OffsetUnits","",""],[5,"Red","",""],[5,"Green","",""],[5,"Blue","",""],[5,"Alpha","",""],[5,"MaskAll","",""],[10,"fmt","","",38],[10,"eq","","",38],[10,"ne","","",38],[10,"clone","","",38],[10,"fmt","","",39],[10,"eq","","",39],[10,"ne","","",39],[10,"clone","","",39],[10,"fmt","","",40],[10,"eq","","",40],[10,"ne","","",40],[10,"clone","","",40],[10,"fmt","","",41],[10,"eq","","",41],[10,"ne","","",41],[10,"clone","","",41],[10,"fmt","","",32],[10,"eq","","",32],[10,"ne","","",32],[10,"clone","","",32],[10,"get_cull_mode","","Get the cull mode, if any, for this primitive state.",32],[10,"default","","",32],[10,"fmt","","",42],[10,"eq","","",42],[10,"ne","","",42],[10,"clone","","",42],[10,"fmt","","",43],[10,"eq","","",43],[10,"ne","","",43],[10,"clone","","",43],[10,"fmt","","",33],[10,"eq","","",33],[10,"ne","","",33],[10,"clone","","",33],[10,"default","","",33],[10,"fmt","","",34],[10,"eq","","",34],[10,"ne","","",34],[10,"clone","","",34],[10,"fmt","","",35],[10,"eq","","",35],[10,"ne","","",35],[10,"clone","","",35],[10,"default","","",35],[10,"fmt","","",44],[10,"eq","","",44],[10,"ne","","",44],[10,"clone","","",44],[10,"fmt","","",45],[10,"eq","","",45],[10,"ne","","",45],[10,"clone","","",45],[10,"fmt","","",46],[10,"eq","","",46],[10,"ne","","",46],[10,"clone","","",46],[10,"fmt","","",47],[10,"eq","","",47],[10,"ne","","",47],[10,"clone","","",47],[10,"fmt","","",36],[10,"eq","","",36],[10,"ne","","",36],[10,"clone","","",36],[10,"default","","",36],[10,"default","","",37],[10,"eq","","",37],[10,"clone","","",37],[10,"fmt","","",37],[10,"hash","","",48],[10,"cmp","","",48],[10,"partial_cmp","","",48],[10,"lt","","",48],[10,"le","","",48],[10,"gt","","",48],[10,"ge","","",48],[10,"clone","","",48],[10,"eq","","",48],[10,"ne","","",48],[10,"empty","","Returns an empty set of flags.",48],[10,"all","","Returns the set containing all flags.",48],[10,"bits","","Returns the raw value of the flags currently stored.",48],[10,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",48],[10,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",48],[10,"is_empty","","Returns `true` if no flags are currently stored.",48],[10,"is_all","","Returns `true` if all flags are currently set.",48],[10,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",48],[10,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",48],[10,"insert","","Inserts the specified flags in-place.",48],[10,"remove","","Removes the specified flags in-place.",48],[10,"bitor","","Returns the union of the two sets of flags.",48],[10,"bitand","","Returns the intersection between the two sets of flags.",48],[10,"sub","","Returns the set difference of the two sets of flags.",48],[10,"not","","Returns the complement of this set of flags.",48],[10,"fmt","","",48],[0,"target","device","Render target specification."],[1,"Rect","device::target","A screen space rectangle"],[11,"x","","",49],[11,"y","","",49],[11,"w","","",49],[11,"h","","",49],[1,"ClearData","","How to clear a frame."],[11,"color","","If set, the color buffer of the frame will be cleared to this.",50],[11,"depth","","If set, the depth buffer of the frame will be cleared to this.",50],[11,"stencil","","If set, the stencil buffer of the frame will be cleared to this.",50],[2,"Target","","When rendering, each \"output\" of the fragment shader goes to a specific target. A `Plane` can\nbe bound to a target, causing writes to that target to affect the `Plane`."],[12,"TargetColor","","Color data.",51],[12,"TargetDepth","","Depth data.",51],[12,"TargetStencil","","Stencil data.",51],[12,"TargetDepthStencil","","A target for both depth and stencil data at once.",51],[4,"Layer","","A depth value, specifying which plane to select out of a 3D texture."],[4,"Level","","Mipmap level to select in a texture."],[4,"Depth","","A single depth value from a depth buffer."],[4,"Stencil","","A single value from a stencil stencstencil buffer."],[4,"Color","","A color with floating-point components."],[10,"fmt","","",49],[10,"eq","","",49],[10,"ne","","",49],[10,"clone","","",49],[10,"clone","","",50],[10,"fmt","","",50],[10,"fmt","","",51],[10,"clone","","",51],[0,"tex","device","Texture creation and modification."],[1,"SurfaceInfo","device::tex","Describes the storage of a surface"],[11,"width","","",52],[11,"height","","",52],[11,"format","","",52],[1,"TextureInfo","","Describes the storage of a texture."],[11,"width","","",53],[11,"height","","",53],[11,"depth","","",53],[11,"levels","","Number of mipmap levels. Defaults to -1, which stands for unlimited.\nMipmap levels at equal or above `levels` can not be loaded or sampled\nby the shader. width and height of each consecutive mipmap level is\nhalved, starting from level 0.",53],[11,"kind","","",53],[11,"format","","",53],[1,"ImageInfo","","Describes a subvolume of a texture, which image data can be uploaded into."],[11,"xoffset","","",54],[11,"yoffset","","",54],[11,"zoffset","","",54],[11,"width","","",54],[11,"height","","",54],[11,"depth","","",54],[11,"format","","Format of each texel.",54],[11,"mipmap","","Which mipmap to select.",54],[1,"SamplerInfo","","Specifies how to sample from a texture."],[11,"filtering","","Filter method to use.",55],[11,"wrap_mode","","Wrapping mode for each of the U, V, and W axis (S, T, and R in OpenGL\nspeak)",55],[11,"lod_bias","","This bias is added to every computed mipmap level (N + lod_bias). For\nexample, if it would select mipmap level 2 and lod_bias is 1, it will\nuse mipmap level 3.",55],[11,"lod_range","","This range is used to clamp LOD level used for sampling",55],[2,"SurfaceError","","Surface creation/update error."],[12,"UnsupportedSurfaceFormat","","Failed to map a given format to the device",56],[2,"TextureError","","Texture creation/update error."],[12,"UnsupportedTextureFormat","","Failed to map a given format to the device",57],[2,"Components","","Describes the component layout of each texel."],[12,"R","","Red only",58],[12,"RG","","Red and green",58],[12,"RGB","","Red, green, blue",58],[12,"RGBA","","Red, green, blue, alpha",58],[2,"Format","","Describes the layout of each texel within a surface/texture."],[12,"Float","","Floating point.",59],[12,"Integer","","Signed integer.",59],[12,"Unsigned","","Unsigned integer.",59],[12,"R3G3B2","","Normalized integer, with 3 bits for R and G, but only 2 for B.",59],[12,"RGB5A1","","5 bits each for RGB, 1 for Alpha.",59],[12,"RGB10A2","","10 bits each for RGB, 2 for Alpha.",59],[12,"RGB10A2UI","","10 bits each for RGB, 2 for Alpha, as unsigned integers.",59],[12,"R11FG11FB10F","","This uses special 11 and 10-bit floating-point values without sign bits.",59],[12,"RGB9E5","","This s an RGB format of type floating-point. The 3 color values have\n9 bits of precision, and they share a single exponent.",59],[12,"DEPTH24STENCIL8","","24 bits for depth, 8 for stencil",59],[2,"FilterMethod","","How to [filter](https://en.wikipedia.org/wiki/Texture_filtering) the\ntexture when sampling. They correspond to increasing levels of quality,\nbut also cost. They \"layer\" on top of each other: it is not possible to\nhave bilinear filtering without mipmapping, for example."],[12,"Scale","","The dumbest filtering possible, nearest-neighbor interpolation.",60],[12,"Mipmap","","Add simple mipmapping.",60],[12,"Bilinear","","Sample multiple texels within a single mipmap level to increase\nquality.",60],[12,"Trilinear","","Sample multiple texels across two mipmap levels to increase quality.",60],[12,"Anisotropic","","Anisotropic filtering with a given \"max\", must be between 1 and 16,\ninclusive.",60],[2,"TextureKind","","Specifies how a given texture may be used. The available texture types are\nrestricted by what Metal exposes, though this could conceivably be\nextended in the future. Note that a single texture can *only* ever be of\none kind. A texture created as `Texture2D` will forever be `Texture2D`."],[12,"Texture1D","","A single row of texels.",61],[12,"Texture1DArray","","An array of rows of texels. Equivalent to Texture2D except that texels\nin a different row are not sampled.",61],[12,"Texture2D","","A traditional 2D texture, with rows arranged contiguously.",61],[12,"Texture2DArray","","An array of 2D textures. Equivalent to Texture3D except that texels in\na different depth level are not sampled.",61],[12,"TextureCube","","A set of 6 2D textures, one for each face of a cube.",61],[12,"Texture3D","","A volume texture, with each 2D layer arranged contiguously.",61],[2,"WrapMode","","Specifies how texture coordinates outside the range `[0, 1]` are handled."],[12,"Tile","","Tile the texture. That is, sample the coordinate modulo `1.0`. This is\nthe default.",62],[12,"Mirror","","Mirror the texture. Like tile, but uses abs(coord) before the modulo.",62],[12,"Clamp","","Clamp the texture to the value at `0.0` or `1.0` respectively.",62],[4,"Bits","","Number of bits per component"],[5,"RGBA8","","A commonly used RGBA8 format"],[10,"fmt","","",56],[10,"eq","","",56],[10,"ne","","",56],[10,"clone","","",56],[10,"fmt","","",57],[10,"eq","","",57],[10,"ne","","",57],[10,"clone","","",57],[10,"fmt","","",58],[10,"clone","","",58],[10,"hash","","",58],[10,"partial_cmp","","",58],[10,"lt","","",58],[10,"le","","",58],[10,"gt","","",58],[10,"ge","","",58],[10,"eq","","",58],[10,"ne","","",58],[10,"cmp","","",58],[10,"fmt","","",59],[10,"clone","","",59],[10,"hash","","",59],[10,"partial_cmp","","",59],[10,"lt","","",59],[10,"le","","",59],[10,"gt","","",59],[10,"ge","","",59],[10,"eq","","",59],[10,"ne","","",59],[10,"cmp","","",59],[10,"fmt","","",52],[10,"clone","","",52],[10,"hash","","",52],[10,"partial_cmp","","",52],[10,"lt","","",52],[10,"le","","",52],[10,"gt","","",52],[10,"ge","","",52],[10,"eq","","",52],[10,"ne","","",52],[10,"cmp","","",52],[10,"fmt","","",60],[10,"clone","","",60],[10,"hash","","",60],[10,"partial_cmp","","",60],[10,"lt","","",60],[10,"le","","",60],[10,"gt","","",60],[10,"ge","","",60],[10,"eq","","",60],[10,"ne","","",60],[10,"cmp","","",60],[10,"fmt","","",61],[10,"clone","","",61],[10,"hash","","",61],[10,"partial_cmp","","",61],[10,"lt","","",61],[10,"le","","",61],[10,"gt","","",61],[10,"ge","","",61],[10,"eq","","",61],[10,"ne","","",61],[10,"cmp","","",61],[10,"fmt","","",53],[10,"clone","","",53],[10,"hash","","",53],[10,"partial_cmp","","",53],[10,"lt","","",53],[10,"le","","",53],[10,"gt","","",53],[10,"ge","","",53],[10,"eq","","",53],[10,"ne","","",53],[10,"cmp","","",53],[10,"fmt","","",54],[10,"clone","","",54],[10,"hash","","",54],[10,"partial_cmp","","",54],[10,"lt","","",54],[10,"le","","",54],[10,"gt","","",54],[10,"ge","","",54],[10,"eq","","",54],[10,"ne","","",54],[10,"cmp","","",54],[10,"default","","",54],[10,"default","","",53],[10,"new","","Create a new empty texture info",53],[10,"to_image_info","","Convert to a default ImageInfo that could be used\nto update the contents of the whole texture",53],[10,"contains","","Check if given ImageInfo is a part of the texture",53],[10,"new","","Create a new `ImageInfo`, using default values.",54],[10,"fmt","","",62],[10,"clone","","",62],[10,"hash","","",62],[10,"partial_cmp","","",62],[10,"lt","","",62],[10,"le","","",62],[10,"gt","","",62],[10,"ge","","",62],[10,"eq","","",62],[10,"ne","","",62],[10,"cmp","","",62],[10,"fmt","","",55],[10,"clone","","",55],[10,"partial_cmp","","",55],[10,"lt","","",55],[10,"le","","",55],[10,"gt","","",55],[10,"ge","","",55],[10,"eq","","",55],[10,"ne","","",55],[10,"new","","Create a new sampler description with a given filter method and wrapping mode, using no LOD\nmodifications.",55],[4,"ActualCommandBuffer","device",""],[4,"VertexCount","","Draw vertex count."],[4,"IndexCount","","Draw index count."],[4,"UniformBlockIndex","","Index of a uniform block."],[4,"AttributeSlot","","Slot for an attribute."],[4,"UniformBufferSlot","","Slot for a uniform buffer object."],[4,"TextureSlot","","Slot a texture can be bound to."],[4,"RawBufferHandle","","Raw (untyped) Buffer Handle"],[4,"ArrayBufferHandle","","Array Buffer Handle"],[4,"ShaderHandle","","Shader Handle"],[4,"ProgramHandle","","Program Handle"],[4,"FrameBufferHandle","","Frame Buffer Handle"],[4,"SurfaceHandle","","Surface Handle"],[4,"TextureHandle","","Texture Handle"],[4,"SamplerHandle","","Sampler Handle"],[4,"IndexType","","A type of each index value in the mesh's index buffer"],[6,"Blob","","A trait that slice-like types implement."],[9,"get_address","","Get the address to the data this `Blob` stores.",63],[9,"get_size","","Get the number of bytes in this blob.",63],[6,"RefBlobCast","","Helper trait for casting &Blob"],[9,"cast","","Cast the type the blob references",64],[6,"BoxBlobCast","","Helper trait for casting Box<Blob>"],[9,"cast","","Cast the type the blob references",65],[6,"Device","","An interface for performing draw calls using a specific graphics API"],[9,"get_capabilities","","Returns the capabilities available to the specific API implementation",66],[9,"create_buffer_raw","","",66],[10,"create_buffer","","",66],[9,"create_buffer_static","","",66],[9,"create_array_buffer","","",66],[9,"create_shader","","",66],[9,"create_program","","",66],[9,"create_frame_buffer","","",66],[9,"create_surface","","",66],[9,"create_texture","","",66],[9,"create_sampler","","",66],[9,"delete_buffer_raw","","",66],[10,"delete_buffer","","",66],[9,"delete_shader","","",66],[9,"delete_program","","",66],[9,"delete_surface","","",66],[9,"delete_texture","","",66],[9,"delete_sampler","","",66],[9,"update_buffer_raw","","Update the information stored in a specific buffer",66],[10,"update_buffer","","",66],[9,"update_texture_raw","","Update the information stored in a texture",66],[10,"update_texture","","",66],[9,"generate_mipmap","","",66],[9,"submit","","Submit a command buffer for execution",66],[10,"fmt","","",67],[10,"clone","","",67],[10,"get_name","","Get the internal name",67],[10,"get_info","","Get the info reference",67],[10,"eq","","",67],[10,"clone","","",68],[10,"fmt","","",68],[10,"from_raw","","Create a type-safe BufferHandle from a RawBufferHandle",68],[10,"cast","","Cast the type this BufferHandle references",68],[10,"get_name","","Get the underlying GL name for this BufferHandle",68],[10,"get_info","","Get the associated information about the buffer",68],[10,"raw","","Get the underlying raw Handle",68],[10,"fmt","","",0],[10,"cast","alloc::boxed","",69],[10,"get_address","collections::vec","",70],[10,"get_size","","",70],[10,"fmt","alloc::boxed","",69],[10,"fmt","device","",2],[10,"eq","","",2],[10,"ne","","",2],[10,"clone","","",2],[10,"fmt","","",3],[10,"eq","","",3],[10,"ne","","",3],[10,"clone","","",3],[10,"fmt","","",1],[10,"eq","","",1],[10,"ne","","",1],[10,"clone","","",1],[10,"fmt","","",4]],"paths":[[1,"Capabilities"],[1,"BufferInfo"],[2,"PrimitiveType"],[2,"BufferUsage"],[2,"Command"],[2,"SignFlag"],[2,"IntSubType"],[2,"IntSize"],[2,"FloatSubType"],[2,"FloatSize"],[2,"Type"],[6,"CommandBuffer"],[1,"Attribute"],[1,"UniformVar"],[1,"BlockVar"],[1,"SamplerVar"],[1,"ProgramInfo"],[1,"ShaderSource"],[2,"IsArray"],[2,"IsShadow"],[2,"IsMultiSample"],[2,"IsRect"],[2,"MatrixFormat"],[2,"SamplerType"],[2,"BaseType"],[2,"ContainerType"],[2,"Stage"],[2,"UniformValue"],[2,"CompatibilityError"],[2,"Bytes"],[2,"CreateShaderError"],[2,"ShaderModel"],[1,"Primitive"],[1,"StencilSide"],[1,"Stencil"],[1,"Depth"],[1,"BlendChannel"],[1,"Blend"],[2,"WindingOrder"],[2,"OffsetType"],[2,"CullMode"],[2,"RasterMethod"],[2,"Comparison"],[2,"StencilOp"],[2,"Equation"],[2,"InverseFlag"],[2,"BlendValue"],[1,"Factor"],[1,"ColorMask"],[1,"Rect"],[1,"ClearData"],[2,"Target"],[1,"SurfaceInfo"],[1,"TextureInfo"],[1,"ImageInfo"],[1,"SamplerInfo"],[2,"SurfaceError"],[2,"TextureError"],[2,"Components"],[2,"Format"],[2,"FilterMethod"],[2,"TextureKind"],[2,"WrapMode"],[6,"Blob"],[6,"RefBlobCast"],[6,"BoxBlobCast"],[6,"Device"],[1,"Handle"],[1,"BufferHandle"],[1,"Box"],[1,"Vec"]]};

searchIndex['gl_generator'] = {"items":[[0,"","gl_generator","# gl_generator"],[0,"static_gen","",""],[1,"StaticGenerator","gl_generator::static_gen",""],[10,"write","","",0],[0,"struct_gen","gl_generator",""],[1,"StructGenerator","gl_generator::struct_gen",""],[10,"write","","",1],[0,"registry","gl_generator",""],[1,"Registry","gl_generator::registry",""],[11,"groups","","",2],[11,"enums","","",2],[11,"cmds","","",2],[11,"features","","",2],[11,"extensions","","",2],[1,"EnumIterator","",""],[1,"CmdIterator","",""],[1,"Group","",""],[11,"name","","",3],[11,"enums","","",3],[1,"EnumNs","",""],[11,"namespace","","",4],[11,"group","","",4],[11,"ty","","",4],[11,"start","","",4],[11,"end","","",4],[11,"vendor","","",4],[11,"comment","","",4],[11,"defs","","",4],[1,"Enum","",""],[11,"ident","","",5],[11,"value","","",5],[11,"alias","","",5],[11,"ty","","",5],[1,"CmdNs","",""],[11,"namespace","","",6],[11,"defs","","",6],[1,"Binding","",""],[11,"ident","","",7],[11,"ty","","",7],[11,"group","","",7],[1,"Cmd","",""],[11,"proto","","",8],[11,"params","","",8],[11,"is_safe","","",8],[11,"alias","","",8],[11,"vecequiv","","",8],[11,"glx","","",8],[1,"Feature","",""],[11,"api","","",9],[11,"name","","",9],[11,"number","","",9],[11,"requires","","",9],[11,"removes","","",9],[1,"Require","",""],[11,"comment","","",10],[11,"enums","","A reference to the earlier types, by name",10],[11,"commands","","A reference to the earlier types, by name",10],[1,"Remove","",""],[11,"profile","","",11],[11,"comment","","",11],[11,"enums","","A reference to the earlier types, by name",11],[11,"commands","","A reference to the earlier types, by name",11],[1,"Extension","",""],[11,"name","","",12],[11,"supported","","which apis this extension is defined for (see Feature.api)",12],[11,"requires","","",12],[1,"GlxOpcode","",""],[11,"ty","","",13],[11,"opcode","","",13],[11,"name","","",13],[11,"comment","","",13],[1,"Filter","",""],[11,"extensions","","",14],[11,"profile","","",14],[11,"version","","",14],[11,"api","","",14],[2,"Ns","",""],[12,"Gl","","",15],[12,"Glx","","",15],[12,"Wgl","","",15],[6,"FromXML","",""],[9,"convert","","",16],[10,"from_str","","",15],[10,"fmt","","",15],[10,"fmt","","",15],[10,"from_xml","","Generate a registry from the supplied XML string",2],[10,"get_tys","","Returns a set of all the types used in the supplied registry. This is useful\nfor working out what conversions are needed for the specific registry.",2],[10,"enum_iter","","",2],[10,"cmd_iter","","",2],[10,"next","","",17],[10,"next","","",18],[10,"clone","","",9],[10,"clone","","",10],[10,"clone","","",11],[10,"clone","","",12],[10,"convert","","",10],[10,"convert","","",11],[10,"convert","","",9],[10,"convert","","",12],[10,"convert","collections::string","",19],[0,"ty","gl_generator",""],[3,"to_return_suffix","gl_generator::ty",""],[3,"to_rust_ty","","Converts a C style type definition to the Rust equivalent"],[4,"Src","",""],[5,"GL_ALIASES","",""],[5,"X_ALIASES","",""],[5,"GLX_ALIASES","",""],[5,"WIN_ALIASES","",""],[5,"WGL_ALIASES","",""]],"paths":[[1,"StaticGenerator"],[1,"StructGenerator"],[1,"Registry"],[1,"Group"],[1,"EnumNs"],[1,"Enum"],[1,"CmdNs"],[1,"Binding"],[1,"Cmd"],[1,"Feature"],[1,"Require"],[1,"Remove"],[1,"Extension"],[1,"GlxOpcode"],[1,"Filter"],[2,"Ns"],[6,"FromXML"],[1,"EnumIterator"],[1,"CmdIterator"],[1,"String"]]};

searchIndex['image'] = {"items":[[0,"","image","This crate provides native rust implementations of\nImage encoders and decoders and basic image manipulation\nfunctions."],[1,"Luma","","A type to hold a grayscale pixel"],[1,"LumaA","","A type to hold a grayscale pixel with an alpha channel"],[1,"Rgb","","A type to hold an RGB pixel"],[1,"Rgba","","A type to hold an RGB pixel with an alpha channel"],[1,"SubImage","","A View into another image"],[1,"ImageBuf","","An Image whose pixels are contained within a vector"],[1,"Pixels","","Immutable pixel iterator"],[1,"MutPixels","","Mutable pixel iterator"],[2,"ColorType","","An enumeration over supported color types and their bit depths"],[12,"Grey","","Pixel is greyscale",0],[12,"RGB","","Pixel contains R, G and B channels",0],[12,"Palette","","Pixel is an index into a color palette",0],[12,"GreyA","","Pixel is greyscale with an alpha channel",0],[12,"RGBA","","Pixel is RGB with an alpha channel",0],[2,"ImageError","","An enumeration of Image Errors"],[12,"FormatError","","The Image is not formatted properly",1],[12,"DimensionError","","The Image's dimensions are either too small or too large",1],[12,"UnsupportedError","","The Decoder does not support this image format",1],[12,"UnsupportedColor","","The Decoder does not support this color type",1],[12,"NotEnoughData","","Not enough data was provided to the Decoder\nto decode the image",1],[12,"IoError","","An I/O Error occurred while decoding the image",1],[12,"ImageEnd","","The end of the image has been reached",1],[2,"ImageFormat","","An enumeration of supported image formats.\nNot all formats support both encoding and decoding."],[12,"PNG","","An Image in PNG Format",2],[12,"JPEG","","An Image in JPEG Format",2],[12,"GIF","","An Image in GIF Format",2],[12,"WEBP","","An Image in WEBP Format",2],[12,"PPM","","An Image in PPM Format",2],[2,"FilterType","","Available Sampling Filters"],[12,"Nearest","","Nearest Neighbor",3],[12,"Triangle","","Linear Filter",3],[12,"CatmullRom","","Cubic Filter",3],[12,"Gaussian","","Gaussian Filter",3],[12,"Lanczos3","","Lanczos with window 3",3],[2,"DynamicImage","","A Dynamic Image"],[12,"ImageLuma8","","Each pixel in this image is 8-bit Luma",4],[12,"ImageLumaA8","","Each pixel in this image is 8-bit Luma with alpha",4],[12,"ImageRgb8","","Each pixel in this image is 8-bit Rgb",4],[12,"ImageRgba8","","Each pixel in this image is 8-bit Rgb with alpha",4],[3,"open","","Open the image located at the path specified.\nThe image's format is determined from the path's file extension."],[3,"load","","Create a new image from a Reader"],[3,"load_from_memory","","Create a new image from a byte slice"],[0,"imageops","","Image Processing Functions"],[2,"FilterType","image::imageops","Available Sampling Filters"],[12,"Nearest","","Nearest Neighbor",3],[12,"Triangle","","Linear Filter",3],[12,"CatmullRom","","Cubic Filter",3],[12,"Gaussian","","Gaussian Filter",3],[12,"Lanczos3","","Lanczos with window 3",3],[3,"rotate90","","Rotate an image 90 degrees clockwise."],[3,"rotate180","","Rotate an image 180 degrees clockwise."],[3,"rotate270","","Rotate an image 270 degrees clockwise."],[3,"flip_horizontal","","Flip an image horizontally"],[3,"flip_vertical","","Flip an image vertically"],[3,"filter3x3","","Perform a 3x3 box filter on the supplied image.\n```kernel``` is an array of the filter weights of length 9."],[3,"resize","","Resize the supplied image to the specified dimensions\n```nwidth``` and ```nheight``` are the new dimensions.\n```filter``` is the sampling filter to use."],[3,"blur","","Performs a Gaussian blur on the supplied image.\n```sigma``` is a measure of how much to blur by."],[3,"unsharpen","","Performs an unsharpen mask on the supplied image\n```sigma``` is the amount to blur the image by.\n```threshold``` is the threshold for the difference between\nsee https://en.wikipedia.org/wiki/Unsharp_masking#Digital_unsharp_masking"],[3,"grayscale","","Convert the supplied image to grayscale"],[3,"invert","","Invert each pixel within the supplied image\nThis function operates in place."],[3,"contrast","","Adjust the contrast of the supplied image\n```contrast``` is the amount to adjust the contrast by.\nNegative values decrease the contrast and positive values increase the contrast."],[3,"brighten","","Brighten the supplied image\n```value``` is the amount to brighten each pixel by.\nNegative values decrease the brightness and positive values increase it."],[3,"crop","","Return a mutable view into an image"],[0,"webp","image","Decoding of Webp Images"],[1,"WebpDecoder","image::webp","A Representation of a Webp Image format decoder."],[0,"vp8","","An implementation of the VP8 Video Codec"],[1,"Frame","image::webp::vp8","A Representation of the last decoded video frame"],[11,"width","","The width of the luma plane",5],[11,"height","","The height of the luma plane",5],[11,"ybuf","","The luma plane of the frame",5],[11,"keyframe","","Indicates whether this frame is a keyframe",5],[11,"for_display","","Indicates whether this frame is intended for display",5],[11,"pixel_type","","The pixel type of the frame as defined by Section 9.2\nof the VP8 Specification",5],[1,"VP8Decoder","","VP8 Decoder\nOnly decodes keyframes"],[10,"clone","","",5],[10,"fmt","","",5],[10,"default","","",5],[10,"new","","Create a new decoder.\nThe reader must present a raw vp8 bitstream to the decoder",6],[10,"decode_frame","","Decodes the current frame and returns a reference to it",6],[0,"ppm","image","Encoding of portable pixmap Images"],[1,"PPMEncoder","image::ppm","A representation of a PPM encoder."],[0,"png","image","Decoding and Encoding of PNG Images"],[1,"PNGDecoder","image::png","The representation of a PNG decoder"],[1,"PNGEncoder","","The representation of a PNG encoder"],[0,"zlib","","An Implementation of RFC 1950"],[1,"ZlibDecoder","image::png::zlib","A Zlib compressed stream decoder."],[10,"new","","Create a new decoder that decodes from a Reader",7],[10,"inner","","Return a mutable reference to the wrapped Reader",7],[10,"read","","",7],[0,"deflate","image::png","An Implementation of RFC 1951"],[1,"Inflater","image::png::deflate","A DEFLATE compressed stream decoder."],[10,"new","","Create a new decoder that decodes from a Reader",8],[10,"eof","","Indicate whether the end of the stream has been reached.",8],[10,"inner","","Return a mutable reference to the wrapped Reader",8],[10,"read","","",8],[0,"hash","image::png","This module provides implementations of common hashing algorithms."],[1,"Adler32","image::png::hash","An Implementation of the Adler-32 checksum"],[1,"Crc32","","An Implementation of the Crc-32 checksum"],[10,"new","","Create a new hasher.",9],[10,"update","","Update the internal hasher with the bytes from ```buf```",9],[10,"checksum","","Return the computed hash.",9],[10,"reset","","Reset this hasher to its initial state.",9],[10,"new","","Create a new hasher.",10],[10,"update","","Update the internal hasher with the bytes from ```buf```",10],[10,"checksum","","Return the computed hash.",10],[10,"reset","","Reset this hasher to its initial state.",10],[0,"jpeg","image","Decoding and Encoding of JPEG Images"],[1,"JPEGDecoder","image::jpeg","The representation of a JPEG decoder"],[1,"JPEGEncoder","","The representation of a JPEG encoder"],[1,"Component","","A representation of a JPEG component"],[11,"id","","The Component's identifier",11],[11,"h","","Horizontal sampling factor",11],[11,"v","","Vertical sampling factor",11],[11,"tq","","The quantization table selector",11],[11,"dc_table","","Index to the Huffman DC Table",11],[11,"ac_table","","Index to the AC Huffman Table",11],[11,"dc_pred","","The dc prediction of the component",11],[0,"gif","image","Decoding of GIF Images"],[1,"GIFDecoder","image::gif","The Representation of a GIF decoder"],[0,"lzw","","This modules provides an implementation of the Lempel–Ziv–Welch Compression Algorithm"],[1,"LZWReader","image::gif::lzw","An implementation of an LZW Decompressor."],[10,"new","","Create a new decompressor from a Reader",12],[10,"read","","",12],[4,"ImageResult","image",""],[6,"Pixel","","A trait that all pixels implement."],[9,"from_channels","","Construct a pixel from the 4 channels a, b, c and d.\nIf the pixel does not contain 4 channels the extra are ignored.",13],[9,"to_rgb","","Convert this pixel to RGB",13],[9,"to_rgba","","Convert this pixel to RGB with an alpha channel",13],[9,"to_luma","","Convert this pixel to luma",13],[9,"to_luma_alpha","","Convert this pixel to luma with an alpha channel",13],[9,"invert","","Invert this pixel",13],[9,"map","","Apply the function ```f``` to each channel of this pixel.",13],[9,"map_with_alpha","","Apply the function f to each channel except the alpha channel.\nApply the function g to the alpha channel.",13],[9,"map2","","Apply the function ```f``` to each channel of this pixel and\n```other``` pairwise.",13],[9,"channels4","","Returns the channels of this pixel as a 4 tuple. If the pixel\nhas less than 4 channels the remainder is filled with the maximum value",13],[6,"ImageDecoder","","The trait that all decoders implement"],[9,"dimensions","","Return a tuple containing the width and height of the image",14],[9,"colortype","","Return the color type of the image e.g RGB(8) (8bit RGB)",14],[9,"row_len","","Returns the length in bytes of one decoded row of the image",14],[9,"read_scanline","","Read one row from the image into buf\nReturns the row index",14],[9,"read_image","","Decode the entire image and return it as a Vector",14],[10,"load_rect","","Decode a specific region of the image, represented by the rectangle\nstarting from ```x``` and ```y``` and having ```length``` and ```width```",14],[6,"GenericImage","","A trait for manipulating images."],[9,"dimensions","","The width and height of this image.",15],[9,"bounds","","The bounding rectangle of this image.",15],[9,"get_pixel","","Return the pixel located at (x, y)",15],[9,"put_pixel","","Put a pixel at location (x, y)",15],[10,"pixels","","Return an Iterator over the pixels of this image.\nThe iterator yields the coordinates of each pixel\nalong with their value",15],[6,"MutableRefImage","","A trait for images that allow providing mutable references to pixels."],[9,"get_mut_pixel","","Return a mutable reference to the pixel located at (x, y)",16],[10,"mut_pixels","","Return an Iterator over mutable pixels of this image.\nThe iterator yields the coordinates of each pixel\nalong with a mutable reference to them.",16]],"paths":[[2,"ColorType"],[2,"ImageError"],[2,"ImageFormat"],[2,"FilterType"],[2,"DynamicImage"],[1,"Frame"],[1,"VP8Decoder"],[1,"ZlibDecoder"],[1,"Inflater"],[1,"Adler32"],[1,"Crc32"],[1,"Component"],[1,"LZWReader"],[6,"Pixel"],[6,"ImageDecoder"],[6,"GenericImage"],[6,"MutableRefImage"]]};

searchIndex['cam'] = {"items":[[0,"","cam","A library for 3D camera and navigation."],[1,"Camera","","Models a camera with position and directions."],[11,"position","","The camera position.",0],[11,"up","","The up direction.",0],[11,"right","","The right direction.",0],[11,"forward","","The forward direction.",0],[1,"CameraPerspective","","Models camera perspective settings."],[11,"fov","","Field of view (in degrees).",1],[11,"near_clip","","The near clip distance.",1],[11,"far_clip","","The far clip distance.",1],[11,"aspect_ratio","","The aspect ratio, usually set to 1.0.",1],[1,"FirstPerson","","Models a flying first person camera."],[11,"settings","","The first person camera settings.",2],[11,"yaw","","The yaw angle (in radians).",2],[11,"pitch","","The pitch angle (in radians).",2],[11,"direction","","The direction we are heading.",2],[11,"position","","The position of the camera.",2],[11,"velocity","","The velocity we are moving in the direction.",2],[1,"FirstPersonSettings","","First person camera settings."],[11,"move_forward_key","","Which key to press to move forward.",3],[11,"move_backward_key","","Which key to press to move backward.",3],[11,"strafe_left_key","","Which key to press to strafe left.",3],[11,"strafe_right_key","","Which key to press to strafe right.",3],[11,"fly_up_key","","Which key to press to fly up.",3],[11,"fly_down_key","","Which key to press to fly down.",3],[11,"move_faster_key","","Which key to press to move faster.",3],[11,"speed_horizontal","","The horizontal movement speed.",3],[11,"speed_vertical","","The vertical movement speed.",3],[3,"model_view_projection","","Computes a model view projection matrix."]],"paths":[[1,"Camera"],[1,"CameraPerspective"],[1,"FirstPerson"],[1,"FirstPersonSettings"]]};

searchIndex['gfx_macros'] = {"items":[[0,"","gfx_macros","Macro extensions crate.\nImplements `shaders!` macro as well as `#[shader_param]` and\n`#[vertex_format]` attributes."],[3,"registrar","","Entry point for the plugin phase"],[0,"shader_param","",""],[3,"expand","gfx_macros::shader_param","Decorator for `shader_param` attribute"],[0,"vertex_format","gfx_macros",""],[3,"expand","gfx_macros::vertex_format","Derive a `gfx::VertexFormat` implementation for the `struct`"],[15,"shaders!","gfx_macros",""]],"paths":[]};

searchIndex['graphics'] = {"items":[[0,"","graphics","A library for 2D graphics that works with multiple back-ends."],[1,"Context","","Drawing 2d context."],[11,"view","","View transformation.",0],[11,"transform","","Current transformation.",0],[0,"internal","","Contains internal type aliases and traits."],[4,"Area","graphics::internal","The type used for area."],[4,"Color","","[red, green, blue, alpha]"],[4,"ColorComponent","","The type used for color component."],[4,"Line","","[x1, y1, x2, y2]"],[4,"SourceRectangle","","[x, y, w, h]"],[4,"Polygon","","[x0, y0, x1, y1, ...]"],[4,"Polygons","","A slice of polygons."],[4,"Radius","","The type used for radius."],[4,"Ray","","[x, y, dir_x, dir_y]"],[4,"Rectangle","","[x, y, w, h]"],[4,"Triangle","","[x1, y1, x2, y2, x3, y3]"],[4,"Vec2d","","[x, y]"],[4,"Width","","The type used for width."],[6,"CanColor","","Implemented by contexts that can color."],[9,"color","","Create a new context with color.",1],[6,"CanRectangle","","Implemented by contexts that can set rectangle information."],[9,"rectangle","","Create new context with rectangle information.",2],[6,"CanSourceRectangle","","Implemented by contexts that can set source rectangle information."],[9,"source_rectangle","","Create new context with source rectangle information.",3],[6,"CanTransform","","Implemented by contexts that can transform."],[9,"transform","","Create a new context with transformation.",4],[6,"CanViewTransform","","Implemented by contexts that can view transform."],[9,"view_transform","","Create a new context with view transformation.",5],[6,"HasColor","","Implemented by contexts that uses type `U` as current color."],[9,"get_color","","Returns the current color.",6],[6,"HasRectangle","","Implemented by contexts that uses type `U` as current rectangle."],[9,"get_rectangle","","Returns the current rectangle.",7],[6,"HasSourceRectangle","","Implemented by contexts that uses type `U` as current source rectangle."],[9,"get_source_rectangle","","Returns the current source rectangle.",8],[6,"HasTransform","","Implemented by contexts that uses type `U` as current transform."],[9,"get_transform","","Returns the current transform.",9],[6,"HasViewTransform","","Implemented by contexts that uses type `U` as current view transform."],[9,"get_view_transform","","Returns the current view transform.",10],[0,"interpolation","graphics","Interpolation algorithms."],[3,"lerp","graphics::interpolation","Performs linear interpolation.\nA linear interpolation consists of two states 'a' and 'b'.\nThe 't' variable is a factor between 0 and 1 that \ngives weight to 'a' or 'b'.\nWhen 't' is zero then 'a' has full weight.\nWhen 't' is one then 'b' has full weight."],[3,"lerp_2","","Performs linear interpolation on array of size 3."],[3,"lerp_3","","Performs linear interpolation on array of size 3."],[3,"lerp_4","","Performs linear interpolation on array of size 4."],[3,"lerp_5","","Performs linear interpolation on array of size 5."],[3,"quad_bez","","Performs quadratic beziér interpolation.\nThis is done by nesting linear interpolations.\nFor more information, see:"],[3,"cub_bez","","Performs cubic beziér interpolation.\nThis is done by interpolation between two quadratic beziér.\nFor more information, see:"],[0,"modular_index","graphics","Helper functions for computing modular index safely."],[3,"offset","graphics::modular_index","Computes modular offset safely for indices."],[3,"previous","","Computes previous modular index safely."],[3,"next","","Computes next modular index safely."],[0,"triangulation","graphics","Methods for converting shapes into triangles."],[3,"with_lerp_polygons_tri_list_xy_f32_rgba_f32","graphics::triangulation","Streams tweened polygons using linear interpolation."],[3,"with_ellipse_tri_list_xy_f32_rgba_f32","","Streams an ellipse specified by a resolution."],[3,"with_round_border_line_tri_list_xy_f32_rgba_f32","","Streams a round border line."],[3,"with_round_rectangle_tri_list_xy_f32_rgba_f32","","Streams a round rectangle."],[3,"stream_polygon_tri_list_xy_f32_rgba_f32","","Streams a polygon into tri list with color per vertex.\nUses buffers that fit inside L1 cache."],[3,"with_ellipse_border_tri_list_xy_f32_rgba_f32","","Streams an ellipse border specified by a resolution."],[3,"with_round_rectangle_border_tri_list_xy_f32_rgba_f32","","Streams a round rectangle border."],[3,"stream_quad_tri_list_xy_f32_rgba_f32","","Streams a quad into tri list with color per vertex."],[3,"with_polygon_tri_list_xy_f32_rgba_f32","","Splits polygon into convex segments with one color per vertex.\nCreate a buffer that fits into L1 cache with 1KB overhead."],[3,"rect_tri_list_xy_f32","","Creates triangle list vertices from rectangle."],[3,"rect_border_tri_list_xy_f32","","Creates triangle list vertices from rectangle."],[3,"rect_tri_list_rgba_f32","","Creates triangle list colors from rectangle."],[3,"rect_border_tri_list_rgba_f32","","Creates triangle list colors from rectangle border."],[3,"rect_tri_list_uv_f32","","Creates triangle list texture coords from image."],[0,"vecmath","graphics","Various methods for computing with vectors."],[3,"translate","graphics::vecmath","Creates a translation matrix."],[3,"rotate_radians","","Creates a rotation matrix."],[3,"orient","","Orients x axis to look at point."],[3,"scale","","Create a scale matrix."],[3,"shear","","Create a shear matrix."],[3,"identity","","Create an identity matrix."],[3,"get_scale","","Extract scale information from matrix."],[3,"separation","","Compute the shortest vector from point to ray.\nA ray stores starting point and directional vector."],[3,"least_separation_4","","Returns the least separation out of four.\nEach seperation can be computed using `separation` function.\nThe separation returned can be used\nto solve collision of rectangles."],[3,"margin_rectangle","","Shrinks a rectangle by a factor on all sides."],[3,"relative_rectangle","","Computes a relative rectangle using the rectangle as a tile."],[3,"relative_source_rectangle","","Computes a relative source rectangle using\nthe source rectangle as a tile."],[3,"modular_offset","","Computes modular offset safely for numbers."],[3,"area_centroid","","Computes the area and centroid of a simple polygon."],[3,"area","","Computes area of a simple polygon."],[3,"centroid","","Computes centroid of a simple polygon."],[3,"line_side","","Returns a number that tells which side it is relative to a line."],[3,"inside_triangle","","Returns true if point is inside triangle."],[3,"triangle_face","","Returns true if triangle is clockwise."],[3,"hsv","","Transform color with hue saturation and value."],[4,"Scalar","","The type used for scalars."],[4,"Matrix2d","","The type used for matrices."],[4,"Vec2d","","The type used for vectors."],[3,"multiply","","Multiplies two matrices."],[4,"BevelBorderLineContext","graphics",""],[4,"BevelBorderLineColorContext","",""],[4,"BevelRectangleContext","",""],[4,"BevelRectangleColorContext","",""],[4,"BevelRectangleBorderContext","",""],[4,"BevelRectangleBorderColorContext","",""],[4,"ColorContext","",""],[4,"EllipseContext","",""],[4,"EllipseBorderContext","",""],[4,"EllipseColorContext","",""],[4,"EllipseBorderColorContext","",""],[4,"LerpTweenContext","",""],[4,"LerpTweenColorContext","",""],[4,"LerpTweenPolygonsContext","",""],[4,"LerpTweenPolygonsColorContext","",""],[4,"LineContext","",""],[4,"LineColorContext","",""],[4,"ImageContext","",""],[4,"ImageColorContext","",""],[4,"ImageRectangleContext","",""],[4,"ImageRectangleColorContext","",""],[4,"PolygonContext","",""],[4,"PolygonColorContext","",""],[4,"RectangleContext","",""],[4,"RectangleBorderContext","",""],[4,"RectangleColorContext","",""],[4,"RectangleBorderColorContext","",""],[4,"RoundBorderLineContext","",""],[4,"RoundBorderLineColorContext","",""],[4,"RoundRectangleContext","",""],[4,"RoundRectangleColorContext","",""],[4,"RoundRectangleBorderContext","",""],[4,"RoundRectangleBorderColorContext","",""],[4,"SquareBorderLineContext","",""],[4,"SquareBorderLineColorContext","",""],[6,"AddBevel","","Implemented by contexts that can make a shape bevel."],[9,"bevel","","Bevels the shape of the current context.",11],[6,"AddBevelBorder","","Implemented by contexts that can add round border."],[9,"bevel_border_radius","","Adds a bevel border radius.",12],[10,"bevel_border_width","","Adds a bevel border width.",12],[6,"AddBorder","","Implemented by contexts that can add border."],[9,"border_radius","","Adds a border radius.",13],[10,"border_width","","Adds a border width.",13],[6,"AddColor","","Implemented by contexts who can add color."],[9,"rgba","","Add color with alpha channel.",14],[10,"rgb","","Adds color with alpha channel set to 1.0.",14],[10,"color","","Add color [r, g, b, a].",14],[10,"grey","","Adds a gray color.",14],[10,"alpha","","Adds a white semi-transparent color.",14],[6,"AddEllipse","","Implemented by all contexts that can add ellipse."],[9,"ellipse","","Adds an ellipse.",15],[10,"ellipse_centered","","Adds an ellipse with coordinates in the center.",15],[10,"circle","","Adds a circle.",15],[6,"AddImage","","Implemented by contexts that can add image."],[9,"image","","Add image to context.",16],[6,"AddLine","","Implemented by all contexts that can add rectangle."],[9,"line","","Adds a line.",17],[6,"AddPolygon","","Implemented by contexts who can add polygon."],[9,"polygon","","Add polygon.",18],[6,"AddPolygons","","Implemented by tweening contexts that can add polygons."],[9,"polygons","","Add polygons.",19],[6,"AddRectangle","","Implemented by all contexts that can add rectangle."],[9,"rect","","Adds a rectangle.",20],[10,"rect_centered","","Adds a rectangle with coordinates in the center.",20],[10,"square","","Adds a square with coordinates of upper left corner.",20],[10,"square_centered","","Adds a square with coordinates in the center.",20],[6,"AddRound","","Implemented by contexts that can make a shape rounder."],[9,"round","","Rounds the shape of the current context.",21],[6,"AddRoundBorder","","Implemented by contexts that can add round border."],[9,"round_border_radius","","Adds a round border radius.",22],[10,"round_border_width","","Adds a round border width.",22],[6,"AddSquareBorder","","Implemented by contexts that can add square border."],[9,"square_border_radius","","Adds a square border radius.",23],[10,"square_border_width","","Adds a square border width.",23],[6,"AddTween","","Implemented by contexts who can give an animated inbetweening context."],[9,"lerp","","Do linear interpolation.",24],[6,"BackEnd","","Implemented by all graphics back-ends.\nThis trait uses default methods to simplify implementation."],[10,"supports_clear_rgba","","Returns true if feature is supported.",25],[10,"clear_rgba","","Clears background with a color.",25],[10,"enable_alpha_blend","","Turns on alpha blending.",25],[10,"disable_alpha_blend","","Turns off alpha blending.",25],[10,"supports_single_texture","","Returns true if texture feature is supported.",25],[10,"enable_single_texture","","Sets the current single-texture.",25],[10,"disable_single_texture","","Disables single-texture.",25],[10,"has_texture_alpha","","Should return true if texture has alpha channel.",25],[10,"supports_tri_list_xy_f64_rgba_f32","","Returns true if feature is supported.",25],[10,"tri_list_xy_f64_rgba_f32","","Renders list of 2d triangles with color assigned per vertex.",25],[10,"supports_tri_list_xy_f32_rgba_f32","","Returns true if feature is supported.",25],[10,"tri_list_xy_f32_rgba_f32","","Renders list of 2d triangles with color assigned per vertex.",25],[10,"supports_tri_list_xy_f32_rgba_f32_uv_f32","","Returns true if feature is supported.",25],[10,"tri_list_xy_f32_rgba_f32_uv_f32","","Renders list of 2d triangles.",25],[6,"Draw","","Implemented by contexts that can draws something using a back-end."],[9,"draw","","Draw using back-end.",26],[6,"ImageSize","","Must be implemented by all images to be used with graphics back-end."],[9,"get_size","","Get the image size.",27],[6,"RelativeColor","","Implemented by contexts that contains color."],[9,"mul_rgba","","Multiplies with red, green, blue and alpha values.",28],[10,"tint","","Mixes the current color with white.",28],[10,"shade","","Mixes the current color with black.",28],[10,"hue_deg","","Rotates hue by degrees.",28],[9,"hue_rad","","Rotates hue by radians.",28],[6,"RelativeRectangle","","Should be implemented by contexts that have rectangle information."],[9,"margin","","Shrinks the current rectangle equally by all sides.",29],[10,"expand","","Expands the current rectangle equally by all sides.",29],[9,"rel","","Moves to a relative rectangle using the current rectangle as tile.",29],[6,"RelativeSourceRectangle","","Should be implemented by contexts that\nhave source rectangle information."],[9,"src_rect","","Adds a source rectangle.",30],[9,"src_rel","","Moves to a relative source rectangle using\nthe current source rectangle as tile.",30],[9,"src_flip_h","","Flips the source rectangle horizontally.",30],[9,"src_flip_v","","Flips the source rectangle vertically.",30],[9,"src_flip_hv","","Flips the source rectangle horizontally and vertically.",30],[6,"RelativeTransform2d","","Implemented by contexts that can transform."],[9,"trans","","Translate x an y in local coordinates.",31],[10,"rot_deg","","Rotates degrees in local coordinates.",31],[9,"rot_rad","","Rotate radians in local coordinates.",31],[9,"orient","","Orients x axis to look at point locally.",31],[9,"scale","","Scales in local coordinates.",31],[10,"zoom","","Scales in both directions in local coordinates.",31],[10,"flip_v","","Flips vertically in local coordinates.",31],[10,"flip_h","","Flips horizontally in local coordinates.",31],[10,"flip_hv","","Flips horizontally and vertically in local coordinates.",31],[9,"shear","","Shears in local coordinates.",31],[6,"View","","Should be implemented by contexts that\ndraws something relative to view."],[9,"view","","Moves the current transform to the view coordinate system.",32],[9,"reset","","Moves the current transform to the default coordinate system.",32],[9,"store_view","","Stores the current transform as new view.",32],[9,"get_view_size","","Computes the current view size.",32]],"paths":[[1,"Context"],[6,"CanColor"],[6,"CanRectangle"],[6,"CanSourceRectangle"],[6,"CanTransform"],[6,"CanViewTransform"],[6,"HasColor"],[6,"HasRectangle"],[6,"HasSourceRectangle"],[6,"HasTransform"],[6,"HasViewTransform"],[6,"AddBevel"],[6,"AddBevelBorder"],[6,"AddBorder"],[6,"AddColor"],[6,"AddEllipse"],[6,"AddImage"],[6,"AddLine"],[6,"AddPolygon"],[6,"AddPolygons"],[6,"AddRectangle"],[6,"AddRound"],[6,"AddRoundBorder"],[6,"AddSquareBorder"],[6,"AddTween"],[6,"BackEnd"],[6,"Draw"],[6,"ImageSize"],[6,"RelativeColor"],[6,"RelativeRectangle"],[6,"RelativeSourceRectangle"],[6,"RelativeTransform2d"],[6,"View"]]};

searchIndex['input'] = {"items":[[0,"","input","A flexible structure for user interactions\nto be used in window frameworks and widgets libraries."],[2,"InputEvent","","Models input events."],[12,"KeyPress","","Pressed a keyboard key.",0],[11,"key","input::InputEvent","Keyboard key.",0],[12,"KeyRelease","input","Released a keyboard key.",0],[11,"key","input::InputEvent","Keyboard key.",0],[12,"MousePress","input","Pressed a mouse button.",0],[11,"button","input::InputEvent","Mouse button.",0],[12,"MouseRelease","input","Released a mouse button.",0],[11,"button","input::InputEvent","Mouse button.",0],[12,"MouseMove","input","Moved mouse cursor.",0],[11,"x","input::InputEvent","x in window coordinates.",0],[11,"y","","y in window coordinates.",0],[11,"draw_x","","x in drawing coordinates.",0],[11,"draw_y","","y in drawing coordinates.",0],[12,"MouseRelativeMove","input","Moved mouse relative, not bounded by cursor.",0],[11,"dx","input::InputEvent","Delta x in window coordinates.",0],[11,"dy","","Delta y in window coordinates.",0],[11,"draw_dx","","Delta x in drawing coordinates.",0],[11,"draw_dy","","Delta y in drawing coordinates.",0],[12,"MouseScroll","input","Scrolled mouse.",0],[11,"dx","input::InputEvent","Delta x in undefined coordinates.",0],[11,"dy","","Delta y in undefined coordinates.",0],[0,"keyboard","input","Back-end agnostic keyboard keys."],[2,"Key","input::keyboard","Represent a keyboard key."],[12,"Unknown","","",1],[12,"Backspace","","",1],[12,"Tab","","",1],[12,"Return","","",1],[12,"Escape","","",1],[12,"Space","","",1],[12,"Exclaim","","",1],[12,"Quotedbl","","",1],[12,"Hash","","",1],[12,"Dollar","","",1],[12,"Percent","","",1],[12,"Ampersand","","",1],[12,"Quote","","",1],[12,"LeftParen","","",1],[12,"RightParen","","",1],[12,"Asterisk","","",1],[12,"Plus","","",1],[12,"Comma","","",1],[12,"Minus","","",1],[12,"Period","","",1],[12,"Slash","","",1],[12,"D0","","",1],[12,"D1","","",1],[12,"D2","","",1],[12,"D3","","",1],[12,"D4","","",1],[12,"D5","","",1],[12,"D6","","",1],[12,"D7","","",1],[12,"D8","","",1],[12,"D9","","",1],[12,"Colon","","",1],[12,"Semicolon","","",1],[12,"Less","","",1],[12,"Equals","","",1],[12,"Greater","","",1],[12,"Question","","",1],[12,"At","","",1],[12,"LeftBracket","","",1],[12,"Backslash","","",1],[12,"RightBracket","","",1],[12,"Caret","","",1],[12,"Underscore","","",1],[12,"Backquote","","",1],[12,"A","","",1],[12,"B","","",1],[12,"C","","",1],[12,"D","","",1],[12,"E","","",1],[12,"F","","",1],[12,"G","","",1],[12,"H","","",1],[12,"I","","",1],[12,"J","","",1],[12,"K","","",1],[12,"L","","",1],[12,"M","","",1],[12,"N","","",1],[12,"O","","",1],[12,"P","","",1],[12,"Q","","",1],[12,"R","","",1],[12,"S","","",1],[12,"T","","",1],[12,"U","","",1],[12,"V","","",1],[12,"W","","",1],[12,"X","","",1],[12,"Y","","",1],[12,"Z","","",1],[12,"Delete","","",1],[12,"CapsLock","","",1],[12,"F1","","",1],[12,"F2","","",1],[12,"F3","","",1],[12,"F4","","",1],[12,"F5","","",1],[12,"F6","","",1],[12,"F7","","",1],[12,"F8","","",1],[12,"F9","","",1],[12,"F10","","",1],[12,"F11","","",1],[12,"F12","","",1],[12,"PrintScreen","","",1],[12,"ScrollLock","","",1],[12,"Pause","","",1],[12,"Insert","","",1],[12,"Home","","",1],[12,"PageUp","","",1],[12,"End","","",1],[12,"PageDown","","",1],[12,"Right","","",1],[12,"Left","","",1],[12,"Down","","",1],[12,"Up","","",1],[12,"NumLockClear","","",1],[12,"NumPadDivide","","",1],[12,"NumPadMultiply","","",1],[12,"NumPadMinus","","",1],[12,"NumPadPlus","","",1],[12,"NumPadEnter","","",1],[12,"NumPad1","","",1],[12,"NumPad2","","",1],[12,"NumPad3","","",1],[12,"NumPad4","","",1],[12,"NumPad5","","",1],[12,"NumPad6","","",1],[12,"NumPad7","","",1],[12,"NumPad8","","",1],[12,"NumPad9","","",1],[12,"NumPad0","","",1],[12,"NumPadPeriod","","",1],[12,"Application","","",1],[12,"Power","","",1],[12,"NumPadEquals","","",1],[12,"F13","","",1],[12,"F14","","",1],[12,"F15","","",1],[12,"F16","","",1],[12,"F17","","",1],[12,"F18","","",1],[12,"F19","","",1],[12,"F20","","",1],[12,"F21","","",1],[12,"F22","","",1],[12,"F23","","",1],[12,"F24","","",1],[12,"Execute","","",1],[12,"Help","","",1],[12,"Menu","","",1],[12,"Select","","",1],[12,"Stop","","",1],[12,"Again","","",1],[12,"Undo","","",1],[12,"Cut","","",1],[12,"Copy","","",1],[12,"Paste","","",1],[12,"Find","","",1],[12,"Mute","","",1],[12,"VolumeUp","","",1],[12,"VolumeDown","","",1],[12,"NumPadComma","","",1],[12,"NumPadEqualsAS400","","",1],[12,"AltErase","","",1],[12,"Sysreq","","",1],[12,"Cancel","","",1],[12,"Clear","","",1],[12,"Prior","","",1],[12,"Return2","","",1],[12,"Separator","","",1],[12,"Out","","",1],[12,"Oper","","",1],[12,"ClearAgain","","",1],[12,"CrSel","","",1],[12,"ExSel","","",1],[12,"NumPad00","","",1],[12,"NumPad000","","",1],[12,"ThousandsSeparator","","",1],[12,"DecimalSeparator","","",1],[12,"CurrencyUnit","","",1],[12,"CurrencySubUnit","","",1],[12,"NumPadLeftParen","","",1],[12,"NumPadRightParen","","",1],[12,"NumPadLeftBrace","","",1],[12,"NumPadRightBrace","","",1],[12,"NumPadTab","","",1],[12,"NumPadBackspace","","",1],[12,"NumPadA","","",1],[12,"NumPadB","","",1],[12,"NumPadC","","",1],[12,"NumPadD","","",1],[12,"NumPadE","","",1],[12,"NumPadF","","",1],[12,"NumPadXor","","",1],[12,"NumPadPower","","",1],[12,"NumPadPercent","","",1],[12,"NumPadLess","","",1],[12,"NumPadGreater","","",1],[12,"NumPadAmpersand","","",1],[12,"NumPadDblAmpersand","","",1],[12,"NumPadVerticalBar","","",1],[12,"NumPadDblVerticalBar","","",1],[12,"NumPadColon","","",1],[12,"NumPadHash","","",1],[12,"NumPadSpace","","",1],[12,"NumPadAt","","",1],[12,"NumPadExclam","","",1],[12,"NumPadMemStore","","",1],[12,"NumPadMemRecall","","",1],[12,"NumPadMemClear","","",1],[12,"NumPadMemAdd","","",1],[12,"NumPadMemSubtract","","",1],[12,"NumPadMemMultiply","","",1],[12,"NumPadMemDivide","","",1],[12,"NumPadPlusMinus","","",1],[12,"NumPadClear","","",1],[12,"NumPadClearEntry","","",1],[12,"NumPadBinary","","",1],[12,"NumPadOctal","","",1],[12,"NumPadDecimal","","",1],[12,"NumPadHexadecimal","","",1],[12,"LCtrl","","",1],[12,"LShift","","",1],[12,"LAlt","","",1],[12,"LGui","","",1],[12,"RCtrl","","",1],[12,"RShift","","",1],[12,"RAlt","","",1],[12,"RGui","","",1],[12,"Mode","","",1],[12,"AudioNext","","",1],[12,"AudioPrev","","",1],[12,"AudioStop","","",1],[12,"AudioPlay","","",1],[12,"AudioMute","","",1],[12,"MediaSelect","","",1],[12,"Www","","",1],[12,"Mail","","",1],[12,"Calculator","","",1],[12,"Computer","","",1],[12,"AcSearch","","",1],[12,"AcHome","","",1],[12,"AcBack","","",1],[12,"AcForward","","",1],[12,"AcStop","","",1],[12,"AcRefresh","","",1],[12,"AcBookmarks","","",1],[12,"BrightnessDown","","",1],[12,"BrightnessUp","","",1],[12,"DisplaySwitch","","",1],[12,"KbdIllumToggle","","",1],[12,"KbdIllumDown","","",1],[12,"KbdIllumUp","","",1],[12,"Eject","","",1],[12,"Sleep","","",1],[10,"fmt","","",1],[10,"clone","","",1],[10,"eq","","",1],[10,"partial_cmp","","",1],[10,"cmp","","",1],[10,"code","","Returns an id of the key",1],[10,"hash","","",1],[10,"to_i64","","",1],[10,"to_u64","","",1],[10,"to_int","","",1],[10,"from_u64","","",1],[10,"from_i64","","",1],[10,"from_int","","",1],[0,"mouse","input","Back-end agnostic mouse buttons."],[2,"Button","input::mouse","Represent a mouse button."],[12,"Unknown","","Unknown mouse button.",2],[12,"Left","","Left mouse button.",2],[12,"Right","","Right mouse button.",2],[12,"Middle","","Middle mouse button.",2],[12,"X1","","Extra mouse button number 1.",2],[12,"X2","","Extra mouse button number 2.",2],[12,"Button6","","Mouse button number 6.",2],[12,"Button7","","Mouse button number 7.",2],[12,"Button8","","Mouse button number 8.",2],[10,"fmt","","",2],[10,"hash","","",2],[10,"partial_cmp","","",2],[10,"lt","","",2],[10,"le","","",2],[10,"gt","","",2],[10,"ge","","",2],[10,"cmp","","",2],[10,"eq","","",2],[10,"ne","","",2],[10,"clone","","",2],[10,"clone","input","",0]],"paths":[[2,"InputEvent"],[2,"Key"],[2,"Button"]]};

searchIndex['xml'] = {"items":[[0,"","xml","This crate currently provides almost XML 1.0/1.1-compliant pull parser."],[0,"macros","","Contains several macros used in this crate."],[0,"common","","Contains several types used throughout the library."],[1,"Error","xml::common","XML parsing error."],[1,"Name","","XML qualified name."],[11,"prefix","","An XML namespace prefix.",0],[11,"namespace","","An XML namespace identifier.",0],[11,"local_name","","Local (namespace-less) name.",0],[1,"Attribute","","XML element attribute."],[11,"name","","Qualified name of the attribute.",1],[11,"value","","Attribute value.",1],[2,"XmlVersion","","XML version enumeration."],[12,"Version10","","XML version 1.0.",2],[12,"Version11","","XML version 1.1.",2],[3,"is_whitespace_char","","Checks whether the given character is a white space character (`S`)\nas is defined by XML 1.1 specification, [section 2.3][1]."],[3,"is_name_start_char","","Checks whether the given character is a name start character (`NameStartChar`)\nas is defined by XML 1.1 specification, [section 2.3][1]."],[3,"is_name_char","","Checks whether the given character is a name character (`NameChar`)\nas is defined by XML 1.1 specification, [section 2.3][1]."],[3,"parse_name","","Parses given string slice into an XML qualified name."],[3,"escape_str","","Performs escaping of common XML characters."],[6,"HasPosition","","Represents a thing which has a position inside some textual document."],[9,"row","","Returns a line number inside the document.",3],[9,"col","","Returns a column number inside the document.",3],[6,"OptionOps","","Contains additional operations on optional values."],[9,"execute","","Executes given action on an optional value, if it is present. Otherwise\nit is a no-op.",4],[10,"eq","","",5],[10,"ne","","",5],[10,"clone","","",5],[10,"fmt","","",5],[10,"row","","",5],[10,"col","","",5],[10,"new","","Creates a new error using position information from the provided\n`HasPosition` object and a message.",5],[10,"new_full","","Creates a new error using provided position information and a message.",5],[10,"msg","","Returns a reference to a message which is contained inside this error.",5],[10,"eq","","",0],[10,"ne","","",0],[10,"clone","","",0],[10,"fmt","","",0],[10,"new_local","","Returns a `Name` instance representing plain local name.",0],[10,"new","","Returns a `Name` instance representing qualified name with the\ngiven prefix and namespace URI.",0],[10,"prefix_ref","","Returns a slice with namespace prefix of this name, if it is present.",0],[10,"namespace_ref","","Returns a slice with namespace URI of this name, if it is present.",0],[10,"to_str_proper","","Returns correct XML representation of this local name and prefix.",0],[10,"eq","","",1],[10,"ne","","",1],[10,"clone","","",1],[10,"fmt","","",1],[10,"new","","Returns an `Attribute` instance with the given qualified name and value.",1],[10,"new_local","","Returns an `Attribute` instance with plain local name and the given value.",1],[10,"eq","","",2],[10,"ne","","",2],[10,"clone","","",2],[10,"fmt","","",2],[10,"execute","core::option","",6],[0,"namespace","xml",""],[1,"Namespace","xml::namespace","Namespace is a map from prefixes to namespace URIs."],[1,"NamespaceMappings","","An iterator over mappings from prefixes to URIs in a namespace."],[1,"NamespaceStack","","Namespace stack is a sequence of namespaces."],[1,"NamespaceStackMappings","","An iterator over mappings from prefixes to URIs in a namespace stack."],[5,"NS_XMLNS_PREFIX","",""],[5,"NS_XMLNS_URI","",""],[5,"NS_XML_PREFIX","",""],[5,"NS_XML_URI","",""],[5,"NS_EMPTY_URI","",""],[6,"NamespaceIterable","","Denotes something which contains namespace URI mappings."],[9,"uri_mappings","","",7],[10,"clone","","",8],[10,"eq","","",8],[10,"ne","","",8],[10,"empty","","Returns an empty namespace.",8],[10,"is_empty","","Checks whether this namespace is empty.",8],[10,"is_essentially_empty","","Checks whether this namespace is essentially empty, that is, it does not contain\nanything but default mappings.",8],[10,"put","","Puts a mapping into this namespace.",8],[10,"get","","Queries the namespace for the given prefix.",8],[10,"next","","",9],[10,"uri_mappings","","",8],[10,"eq","","",10],[10,"ne","","",10],[10,"clone","","",10],[10,"empty","","Returns an empty namespace stack.",10],[10,"default","","Returns a namespace stack with default items in it.",10],[10,"push_empty","","Adds an empty namespace to the top of this stack.",10],[10,"pop","","Removes a namespace at the top of the stack.",10],[10,"peek","","Returns a namespace at the top of the stack, leaving the stack intact.",10],[10,"put","","Puts a mapping into the topmost namespace in this stack.",10],[10,"get","","Performs a search for the given prefix in the whole stack.",10],[10,"squash","","Combines this stack of namespaces into a single namespace.",10],[10,"next","","",11],[10,"uri_mappings","","",10],[0,"reader","xml","Contains high-level interface for a pull-based XML parser."],[1,"EventReader","xml::reader","Simple wrapper around an `std::io::Buffer` which provides pull-based XML parsing."],[1,"Events","","XML events iterator, created by `events()` method on `Parser`."],[0,"config","","Contains parser configuration object."],[1,"ParserConfig","xml::reader::config","Parser configuration structure."],[11,"trim_whitespace","","Whether or not should whitespace be removed. Default is false.",12],[11,"whitespace_to_characters","","Whether or not should whitespace be converted to characters.\nDefault is false.",12],[11,"cdata_to_characters","","Whether or not should CDATA be converted to characters.\nDefault is false.",12],[11,"ignore_comments","","Whether or not should comments be omitted. Default is true.",12],[11,"coalesce_characters","","Whether or not should sequential `Characters` events be merged.\nDefault is true.",12],[10,"new","","Returns a new config with default values.",12],[10,"trim_whitespace","","Sets the field to the provided value and returns updated config object.",12],[10,"whitespace_to_characters","","Sets the field to the provided value and returns updated config object.",12],[10,"cdata_to_characters","","Sets the field to the provided value and returns updated config object.",12],[10,"ignore_comments","","Sets the field to the provided value and returns updated config object.",12],[10,"coalesce_characters","","Sets the field to the provided value and returns updated config object.",12],[0,"events","xml::reader","Contains `XmlEvent` datatype, instances of which are emitted by the parser."],[2,"XmlEvent","xml::reader::events","An element of an XML input stream."],[12,"StartDocument","","Corresponds to XML document declaration.",13],[11,"version","xml::reader::events::XmlEvent","XML version.",13],[11,"encoding","","XML document encoding.",13],[11,"standalone","","XML standalone declaration.",13],[12,"EndDocument","xml::reader::events","Denotes to the end of the document stream.",13],[12,"ProcessingInstruction","","Denotes an XML processing instruction.",13],[11,"name","xml::reader::events::XmlEvent","Processing instruction target.",13],[11,"data","","Processing instruction content.",13],[12,"StartElement","xml::reader::events","Denotes a beginning of an XML element.",13],[11,"name","xml::reader::events::XmlEvent","Qualified name of the element.",13],[11,"attributes","","A list of attributes associated with the element.\n \nCurrently attributes are not checked for duplicates (TODO)",13],[11,"namespace","","Contents of the namespace mapping at this point of the document.",13],[12,"EndElement","xml::reader::events","Denotes an end of an XML document.",13],[11,"name","xml::reader::events::XmlEvent","Qualified name of the element.",13],[12,"CData","xml::reader::events","Denotes CDATA content.",13],[12,"Comment","","Denotes a comment.",13],[12,"Characters","","Denotes character data outside of tags.",13],[12,"Whitespace","","Denotes a chunk of whitespace outside of tags.",13],[12,"Error","","Denotes parsing error.",13],[10,"clone","","",13],[10,"eq","","",13],[10,"ne","","",13],[10,"fmt","","",13],[10,"as_writer_event","","",13],[10,"new","xml::reader","Creates a new parser, consuming given `Buffer`.",14],[10,"new_with_config","","Creates a new parser with the provded configuration, consuming given `Buffer`.",14],[10,"next","","Pulls and returns next XML event from the stream.",14],[10,"events","","Returns an iterator over XML events.",14],[10,"next","","",15],[10,"new_from_string","","Convenience method to create a reader from an owned string.",14],[10,"new_from_bytes","","Convenience method to create a reader from an owned vector of bytes.",14],[10,"new_from_str_slice","","Convenience method to create a reader from a string slice.",14],[10,"new_from_bytes_slice","","Convenience method to create a reader from a slice of bytes.",14],[0,"writer","xml",""],[1,"EventWriter","xml::writer",""],[0,"config","",""],[1,"EmitterConfig","xml::writer::config",""],[11,"line_separator","","",16],[11,"indent_string","","",16],[11,"perform_indent","","",16],[11,"write_document_declaration","","",16],[11,"normalize_empty_elements","","",16],[11,"cdata_to_characters","","",16],[10,"new","","",16],[10,"line_separator","","Sets the field to the provided value and returns updated config object.",16],[10,"indent_string","","Sets the field to the provided value and returns updated config object.",16],[10,"perform_indent","","Sets the field to the provided value and returns updated config object.",16],[10,"write_document_declaration","","Sets the field to the provided value and returns updated config object.",16],[10,"normalize_empty_elements","","Sets the field to the provided value and returns updated config object.",16],[10,"cdata_to_characters","","Sets the field to the provided value and returns updated config object.",16],[0,"events","xml::writer",""],[2,"XmlEvent","xml::writer::events","An element of an XML output stream."],[12,"StartDocument","","Corresponds to XML document declaration.",17],[11,"version","xml::writer::events::XmlEvent","XML version.",17],[11,"encoding","","XML document encoding.",17],[11,"standalone","","XML standalone declaration.",17],[12,"ProcessingInstruction","xml::writer::events","Denotes an XML processing instruction.",17],[11,"name","xml::writer::events::XmlEvent","Processing instruction target.",17],[11,"data","","Processing instruction content.",17],[12,"StartElement","xml::writer::events","Denotes a beginning of an XML element.",17],[11,"name","xml::writer::events::XmlEvent","Qualified name of the element.",17],[11,"attributes","","A list of attributes associated with the element.\n \nCurrently attributes are not checked for duplicates (TODO).",17],[11,"namespace","","Contents of the namespace mapping at this point of the document.",17],[12,"EndElement","xml::writer::events","Denotes an end of an XML document.",17],[11,"name","xml::writer::events::XmlEvent","Qualified name of the element.",17],[12,"CData","xml::writer::events","Denotes CDATA content.",17],[12,"Comment","","Denotes a comment.",17],[12,"Characters","","Denotes character data outside of tags.",17],[4,"EventWriterResult","xml::writer",""],[10,"new","","",18],[10,"new_with_config","","",18],[10,"write","","",18],[10,"new_into_mem","","",18],[10,"new_into_mem_config","","",18]],"paths":[[1,"Name"],[1,"Attribute"],[2,"XmlVersion"],[6,"HasPosition"],[6,"OptionOps"],[1,"Error"],[2,"Option"],[6,"NamespaceIterable"],[1,"Namespace"],[1,"NamespaceMappings"],[1,"NamespaceStack"],[1,"NamespaceStackMappings"],[1,"ParserConfig"],[2,"XmlEvent"],[1,"EventReader"],[1,"Events"],[1,"EmitterConfig"],[2,"XmlEvent"],[1,"EventWriter"]]};

searchIndex['vecmath'] = {"items":[[0,"","vecmath","A simple and generic library for vector math."],[3,"col_mat3x2_mul_col","","Computes column vector in column matrix product."],[3,"col_mat3_mul_col","","Computes column vector in column matrix product."],[3,"col_mat4x3_mul_col","","Computes column vector in column matrix product."],[3,"col_mat4_mul_col","","Computes column vector in column matrix product."],[3,"row_mat2x3_mul_row","","Computes row vector in row matrix product."],[3,"row_mat3_mul_row","","Computes row vector in row matrix product."],[3,"row_mat3x4_mul_row","","Computes row vector in row matrix product."],[3,"row_mat4_mul_row","","Computes row vector in row matrix product."],[3,"col_mat3x2_mul","","Multiplies two matrices."],[3,"col_mat3_mul","","Multiplies two matrices."],[3,"col_mat4x3_mul","","Multiplies two matrices."],[3,"col_mat4_mul","","Multiplies two matrices."],[3,"row_mat2x3_mul","","Multiplies two matrices."],[3,"row_mat3_mul","","Multiplies two matrices."],[3,"row_mat3x4_mul","","Multiplies two matrices."],[3,"row_mat4_mul","","Multiplies two matrices."],[3,"mat2x3_id","","Constructs identity matrix."],[3,"mat3x2_id","","Constructs identity matrix."],[3,"mat3_id","","Constructs identity matrix."],[3,"mat3x4_id","","Constructs identity matrix."],[3,"mat4x3_id","","Constructs identity matrix."],[3,"mat4_id","","Constructs identity matrix."],[3,"vec2_to_f32","","Converts to a f32 vector."],[3,"vec3_to_f32","","Converts to a f32 vector."],[3,"vec4_to_f32","","Converts to a f32 vector."],[3,"mat2x3_to_f32","","Converts to a f32 matrix."],[3,"mat3x2_to_f32","","Converts to a f32 matrix."],[3,"mat3_to_f32","","Converts to a f32 matrix."],[3,"mat3x4_to_f32","","Converts to a f32 matrix."],[3,"mat4x3_to_f32","","Converts to a f32 matrix."],[3,"mat4_to_f32","","Converts to a f32 matrix."],[3,"vec2_to_f64","","Converts to a f64 vector."],[3,"vec3_to_f64","","Converts to a f64 vector."],[3,"vec4_to_f64","","Converts to a f64 vector."],[3,"mat2x3_to_f64","","Converts to a f64 matrix."],[3,"mat3x2_to_f64","","Converts to a f64 matrix."],[3,"mat3_to_f64","","Converts to a f64 matrix."],[3,"mat3x4_to_f64","","Converts to a f64 matrix."],[3,"mat4x3_to_f64","","Converts to a f64 matrix."],[3,"mat4_to_f64","","Converts to a f64 matrix."],[3,"vec2_from_f32","","Converts from a f32 vector."],[3,"vec3_from_f32","","Converts from a f32 vector."],[3,"vec4_from_f32","","Converts to a f32 vector."],[3,"mat2x3_from_f32","","Converts to a f32 matrix."],[3,"mat3x2_from_f32","","Converts to a f32 matrix."],[3,"mat3_from_f32","","Converts to a f32 matrix."],[3,"mat3x4_from_f32","","Converts to a f32 matrix."],[3,"mat4x3_from_f32","","Converts to a f32 column matrix."],[3,"mat4_from_f32","","Converts to a f32 matrix."],[3,"vec2_from_f64","","Converts to a f64 vector."],[3,"vec3_from_f64","","Converts to a f64 vector."],[3,"vec4_from_f64","","Converts to a f64 vector."],[3,"mat2x3_from_f64","","Converts to a f64 matrix."],[3,"mat3x2_from_f64","","Converts to a f64 matrix."],[3,"mat3_from_f64","","Converts to a f64 matrix."],[3,"mat3x4_from_f64","","Converts to a f64 matrix."],[3,"mat4x3_from_f64","","Converts to a f64 matrix."],[3,"mat4_from_f64","","Converts to a f64 matrix."],[3,"vec2_sub","","Subtracts 'b' from 'a'."],[3,"vec3_sub","","Subtracts 'b' from 'a'."],[3,"vec4_sub","","Subtracts 'b' from 'a'."],[3,"mat2x3_sub","","Subtracts 'b' from 'a'."],[3,"mat3x2_sub","","Subtracts 'b' from 'a'."],[3,"mat3_sub","","Subtracts 'b' from 'a'."],[3,"mat3x4_sub","","Subtracts 'b' from 'a'."],[3,"mat4x3_sub","","Subtracts 'b' from 'a'."],[3,"mat4_sub","","Subtracts 'b' from 'a'."],[3,"vec2_add","","Adds two vectors."],[3,"vec3_add","","Adds two vectors."],[3,"vec4_add","","Adds two vectors."],[3,"mat2x3_add","","Adds two matrices."],[3,"mat3x2_add","","Adds two matrices."],[3,"mat3_add","","Adds two matrices."],[3,"mat3x4_add","","Adds two matrices."],[3,"mat4x3_add","","Adds two matrices."],[3,"mat4_add","","Adds two matrices."],[3,"vec2_dot","","Computes the dot product."],[3,"vec3_dot","","Computes the dot product."],[3,"vec4_dot","","Computes the dot product."],[3,"vec2_square_len","","Computes the square length of a vector."],[3,"vec3_square_len","","Computes the square length of a vector."],[3,"vec4_square_len","","Computes the square length of a vector."],[3,"vec2_cross","","Computes the cross product."],[3,"vec3_cross","","Computes the cross product."],[3,"vec2_scale","","Multiplies the vector with a scalar."],[3,"vec3_scale","","Multiplies the vector with a scalar."],[3,"vec4_scale","","Multiplies the vector with a scalar."],[3,"vec2_len","","Computes the length of vector."],[3,"vec3_len","","Computes the length of vector."],[3,"vec4_len","","Computes the length of vector."],[3,"vec2_inv_len","","Computes the inverse length of a vector."],[3,"vec3_inv_len","","Computes the inverse length of a vector."],[3,"vec4_inv_len","","Computes the inverse length of a vector."],[3,"vec2_normalized","","Computes the normalized."],[3,"vec3_normalized","","Computes the normalized."],[3,"vec4_normalized","","Computes the normalized."],[3,"vec2_normalized_sub","","Computes the normalized difference between two vectors."],[3,"vec3_normalized_sub","","Computes the normalized difference between two vectors."],[3,"vec4_normalized_sub","","Computes the normalized difference between two vectors."],[3,"vec3_dot_vec2","","Computes transformed vector component."],[3,"vec4_dot_vec3","","Computes transformed vector component."],[3,"vec3_dot_pos2","","Computes transformed position component."],[3,"vec4_dot_pos3","","Computes transformed position component."],[3,"row_mat2x3_col","","Returns a column vector of a row matrix."],[3,"col_mat2x3_row","","Returns a row vector of a column matrix."],[3,"row_mat3x2_col","","Returns a column vector of a row matrix."],[3,"col_mat3x2_row","","Returns a row vector of a column matrix."],[3,"row_mat3_col","","Returns a column vector of a row matrix."],[3,"col_mat3_row","","Returns a row vector of a column matrix."],[3,"row_mat3x4_col","","Returns a column vector of a row matrix."],[3,"col_mat3x4_row","","Returns a row vector of a column matrix."],[3,"row_mat4x3_col","","Returns a column vector of a row matrix."],[3,"col_mat4x3_row","","Returns a column vector of a row matrix."],[3,"row_mat4_col","","Returns a column vector of a row matrix."],[3,"col_mat4_row","","Returns a row vector of a column matrix."],[3,"mat2x3_transposed","","Constructs the transpose of a matrix."],[3,"mat3x2_transposed","","Constructs the transpose of a matrix."],[3,"mat3_transposed","","Constructs the transpose of a matrix."],[3,"mat3x4_transposed","","Constructs the transpose of a matrix."],[3,"mat4x3_transposed","","Constructs the transpose of a matrix."],[3,"mat4_transposed","","Constructs the transpose of a matrix."],[3,"col_mat3_transform","","Transforms a 3D vector through a matrix."],[3,"col_mat4_transform","","Transforms a 4D vector through a matrix."],[3,"row_mat3_transform","","Transforms a 3D vector through a matrix."],[3,"row_mat4_transform","","Transforms a 4D vector through a matrix."],[3,"row_mat2x3_transform_pos2","","Transforms a 2D position through matrix."],[3,"col_mat3x2_transform_pos2","","Transforms a 2D position through matrix."],[3,"row_mat3_transform_pos2","","Transforms a 2D position through row matrix."],[3,"col_mat3_transform_pos2","","Transforms a 2D position through column matrix."],[3,"row_mat3x4_transform_pos3","","Transforms a 3D position through matrix."],[3,"col_mat4x3_transform_pos3","","Transforms a 3D position through matrix."],[3,"row_mat2x3_transform_vec2","","Transforms a 2D vector through matrix."],[3,"col_mat3x2_transform_vec2","","Transforms a 2D vector through matrix."],[3,"row_mat3_transform_vec2","","Transforms a 2D vector through row matrix."],[3,"col_mat3_transform_vec2","","Transforms a 2D vector through column matrix."],[3,"row_mat3x4_transform_vec3","","Transforms a 3D vector through matrix."],[3,"col_mat4x3_transform_vec3","","Transforms a 3D vector through matrix."],[3,"mat2x3_det","","Computes the determinant of a matrix."],[3,"mat3x2_det","","Computes the determinant of a matrix."],[3,"mat3_det","","Computes the determinant of a matrix."],[3,"mat3x4_det","","Computes the determinant of a matrix."],[3,"mat4x3_det","","Computes the determinant of a matrix."],[3,"mat4_det","","Computes the determinant of a 4x4 matrix."],[3,"mat2x3_inv_det","","Computes inverse determinant of a 2x3 matrix."],[3,"mat3x2_inv_det","","Computes inverse determinant of a 3x2 matrix."],[3,"mat3_inv_det","","Computes inverse determinant of a 3x3 matrix."],[3,"mat3x4_inv_det","","Computes inverse determinant of a 3x4 matrix."],[3,"mat4x3_inv_det","","Computes inverse determinant of a 4x3 matrix."],[3,"mat4_inv_det","","Computes the inverse determinant of a 4x4 matrix."],[3,"mat2x3_inv","","Computes the inverse of a 2x3 matrix."],[3,"mat3x2_inv","","Computes the inverse of a 3x2 matrix."],[3,"mat3_inv","","Computes the inverse of a 3x3 matrix."],[3,"mat3x4_inv","","Computes the inverse of a 3x4 matrix."],[3,"mat4x3_inv","","Computes the inverse of a 4x3 matrix."],[3,"mat4_inv","","Computes the inverse of a 4x4 matrix."],[4,"Vector2","","A 2D vector."],[4,"Vector3","","A 3D vector."],[4,"Vector4","","A 4D vector."],[4,"Matrix2x3","","A 2x3 matrix."],[4,"Matrix3x2","","A 3x2 matrix."],[4,"Matrix3","","A 3x3 matrix."],[4,"Matrix3x4","","A 3x4 matrix."],[4,"Matrix4x3","","A 4x3 matrix."],[4,"Matrix4","","A 4x4 matrix."]],"paths":[]};

searchIndex['khronos_api'] = {"items":[[0,"","khronos_api","This crates contains the sources of the official OpenGL repository."],[5,"GL_XML","","Content of the official `gl.xml` file."],[5,"EGL_XML","","Content of the official `egl.xml` file."],[5,"WGL_XML","","Content of the official `wgl.xml` file."],[5,"GLX_XML","","Content of the official `glx.xml` file."]],"paths":[]};

searchIndex['shader_version'] = {"items":[[0,"","shader_version","A helper library for detecting and picking compatible shaders."],[2,"VersionRange","","Models knowledge about version range."],[12,"VersionFromTo","","The version range is working from a version,\nup to but not included another version.",0],[12,"VersionFrom","","The version range is working from a version,\nand possibly for all newer versions unless\nthe context it is used implies otherwise.",0],[0,"opengl","","Models versions of OpenGL"],[2,"OpenGL","shader_version::opengl",""],[12,"OpenGL_2_0","","",1],[12,"OpenGL_2_1","","",1],[12,"OpenGL_3_0","","",1],[12,"OpenGL_3_1","","",1],[12,"OpenGL_3_2","","",1],[12,"OpenGL_3_3","","",1],[12,"OpenGL_4_0","","",1],[12,"OpenGL_4_1","","",1],[12,"OpenGL_4_2","","",1],[12,"OpenGL_4_3","","",1],[12,"OpenGL_4_4","","",1],[10,"get_major_minor","","Gets the minor version of OpenGL.",1],[10,"to_GLSL","","Gets GLSL version associated with OpenGL.",1],[0,"glsl","shader_version","Models versions of OpenGL Shader Language (GLSL)"],[2,"GLSL","shader_version::glsl","For OpenGL version 3.3 and above,\nthe GLSL version is the same as the OpenGL version."],[12,"GLSL_1_10","","",2],[12,"GLSL_1_20","","",2],[12,"GLSL_1_30","","",2],[12,"GLSL_1_40","","",2],[12,"GLSL_1_50","","",2],[12,"GLSL_3_30","","",2],[12,"GLSL_4_00","","",2],[12,"GLSL_4_10","","",2],[12,"GLSL_4_20","","",2],[12,"GLSL_4_30","","",2],[12,"GLSL_4_40","","",2],[10,"to_OpenGL","","Gets OpenGL version associated with GLSL.",2]],"paths":[[2,"VersionRange"],[2,"OpenGL"],[2,"GLSL"]]};

initSearch(searchIndex);
