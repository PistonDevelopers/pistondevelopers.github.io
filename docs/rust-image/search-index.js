var searchIndex = {};
searchIndex['image'] = {"items":[[0,"","image","This crate provides native rust implementations of\nImage encoders and decoders and basic image manipulation\nfunctions."],[1,"Luma","","A type to hold a grayscale pixel"],[1,"LumaA","","A type to hold a grayscale pixel with an alpha channel"],[1,"Rgb","","A type to hold an RGB pixel"],[1,"Rgba","","A type to hold an RGB pixel with an alpha channel"],[1,"SubImage","","A View into another image"],[1,"ImageBuf","","An Image whose pixels are contained within a vector"],[1,"Pixels","","Immutable pixel iterator"],[1,"MutPixels","","Mutable pixel iterator"],[2,"ColorType","","An enumeration over supported color types and their bit depths"],[12,"Grey","","Pixel is greyscale",0],[12,"RGB","","Pixel contains R, G and B channels",0],[12,"Palette","","Pixel is an index into a color palette",0],[12,"GreyA","","Pixel is greyscale with an alpha channel",0],[12,"RGBA","","Pixel is RGB with an alpha channel",0],[2,"ImageError","","An enumeration of Image Errors"],[12,"FormatError","","The Image is not formatted properly",1],[12,"DimensionError","","The Image's dimensions are either too small or too large",1],[12,"UnsupportedError","","The Decoder does not support this image format",1],[12,"UnsupportedColor","","The Decoder does not support this color type",1],[12,"NotEnoughData","","Not enough data was provided to the Decoder\nto decode the image",1],[12,"IoError","","An I/O Error occurred while decoding the image",1],[12,"ImageEnd","","The end of the image has been reached",1],[2,"ImageFormat","","An enumeration of supported image formats.\nNot all formats support both encoding and decoding."],[12,"PNG","","An Image in PNG Format",2],[12,"JPEG","","An Image in JPEG Format",2],[12,"GIF","","An Image in GIF Format",2],[12,"WEBP","","An Image in WEBP Format",2],[12,"PPM","","An Image in PPM Format",2],[2,"FilterType","","Available Sampling Filters"],[12,"Nearest","","Nearest Neighbor",3],[12,"Triangle","","Linear Filter",3],[12,"CatmullRom","","Cubic Filter",3],[12,"Gaussian","","Gaussian Filter",3],[12,"Lanczos3","","Lanczos with window 3",3],[2,"DynamicImage","","A Dynamic Image"],[12,"ImageLuma8","","Each pixel in this image is 8-bit Luma",4],[12,"ImageLumaA8","","Each pixel in this image is 8-bit Luma with alpha",4],[12,"ImageRgb8","","Each pixel in this image is 8-bit Rgb",4],[12,"ImageRgba8","","Each pixel in this image is 8-bit Rgb with alpha",4],[3,"open","","Open the image located at the path specified.\nThe image's format is determined from the path's file extension."],[3,"load","","Create a new image from a Reader"],[3,"load_from_memory","","Create a new image from a byte slice"],[0,"imageops","","Image Processing Functions"],[2,"FilterType","image::imageops","Available Sampling Filters"],[12,"Nearest","","Nearest Neighbor",3],[12,"Triangle","","Linear Filter",3],[12,"CatmullRom","","Cubic Filter",3],[12,"Gaussian","","Gaussian Filter",3],[12,"Lanczos3","","Lanczos with window 3",3],[3,"rotate90","","Rotate an image 90 degrees clockwise."],[3,"rotate180","","Rotate an image 180 degrees clockwise."],[3,"rotate270","","Rotate an image 270 degrees clockwise."],[3,"flip_horizontal","","Flip an image horizontally"],[3,"flip_vertical","","Flip an image vertically"],[3,"filter3x3","","Perform a 3x3 box filter on the supplied image.\n```kernel``` is an array of the filter weights of length 9."],[3,"resize","","Resize the supplied image to the specified dimensions\n```nwidth``` and ```nheight``` are the new dimensions.\n```filter``` is the sampling filter to use."],[3,"blur","","Performs a Gaussian blur on the supplied image.\n```sigma``` is a measure of how much to blur by."],[3,"unsharpen","","Performs an unsharpen mask on the supplied image\n```sigma``` is the amount to blur the image by.\n```threshold``` is the threshold for the difference between\nsee https://en.wikipedia.org/wiki/Unsharp_masking#Digital_unsharp_masking"],[3,"grayscale","","Convert the supplied image to grayscale"],[3,"invert","","Invert each pixel within the supplied image\nThis function operates in place."],[3,"contrast","","Adjust the contrast of the supplied image\n```contrast``` is the amount to adjust the contrast by.\nNegative values decrease the contrast and positive values increase the contrast."],[3,"brighten","","Brighten the supplied image\n```value``` is the amount to brighten each pixel by.\nNegative values decrease the brightness and positive values increase it."],[3,"crop","","Return a mutable view into an image"],[0,"webp","image","Decoding of Webp Images"],[1,"WebpDecoder","image::webp","A Representation of a Webp Image format decoder."],[0,"vp8","","An implementation of the VP8 Video Codec"],[1,"Frame","image::webp::vp8","A Representation of the last decoded video frame"],[11,"width","","The width of the luma plane",5],[11,"height","","The height of the luma plane",5],[11,"ybuf","","The luma plane of the frame",5],[11,"keyframe","","Indicates whether this frame is a keyframe",5],[11,"for_display","","Indicates whether this frame is intended for display",5],[11,"pixel_type","","The pixel type of the frame as defined by Section 9.2\nof the VP8 Specification",5],[1,"VP8Decoder","","VP8 Decoder\nOnly decodes keyframes"],[10,"clone","","",5],[10,"fmt","","",5],[10,"default","","",5],[10,"new","","Create a new decoder.\nThe reader must present a raw vp8 bitstream to the decoder",6],[10,"decode_frame","","Decodes the current frame and returns a reference to it",6],[0,"ppm","image","Encoding of portable pixmap Images"],[1,"PPMEncoder","image::ppm","A representation of a PPM encoder."],[0,"png","image","Decoding and Encoding of PNG Images"],[1,"PNGDecoder","image::png","The representation of a PNG decoder"],[1,"PNGEncoder","","The representation of a PNG encoder"],[0,"zlib","","An Implementation of RFC 1950"],[1,"ZlibDecoder","image::png::zlib","A Zlib compressed stream decoder."],[10,"new","","Create a new decoder that decodes from a Reader",7],[10,"inner","","Return a mutable reference to the wrapped Reader",7],[10,"read","","",7],[0,"deflate","image::png","An Implementation of RFC 1951"],[1,"Inflater","image::png::deflate","A DEFLATE compressed stream decoder."],[10,"new","","Create a new decoder that decodes from a Reader",8],[10,"eof","","Indicate whether the end of the stream has been reached.",8],[10,"inner","","Return a mutable reference to the wrapped Reader",8],[10,"read","","",8],[0,"hash","image::png","This module provides implementations of common hashing algorithms."],[1,"Adler32","image::png::hash","An Implementation of the Adler-32 checksum"],[1,"Crc32","","An Implementation of the Crc-32 checksum"],[10,"new","","Create a new hasher.",9],[10,"update","","Update the internal hasher with the bytes from ```buf```",9],[10,"checksum","","Return the computed hash.",9],[10,"reset","","Reset this hasher to its initial state.",9],[10,"new","","Create a new hasher.",10],[10,"update","","Update the internal hasher with the bytes from ```buf```",10],[10,"checksum","","Return the computed hash.",10],[10,"reset","","Reset this hasher to its initial state.",10],[0,"jpeg","image","Decoding and Encoding of JPEG Images"],[1,"JPEGDecoder","image::jpeg","The representation of a JPEG decoder"],[1,"JPEGEncoder","","The representation of a JPEG encoder"],[1,"Component","","A representation of a JPEG component"],[11,"id","","The Component's identifier",11],[11,"h","","Horizontal sampling factor",11],[11,"v","","Vertical sampling factor",11],[11,"tq","","The quantization table selector",11],[11,"dc_table","","Index to the Huffman DC Table",11],[11,"ac_table","","Index to the AC Huffman Table",11],[11,"dc_pred","","The dc prediction of the component",11],[0,"gif","image","Decoding of GIF Images"],[1,"GIFDecoder","image::gif","The Representation of a GIF decoder"],[0,"lzw","","This modules provides an implementation of the Lempel–Ziv–Welch Compression Algorithm"],[1,"LZWReader","image::gif::lzw","An implementation of an LZW Decompressor."],[10,"new","","Create a new decompressor from a Reader",12],[10,"read","","",12],[4,"ImageResult","image",""],[6,"Pixel","","A trait that all pixels implement."],[9,"from_channels","","Construct a pixel from the 4 channels a, b, c and d.\nIf the pixel does not contain 4 channels the extra are ignored.",13],[9,"to_rgb","","Convert this pixel to RGB",13],[9,"to_rgba","","Convert this pixel to RGB with an alpha channel",13],[9,"to_luma","","Convert this pixel to luma",13],[9,"to_luma_alpha","","Convert this pixel to luma with an alpha channel",13],[9,"invert","","Invert this pixel",13],[9,"map","","Apply the function ```f``` to each channel of this pixel.",13],[9,"map_with_alpha","","Apply the function f to each channel except the alpha channel.\nApply the function g to the alpha channel.",13],[9,"map2","","Apply the function ```f``` to each channel of this pixel and\n```other``` pairwise.",13],[9,"channels4","","Returns the channels of this pixel as a 4 tuple. If the pixel\nhas less than 4 channels the remainder is filled with the maximum value",13],[6,"ImageDecoder","","The trait that all decoders implement"],[9,"dimensions","","Return a tuple containing the width and height of the image",14],[9,"colortype","","Return the color type of the image e.g RGB(8) (8bit RGB)",14],[9,"row_len","","Returns the length in bytes of one decoded row of the image",14],[9,"read_scanline","","Read one row from the image into buf\nReturns the row index",14],[9,"read_image","","Decode the entire image and return it as a Vector",14],[10,"load_rect","","Decode a specific region of the image, represented by the rectangle\nstarting from ```x``` and ```y``` and having ```length``` and ```width```",14],[6,"GenericImage","","A trait for manipulating images."],[9,"dimensions","","The width and height of this image.",15],[9,"bounds","","The bounding rectangle of this image.",15],[9,"get_pixel","","Return the pixel located at (x, y)",15],[9,"put_pixel","","Put a pixel at location (x, y)",15],[10,"pixels","","Return an Iterator over the pixels of this image.\nThe iterator yields the coordinates of each pixel\nalong with their value",15],[6,"MutableRefImage","","A trait for images that allow providing mutable references to pixels."],[9,"get_mut_pixel","","Return a mutable reference to the pixel located at (x, y)",16],[10,"mut_pixels","","Return an Iterator over mutable pixels of this image.\nThe iterator yields the coordinates of each pixel\nalong with a mutable reference to them.",16]],"paths":[[2,"ColorType"],[2,"ImageError"],[2,"ImageFormat"],[2,"FilterType"],[2,"DynamicImage"],[1,"Frame"],[1,"VP8Decoder"],[1,"ZlibDecoder"],[1,"Inflater"],[1,"Adler32"],[1,"Crc32"],[1,"Component"],[1,"LZWReader"],[6,"Pixel"],[6,"ImageDecoder"],[6,"GenericImage"],[6,"MutableRefImage"]]};
initSearch(searchIndex);
