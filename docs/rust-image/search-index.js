var searchIndex = {};
searchIndex['image'] = {"items":[[0,"","image","This crate provides native rust implementations of\nImage encoders and decoders and basic image manipulation\nfunctions."],[1,"Luma","","A type to hold a grayscale pixel"],[1,"LumaA","","A type to hold a grayscale pixel with an alha channel"],[1,"Rgb","","A type to hold an RGB pixel"],[1,"Rgba","","A type to hold an RGB pixel with an alpha channel"],[1,"SubImage","","A View into another image"],[11,"image","","",0],[11,"xoffset","","",0],[11,"yoffset","","",0],[11,"xstride","","",0],[11,"ystride","","",0],[1,"ImageBuf","","An Image whose pixels are contained within a vector"],[11,"pixels","","",1],[11,"width","","",1],[11,"height","","",1],[1,"Pixels","","Immutable pixel iterator"],[11,"image","","",2],[11,"x","","",2],[11,"y","","",2],[11,"width","","",2],[11,"height","","",2],[1,"MutPixels","","Mutable pixel iterator"],[11,"image","","",3],[11,"x","","",3],[11,"y","","",3],[11,"width","","",3],[11,"height","","",3],[2,"ColorType","","An enumeration over supported color types and their bit depths"],[12,"Grey","","Pixel is greyscale",4],[12,"RGB","","Pixel contains R, G and B channels",4],[12,"Palette","","Pixel is an index into a color palette",4],[12,"GreyA","","Pixel is greyscale with an alpha channel",4],[12,"RGBA","","Pixel is RGB with an alpha channel",4],[2,"ImageError","","An enumeration of Image Errors"],[12,"FormatError","","The Image is not formatted properly",5],[12,"DimensionError","","The Image's dimensions are either too small or too large",5],[12,"UnsupportedError","","The Decoder does not support this image format",5],[12,"UnsupportedColor","","The Decoder does not support this color type",5],[12,"NotEnoughData","","Not enough data was provided to the Decoder\nto decode the image",5],[12,"IoError","","An I/O Error occurred while decoding the image",5],[12,"ImageEnd","","The end of the image has been reached",5],[2,"ImageFormat","","An enumeration of supported image formats.\nNot all formats support both encoding and decoding."],[12,"PNG","","An Image in PNG Format",6],[12,"JPEG","","An Image in JPEG Format",6],[12,"GIF","","An Image in GIF Format",6],[12,"WEBP","","An Image in WEBP Format",6],[12,"PPM","","An Image in PPM Format",6],[2,"FilterType","","Available Sampling Filters"],[12,"Nearest","","Nearest Neighbor",7],[12,"Triangle","","Linear Filter",7],[12,"CatmullRom","","Cubic Filter",7],[12,"Gaussian","","Gaussian Filter",7],[12,"Lanczos3","","Lanczos with window 3",7],[2,"DynamicImage","","A Dynamic Image"],[12,"ImageLuma8","","Each pixel in this image is 8-bit Luma",8],[12,"ImageLumaA8","","Each pixel in this image is 8-bit Luma with alpha",8],[12,"ImageRgb8","","Each pixel in this image is 8-bit Rgb",8],[12,"ImageRgba8","","Each pixel in this image is 8-bit Rgb with alpha",8],[3,"open","","Open the image located at the path specified.\nThe image's format is determined from the path's file extension."],[3,"load","","Create a new image from a Reader"],[3,"load_from_memory","","Create a new image from a byte slice"],[0,"imageops","","Image Processing Functions"],[2,"FilterType","image::imageops","Available Sampling Filters"],[12,"Nearest","","Nearest Neighbor",7],[12,"Triangle","","Linear Filter",7],[12,"CatmullRom","","Cubic Filter",7],[12,"Gaussian","","Gaussian Filter",7],[12,"Lanczos3","","Lanczos with window 3",7],[3,"rotate90","","Rotate an image 90 degrees clockwise."],[3,"rotate180","","Rotate an image 180 degrees clockwise."],[3,"rotate270","","Rotate an image 270 degrees clockwise."],[3,"flip_horizontal","","Flip an image horizontally"],[3,"flip_vertical","","Flip an image vertically"],[3,"filter3x3","","Perform a 3x3 box filter on the supplied image.\n```kernel``` is an array of the filter weights of length 9."],[3,"resize","","Resize the supplied image to the specified dimensions\n```nwidth``` and ```nheight``` are the new dimensions.\n```filter``` is the sampling filter to use."],[3,"blur","","Perfomrs a Gausian blur on the supplied image.\n```sigma``` is a meausure of how much to blur by."],[3,"unsharpen","","Performs an unsharpen mask on the supplied image\n```sigma``` is the amount to blur the image by.\n```threshold``` is the threshold for the difference between\nsee https://en.wikipedia.org/wiki/Unsharp_masking#Digital_unsharp_masking"],[3,"grayscale","","Convert the supplied image to grayscale"],[3,"invert","","Invert each pixel within the supplied image\nThis function operates in place."],[3,"contrast","","Adjust the contrast of the supplied image\n```contrast``` is the amount to adjust the contrast by.\nNegative values decrease the constrast and positive values increase the constrast."],[3,"brighten","","Brighten the supplied image\n```value``` is the amount to brighten each pixel by.\nNegative values decrease the brightness and positive values increase it."],[3,"crop","","Return a mutable view into an image"],[0,"webp","image","Decoding of Webp Images"],[1,"WebpDecoder","image::webp","A Representaion of a Webp Image format decoder."],[11,"r","","",9],[11,"frame","","",9],[11,"have_frame","","",9],[11,"decoded_rows","","",9],[0,"vp8","","An implementation of the VP8 Video Codec"],[1,"Frame","image::webp::vp8","A Representation of the last decoded video frame"],[11,"width","","The width of the luma plane",10],[11,"height","","The height of the luma plane",10],[11,"ybuf","","The luma plane of the frame",10],[11,"keyframe","","Indicates whether this frame is a keyframe",10],[11,"version","","",10],[11,"for_display","","Indicates whether this frame is intended for display",10],[11,"pixel_type","","The pixel type of the frame as defined by Section 9.2\nof the VP8 Specification",10],[11,"filter","","",10],[11,"filter_level","","",10],[11,"sharpness_level","","",10],[1,"VP8Decoder","","VP8 Decoder\nOnly decodes keyframes"],[11,"r","","",11],[11,"b","","",11],[11,"mbwidth","","",11],[11,"mbheight","","",11],[11,"frame","","",11],[11,"segments_enabled","","",11],[11,"segments_update_map","","",11],[11,"segment","","",11],[11,"partitions","","",11],[11,"num_partitions","","",11],[11,"segment_tree_probs","","",11],[11,"token_probs","","",11],[11,"prob_intra","","",11],[11,"prob_skip_false","","",11],[11,"top","","",11],[11,"left","","",11],[11,"top_border","","",11],[11,"left_border","","",11],[10,"clone","","",10],[10,"fmt","","",10],[10,"default","","",10],[10,"new","","Create a new decoder.\nThe reader must present a raw vp8 bitstream to the decoder",11],[10,"decode_frame","","Decodes the current frame and returns a reference to it",11],[0,"ppm","image","Encoding of portable pixmap Images"],[1,"PPMEncoder","image::ppm","A representation of a PPM encoder."],[11,"w","","",12],[0,"png","image","Decoding and Encoding of PNG Images"],[1,"PNGDecoder","image::png","The representation of a PNG decoder"],[11,"z","","",13],[11,"crc","","",13],[11,"previous","","",13],[11,"state","","",13],[11,"width","","",13],[11,"height","","",13],[11,"bit_depth","","",13],[11,"colour_type","","",13],[11,"pixel_type","","",13],[11,"palette","","",13],[11,"interlace_method","","",13],[11,"chunk_length","","",13],[11,"chunk_type","","",13],[11,"bpp","","",13],[11,"rlength","","",13],[11,"decoded_rows","","",13],[1,"PNGEncoder","","The representation of a PNG encoder"],[11,"w","","",14],[11,"crc","","",14],[0,"zlib","","An Implementation of RFC 1950"],[1,"ZlibDecoder","image::png::zlib","A Zlib compressed stream decoder."],[11,"inflate","","",15],[11,"adler","","",15],[11,"state","","",15],[10,"new","","Create a new decoder that decodes from a Reader",15],[10,"inner","","Return a mutable reference to the wrapped Reader",15],[10,"read","","",15],[0,"deflate","image::png","An Implementation of RFC 1951"],[1,"Inflater","image::png::deflate","A DEFLATE compressed stream decoder."],[11,"h","","",16],[11,"buf","","",16],[11,"pos","","",16],[11,"final","","",16],[11,"btype","","",16],[11,"block_length","","",16],[11,"ctable","","",16],[11,"lltable","","",16],[11,"dtable","","",16],[10,"new","","Create a new decoder that decodes from a Reader",16],[10,"eof","","Indicate whether the end of the stream has been reached.",16],[10,"inner","","Return a mutable reference to the wrapped Reader",16],[10,"read","","",16],[0,"hash","image::png","This module provides implementations of common hashing algorithms."],[1,"Adler32","image::png::hash","An Implementation of the Adler-32 checksum"],[11,"s1","","",17],[11,"s2","","",17],[1,"Crc32","","An Implementation of the Crc-32 checksum"],[11,"crc","","",18],[10,"new","","Create a new hasher.",17],[10,"update","","Update the internal hasher with the bytes from ```buf```",17],[10,"checksum","","Return the computed hash.",17],[10,"reset","","Reset this hasher to its inital state.",17],[10,"new","","Create a new hasher.",18],[10,"update","","Update the internal hasher with the bytes from ```buf```",18],[10,"checksum","","Return the computed hash.",18],[10,"reset","","Reset this hasher to its inital state.",18],[0,"jpeg","image","Decoding and Encoding of JPEG Images"],[1,"JPEGDecoder","image::jpeg","The representation of a JPEG decoder"],[11,"r","","",19],[11,"qtables","","",19],[11,"dctables","","",19],[11,"actables","","",19],[11,"h","","",19],[11,"height","","",19],[11,"width","","",19],[11,"num_components","","",19],[11,"scan_components","","",19],[11,"components","","",19],[11,"mcu_row","","",19],[11,"mcu","","",19],[11,"hmax","","",19],[11,"vmax","","",19],[11,"interval","","",19],[11,"mcucount","","",19],[11,"expected_rst","","",19],[11,"row_count","","",19],[11,"decoded_rows","","",19],[11,"padded_width","","",19],[11,"state","","",19],[1,"JPEGEncoder","","The representation of a JPEG encoder"],[11,"w","","",20],[11,"components","","",20],[11,"tables","","",20],[11,"accumulator","","",20],[11,"nbits","","",20],[11,"luma_dctable","","",20],[11,"luma_actable","","",20],[11,"chroma_dctable","","",20],[11,"chroma_actable","","",20],[1,"Component","","A representation of a JPEG component"],[11,"id","","The Component's identifier",21],[11,"h","","Horizontal sampling factor",21],[11,"v","","Vertical sampling factor",21],[11,"tq","","The quantization table selector",21],[11,"dc_table","","Index to the Huffman DC Table",21],[11,"ac_table","","Index to the AC Huffman Table",21],[11,"dc_pred","","The dc prediction of the component",21],[0,"gif","image","Decoding of GIF Images"],[1,"GIFDecoder","image::gif","The Representation of a GIF decoder"],[11,"r","","",22],[11,"width","","",22],[11,"height","","",22],[11,"global_table","","",22],[11,"local_table","","",22],[11,"delay","","",22],[11,"image","","",22],[11,"global_backgroud_index","","",22],[11,"local_transparent_index","","",22],[11,"have_header","","",22],[11,"decoded_rows","","",22],[0,"lzw","","This modules provides an implementation of the Lempel–Ziv–Welch Compression Algorithm"],[1,"LZWReader","image::gif::lzw","An implementation of an LZW Decompressor."],[11,"r","","",23],[11,"dict","","",23],[11,"prev","","",23],[11,"accumulator","","",23],[11,"num_bits","","",23],[11,"initial_size","","",23],[11,"code_size","","",23],[11,"next_code","","",23],[11,"end","","",23],[11,"clear","","",23],[11,"eof","","",23],[11,"out","","",23],[11,"pos","","",23],[10,"new","","Create a new decompressor from a Reader",23],[10,"read","","",23],[4,"ImageResult","image",""],[6,"Pixel","","A trait that all pixels implement."],[9,"from_channels","","Construct a pixel from the 4 channels a, b, c and d.\nIf the pixel does not contain 4 channels the extra are ignored.",24],[9,"to_rgb","","Convert this pixel to RGB",24],[9,"to_rgba","","Convert this pixel to RGB with an alpha channel",24],[9,"to_luma","","Convert this pixel to luma",24],[9,"to_luma_alpha","","Convert this pixel to luma with an alpha channel",24],[9,"invert","","Invert this pixel",24],[9,"map","","Apply the function ```f``` to each channel of this pixel.",24],[9,"map_with_alpha","","Apply the function f to each channel except the alpha channel.\nApply the function g to the alpha channel.",24],[9,"map2","","Apply the function ```f``` to each channel of this pixel and\n```other``` pairwise.",24],[9,"channels4","","Returns the channels of this pixes as a 4 tuple. If the pixel\nhas less than 4 channels the remainder is filled with the maximum value",24],[6,"ImageDecoder","","The trait that all decoders implement"],[9,"dimensions","","Return a tuple containing the width and height of the image",25],[9,"colortype","","Return the color type of the image e.g RGB(8) (8bit RGB)",25],[9,"row_len","","Returns the length in bytes of one decoded row of the image",25],[9,"read_scanline","","Read one row from the image into buf\nReturns the row index",25],[9,"read_image","","Decode the entire image and return it as a Vector",25],[10,"load_rect","","Decode a specific region of the image, represented by the rectangle\nstarting from ```x``` and ```y``` and having ```length``` and ```width```",25],[6,"GenericImage","","A trait for manipulating images."],[9,"dimensions","","The width and height of this image.",26],[9,"bounds","","The bounding rectange of this image.",26],[9,"get_pixel","","Return the pixel located at (x, y)",26],[9,"put_pixel","","Put a pixel at location (x, y)",26],[10,"pixels","","Return an Iterator over the pixels of this image.\nThe iterator yeilds the coordiates of each pixel\nalong with their value",26],[6,"MutableRefImage","","A trait for images that allow providing mutable references to pixels."],[9,"get_mut_pixel","","Return a mutable reference to the pixel located at (x, y)",27],[10,"mut_pixels","","Return an Iterator over mutable pixels of this image.\nThe iterator yeilds the coordiates of each pixel\nalong with a mutable reference to them.",27]],"paths":[[1,"SubImage"],[1,"ImageBuf"],[1,"Pixels"],[1,"MutPixels"],[2,"ColorType"],[2,"ImageError"],[2,"ImageFormat"],[2,"FilterType"],[2,"DynamicImage"],[1,"WebpDecoder"],[1,"Frame"],[1,"VP8Decoder"],[1,"PPMEncoder"],[1,"PNGDecoder"],[1,"PNGEncoder"],[1,"ZlibDecoder"],[1,"Inflater"],[1,"Adler32"],[1,"Crc32"],[1,"JPEGDecoder"],[1,"JPEGEncoder"],[1,"Component"],[1,"GIFDecoder"],[1,"LZWReader"],[6,"Pixel"],[6,"ImageDecoder"],[6,"GenericImage"],[6,"MutableRefImage"]]};
initSearch(searchIndex);
